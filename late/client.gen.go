// Package late provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package late

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes   = "bearerAuth.Scopes"
	ConnectTokenScopes = "connectToken.Scopes"
)

// Defines values for AnalyticsListResponsePostsMediaType.
const (
	AnalyticsListResponsePostsMediaTypeDocument AnalyticsListResponsePostsMediaType = "document"
	AnalyticsListResponsePostsMediaTypeGif      AnalyticsListResponsePostsMediaType = "gif"
	AnalyticsListResponsePostsMediaTypeImage    AnalyticsListResponsePostsMediaType = "image"
	AnalyticsListResponsePostsMediaTypeVideo    AnalyticsListResponsePostsMediaType = "video"
)

// Defines values for FacebookPlatformDataContentType.
const (
	FacebookPlatformDataContentTypeStory FacebookPlatformDataContentType = "story"
)

// Defines values for GoogleBusinessPlatformDataCallToActionType.
const (
	BOOK      GoogleBusinessPlatformDataCallToActionType = "BOOK"
	CALL      GoogleBusinessPlatformDataCallToActionType = "CALL"
	LEARNMORE GoogleBusinessPlatformDataCallToActionType = "LEARN_MORE"
	ORDER     GoogleBusinessPlatformDataCallToActionType = "ORDER"
	SHOP      GoogleBusinessPlatformDataCallToActionType = "SHOP"
	SIGNUP    GoogleBusinessPlatformDataCallToActionType = "SIGN_UP"
)

// Defines values for InstagramPlatformDataContentType.
const (
	InstagramPlatformDataContentTypeStory InstagramPlatformDataContentType = "story"
)

// Defines values for InstagramPlatformDataTrialParamsGraduationStrategy.
const (
	MANUAL        InstagramPlatformDataTrialParamsGraduationStrategy = "MANUAL"
	SSPERFORMANCE InstagramPlatformDataTrialParamsGraduationStrategy = "SS_PERFORMANCE"
)

// Defines values for LinkedInAggregateAnalyticsDailyResponseAggregation.
const (
	LinkedInAggregateAnalyticsDailyResponseAggregationDAILY LinkedInAggregateAnalyticsDailyResponseAggregation = "DAILY"
)

// Defines values for LinkedInAggregateAnalyticsTotalResponseAggregation.
const (
	TOTAL LinkedInAggregateAnalyticsTotalResponseAggregation = "TOTAL"
)

// Defines values for MediaItemType.
const (
	MediaItemTypeDocument MediaItemType = "document"
	MediaItemTypeGif      MediaItemType = "gif"
	MediaItemTypeImage    MediaItemType = "image"
	MediaItemTypeVideo    MediaItemType = "video"
)

// Defines values for PlatformTargetErrorCategory.
const (
	AccountIssue     PlatformTargetErrorCategory = "account_issue"
	AuthExpired      PlatformTargetErrorCategory = "auth_expired"
	PlatformError    PlatformTargetErrorCategory = "platform_error"
	PlatformRejected PlatformTargetErrorCategory = "platform_rejected"
	SystemError      PlatformTargetErrorCategory = "system_error"
	Unknown          PlatformTargetErrorCategory = "unknown"
	UserAbuse        PlatformTargetErrorCategory = "user_abuse"
	UserContent      PlatformTargetErrorCategory = "user_content"
)

// Defines values for PlatformTargetErrorSource.
const (
	PlatformTargetErrorSourcePlatform PlatformTargetErrorSource = "platform"
	PlatformTargetErrorSourceSystem   PlatformTargetErrorSource = "system"
	PlatformTargetErrorSourceUser     PlatformTargetErrorSource = "user"
)

// Defines values for PostStatus.
const (
	PostStatusDraft      PostStatus = "draft"
	PostStatusFailed     PostStatus = "failed"
	PostStatusPartial    PostStatus = "partial"
	PostStatusPublished  PostStatus = "published"
	PostStatusPublishing PostStatus = "publishing"
	PostStatusScheduled  PostStatus = "scheduled"
)

// Defines values for PostVisibility.
const (
	PostVisibilityPrivate  PostVisibility = "private"
	PostVisibilityPublic   PostVisibility = "public"
	PostVisibilityUnlisted PostVisibility = "unlisted"
)

// Defines values for PostLogAction.
const (
	PostLogActionCancelled      PostLogAction = "cancelled"
	PostLogActionMediaUpload    PostLogAction = "media_upload"
	PostLogActionPublish        PostLogAction = "publish"
	PostLogActionRateLimitPause PostLogAction = "rate_limit_pause"
	PostLogActionRetry          PostLogAction = "retry"
	PostLogActionTokenRefresh   PostLogAction = "token_refresh"
)

// Defines values for PostLogPlatform.
const (
	PostLogPlatformBluesky        PostLogPlatform = "bluesky"
	PostLogPlatformFacebook       PostLogPlatform = "facebook"
	PostLogPlatformGooglebusiness PostLogPlatform = "googlebusiness"
	PostLogPlatformInstagram      PostLogPlatform = "instagram"
	PostLogPlatformLinkedin       PostLogPlatform = "linkedin"
	PostLogPlatformPinterest      PostLogPlatform = "pinterest"
	PostLogPlatformReddit         PostLogPlatform = "reddit"
	PostLogPlatformSnapchat       PostLogPlatform = "snapchat"
	PostLogPlatformTelegram       PostLogPlatform = "telegram"
	PostLogPlatformThreads        PostLogPlatform = "threads"
	PostLogPlatformTiktok         PostLogPlatform = "tiktok"
	PostLogPlatformTwitter        PostLogPlatform = "twitter"
	PostLogPlatformYoutube        PostLogPlatform = "youtube"
)

// Defines values for PostLogStatus.
const (
	PostLogStatusFailed  PostLogStatus = "failed"
	PostLogStatusPending PostLogStatus = "pending"
	PostLogStatusSkipped PostLogStatus = "skipped"
	PostLogStatusSuccess PostLogStatus = "success"
)

// Defines values for PostLogDetailAction.
const (
	PostLogDetailActionCancelled      PostLogDetailAction = "cancelled"
	PostLogDetailActionMediaUpload    PostLogDetailAction = "media_upload"
	PostLogDetailActionPublish        PostLogDetailAction = "publish"
	PostLogDetailActionRateLimitPause PostLogDetailAction = "rate_limit_pause"
	PostLogDetailActionRetry          PostLogDetailAction = "retry"
	PostLogDetailActionTokenRefresh   PostLogDetailAction = "token_refresh"
)

// Defines values for PostLogDetailPlatform.
const (
	PostLogDetailPlatformBluesky        PostLogDetailPlatform = "bluesky"
	PostLogDetailPlatformFacebook       PostLogDetailPlatform = "facebook"
	PostLogDetailPlatformGooglebusiness PostLogDetailPlatform = "googlebusiness"
	PostLogDetailPlatformInstagram      PostLogDetailPlatform = "instagram"
	PostLogDetailPlatformLinkedin       PostLogDetailPlatform = "linkedin"
	PostLogDetailPlatformPinterest      PostLogDetailPlatform = "pinterest"
	PostLogDetailPlatformReddit         PostLogDetailPlatform = "reddit"
	PostLogDetailPlatformSnapchat       PostLogDetailPlatform = "snapchat"
	PostLogDetailPlatformTelegram       PostLogDetailPlatform = "telegram"
	PostLogDetailPlatformThreads        PostLogDetailPlatform = "threads"
	PostLogDetailPlatformTiktok         PostLogDetailPlatform = "tiktok"
	PostLogDetailPlatformTwitter        PostLogDetailPlatform = "twitter"
	PostLogDetailPlatformYoutube        PostLogDetailPlatform = "youtube"
)

// Defines values for PostLogDetailStatus.
const (
	PostLogDetailStatusFailed  PostLogDetailStatus = "failed"
	PostLogDetailStatusPending PostLogDetailStatus = "pending"
	PostLogDetailStatusSkipped PostLogDetailStatus = "skipped"
	PostLogDetailStatusSuccess PostLogDetailStatus = "success"
)

// Defines values for SnapchatPlatformDataContentType.
const (
	SavedStory SnapchatPlatformDataContentType = "saved_story"
	Spotlight  SnapchatPlatformDataContentType = "spotlight"
	Story      SnapchatPlatformDataContentType = "story"
)

// Defines values for TelegramPlatformDataParseMode.
const (
	HTML       TelegramPlatformDataParseMode = "HTML"
	Markdown   TelegramPlatformDataParseMode = "Markdown"
	MarkdownV2 TelegramPlatformDataParseMode = "MarkdownV2"
)

// Defines values for TikTokPlatformDataCommercialContentType.
const (
	BrandContent TikTokPlatformDataCommercialContentType = "brand_content"
	BrandOrganic TikTokPlatformDataCommercialContentType = "brand_organic"
	None         TikTokPlatformDataCommercialContentType = "none"
)

// Defines values for TikTokPlatformDataMediaType.
const (
	TikTokPlatformDataMediaTypePhoto TikTokPlatformDataMediaType = "photo"
	TikTokPlatformDataMediaTypeVideo TikTokPlatformDataMediaType = "video"
)

// Defines values for UsageStatsBillingPeriod.
const (
	UsageStatsBillingPeriodMonthly UsageStatsBillingPeriod = "monthly"
	UsageStatsBillingPeriodYearly  UsageStatsBillingPeriod = "yearly"
)

// Defines values for WebhookEvents.
const (
	WebhookEventsAccountConnected    WebhookEvents = "account.connected"
	WebhookEventsAccountDisconnected WebhookEvents = "account.disconnected"
	WebhookEventsMessageReceived     WebhookEvents = "message.received"
	WebhookEventsPostFailed          WebhookEvents = "post.failed"
	WebhookEventsPostPartial         WebhookEvents = "post.partial"
	WebhookEventsPostPublished       WebhookEvents = "post.published"
	WebhookEventsPostScheduled       WebhookEvents = "post.scheduled"
)

// Defines values for WebhookLogEvent.
const (
	WebhookLogEventAccountConnected    WebhookLogEvent = "account.connected"
	WebhookLogEventAccountDisconnected WebhookLogEvent = "account.disconnected"
	WebhookLogEventMessageReceived     WebhookLogEvent = "message.received"
	WebhookLogEventPostFailed          WebhookLogEvent = "post.failed"
	WebhookLogEventPostPartial         WebhookLogEvent = "post.partial"
	WebhookLogEventPostPublished       WebhookLogEvent = "post.published"
	WebhookLogEventPostScheduled       WebhookLogEvent = "post.scheduled"
	WebhookLogEventWebhookTest         WebhookLogEvent = "webhook.test"
)

// Defines values for WebhookLogStatus.
const (
	WebhookLogStatusFailed  WebhookLogStatus = "failed"
	WebhookLogStatusSuccess WebhookLogStatus = "success"
)

// Defines values for YouTubePlatformDataVisibility.
const (
	YouTubePlatformDataVisibilityPrivate  YouTubePlatformDataVisibility = "private"
	YouTubePlatformDataVisibilityPublic   YouTubePlatformDataVisibility = "public"
	YouTubePlatformDataVisibilityUnlisted YouTubePlatformDataVisibility = "unlisted"
)

// Defines values for GetFollowerStatsParamsGranularity.
const (
	GetFollowerStatsParamsGranularityDaily   GetFollowerStatsParamsGranularity = "daily"
	GetFollowerStatsParamsGranularityMonthly GetFollowerStatsParamsGranularity = "monthly"
	GetFollowerStatsParamsGranularityWeekly  GetFollowerStatsParamsGranularity = "weekly"
)

// Defines values for GetAllAccountsHealthParamsPlatform.
const (
	GetAllAccountsHealthParamsPlatformBluesky        GetAllAccountsHealthParamsPlatform = "bluesky"
	GetAllAccountsHealthParamsPlatformFacebook       GetAllAccountsHealthParamsPlatform = "facebook"
	GetAllAccountsHealthParamsPlatformGooglebusiness GetAllAccountsHealthParamsPlatform = "googlebusiness"
	GetAllAccountsHealthParamsPlatformInstagram      GetAllAccountsHealthParamsPlatform = "instagram"
	GetAllAccountsHealthParamsPlatformLinkedin       GetAllAccountsHealthParamsPlatform = "linkedin"
	GetAllAccountsHealthParamsPlatformPinterest      GetAllAccountsHealthParamsPlatform = "pinterest"
	GetAllAccountsHealthParamsPlatformReddit         GetAllAccountsHealthParamsPlatform = "reddit"
	GetAllAccountsHealthParamsPlatformSnapchat       GetAllAccountsHealthParamsPlatform = "snapchat"
	GetAllAccountsHealthParamsPlatformTelegram       GetAllAccountsHealthParamsPlatform = "telegram"
	GetAllAccountsHealthParamsPlatformThreads        GetAllAccountsHealthParamsPlatform = "threads"
	GetAllAccountsHealthParamsPlatformTiktok         GetAllAccountsHealthParamsPlatform = "tiktok"
	GetAllAccountsHealthParamsPlatformTwitter        GetAllAccountsHealthParamsPlatform = "twitter"
	GetAllAccountsHealthParamsPlatformYoutube        GetAllAccountsHealthParamsPlatform = "youtube"
)

// Defines values for GetAllAccountsHealthParamsStatus.
const (
	Error   GetAllAccountsHealthParamsStatus = "error"
	Healthy GetAllAccountsHealthParamsStatus = "healthy"
	Warning GetAllAccountsHealthParamsStatus = "warning"
)

// Defines values for CreateGoogleBusinessMediaJSONBodyCategory.
const (
	ADDITIONAL   CreateGoogleBusinessMediaJSONBodyCategory = "ADDITIONAL"
	COVER        CreateGoogleBusinessMediaJSONBodyCategory = "COVER"
	EXTERIOR     CreateGoogleBusinessMediaJSONBodyCategory = "EXTERIOR"
	FOODANDDRINK CreateGoogleBusinessMediaJSONBodyCategory = "FOOD_AND_DRINK"
	INTERIOR     CreateGoogleBusinessMediaJSONBodyCategory = "INTERIOR"
	LOGO         CreateGoogleBusinessMediaJSONBodyCategory = "LOGO"
	MENU         CreateGoogleBusinessMediaJSONBodyCategory = "MENU"
	PRODUCT      CreateGoogleBusinessMediaJSONBodyCategory = "PRODUCT"
	PROFILE      CreateGoogleBusinessMediaJSONBodyCategory = "PROFILE"
	TEAMS        CreateGoogleBusinessMediaJSONBodyCategory = "TEAMS"
)

// Defines values for CreateGoogleBusinessMediaJSONBodyMediaFormat.
const (
	PHOTO CreateGoogleBusinessMediaJSONBodyMediaFormat = "PHOTO"
	VIDEO CreateGoogleBusinessMediaJSONBodyMediaFormat = "VIDEO"
)

// Defines values for CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType.
const (
	APPOINTMENT       CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "APPOINTMENT"
	DININGRESERVATION CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "DINING_RESERVATION"
	FOODDELIVERY      CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "FOOD_DELIVERY"
	FOODORDERING      CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "FOOD_ORDERING"
	FOODTAKEOUT       CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "FOOD_TAKEOUT"
	ONLINEAPPOINTMENT CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "ONLINE_APPOINTMENT"
	SHOPONLINE        CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType = "SHOP_ONLINE"
)

// Defines values for GetLinkedInAggregateAnalyticsParamsAggregation.
const (
	GetLinkedInAggregateAnalyticsParamsAggregationDAILY GetLinkedInAggregateAnalyticsParamsAggregation = "DAILY"
	GetLinkedInAggregateAnalyticsParamsAggregationTOTAL GetLinkedInAggregateAnalyticsParamsAggregation = "TOTAL"
)

// Defines values for UpdateLinkedInOrganizationJSONBodyAccountType.
const (
	UpdateLinkedInOrganizationJSONBodyAccountTypeOrganization UpdateLinkedInOrganizationJSONBodyAccountType = "organization"
	UpdateLinkedInOrganizationJSONBodyAccountTypePersonal     UpdateLinkedInOrganizationJSONBodyAccountType = "personal"
)

// Defines values for GetAnalyticsParamsSource.
const (
	GetAnalyticsParamsSourceAll      GetAnalyticsParamsSource = "all"
	GetAnalyticsParamsSourceExternal GetAnalyticsParamsSource = "external"
	GetAnalyticsParamsSourceLate     GetAnalyticsParamsSource = "late"
)

// Defines values for GetAnalyticsParamsSortBy.
const (
	GetAnalyticsParamsSortByDate       GetAnalyticsParamsSortBy = "date"
	GetAnalyticsParamsSortByEngagement GetAnalyticsParamsSortBy = "engagement"
)

// Defines values for GetAnalyticsParamsOrder.
const (
	GetAnalyticsParamsOrderAsc  GetAnalyticsParamsOrder = "asc"
	GetAnalyticsParamsOrderDesc GetAnalyticsParamsOrder = "desc"
)

// Defines values for SelectLinkedInOrganizationJSONBodyAccountType.
const (
	SelectLinkedInOrganizationJSONBodyAccountTypeOrganization SelectLinkedInOrganizationJSONBodyAccountType = "organization"
	SelectLinkedInOrganizationJSONBodyAccountTypePersonal     SelectLinkedInOrganizationJSONBodyAccountType = "personal"
)

// Defines values for GetConnectUrlParamsPlatform.
const (
	GetConnectUrlParamsPlatformBluesky        GetConnectUrlParamsPlatform = "bluesky"
	GetConnectUrlParamsPlatformFacebook       GetConnectUrlParamsPlatform = "facebook"
	GetConnectUrlParamsPlatformGooglebusiness GetConnectUrlParamsPlatform = "googlebusiness"
	GetConnectUrlParamsPlatformInstagram      GetConnectUrlParamsPlatform = "instagram"
	GetConnectUrlParamsPlatformLinkedin       GetConnectUrlParamsPlatform = "linkedin"
	GetConnectUrlParamsPlatformPinterest      GetConnectUrlParamsPlatform = "pinterest"
	GetConnectUrlParamsPlatformReddit         GetConnectUrlParamsPlatform = "reddit"
	GetConnectUrlParamsPlatformSnapchat       GetConnectUrlParamsPlatform = "snapchat"
	GetConnectUrlParamsPlatformTelegram       GetConnectUrlParamsPlatform = "telegram"
	GetConnectUrlParamsPlatformThreads        GetConnectUrlParamsPlatform = "threads"
	GetConnectUrlParamsPlatformTiktok         GetConnectUrlParamsPlatform = "tiktok"
	GetConnectUrlParamsPlatformTwitter        GetConnectUrlParamsPlatform = "twitter"
	GetConnectUrlParamsPlatformYoutube        GetConnectUrlParamsPlatform = "youtube"
)

// Defines values for ListInboxCommentsParamsPlatform.
const (
	ListInboxCommentsParamsPlatformBluesky   ListInboxCommentsParamsPlatform = "bluesky"
	ListInboxCommentsParamsPlatformFacebook  ListInboxCommentsParamsPlatform = "facebook"
	ListInboxCommentsParamsPlatformInstagram ListInboxCommentsParamsPlatform = "instagram"
	ListInboxCommentsParamsPlatformLinkedin  ListInboxCommentsParamsPlatform = "linkedin"
	ListInboxCommentsParamsPlatformReddit    ListInboxCommentsParamsPlatform = "reddit"
	ListInboxCommentsParamsPlatformThreads   ListInboxCommentsParamsPlatform = "threads"
	ListInboxCommentsParamsPlatformTiktok    ListInboxCommentsParamsPlatform = "tiktok"
	ListInboxCommentsParamsPlatformTwitter   ListInboxCommentsParamsPlatform = "twitter"
	ListInboxCommentsParamsPlatformYoutube   ListInboxCommentsParamsPlatform = "youtube"
)

// Defines values for ListInboxCommentsParamsSortBy.
const (
	ListInboxCommentsParamsSortByComments ListInboxCommentsParamsSortBy = "comments"
	ListInboxCommentsParamsSortByDate     ListInboxCommentsParamsSortBy = "date"
)

// Defines values for ListInboxCommentsParamsSortOrder.
const (
	ListInboxCommentsParamsSortOrderAsc  ListInboxCommentsParamsSortOrder = "asc"
	ListInboxCommentsParamsSortOrderDesc ListInboxCommentsParamsSortOrder = "desc"
)

// Defines values for ListInboxConversationsParamsPlatform.
const (
	ListInboxConversationsParamsPlatformBluesky   ListInboxConversationsParamsPlatform = "bluesky"
	ListInboxConversationsParamsPlatformFacebook  ListInboxConversationsParamsPlatform = "facebook"
	ListInboxConversationsParamsPlatformInstagram ListInboxConversationsParamsPlatform = "instagram"
	ListInboxConversationsParamsPlatformReddit    ListInboxConversationsParamsPlatform = "reddit"
	ListInboxConversationsParamsPlatformTelegram  ListInboxConversationsParamsPlatform = "telegram"
	ListInboxConversationsParamsPlatformTwitter   ListInboxConversationsParamsPlatform = "twitter"
)

// Defines values for ListInboxConversationsParamsStatus.
const (
	ListInboxConversationsParamsStatusActive   ListInboxConversationsParamsStatus = "active"
	ListInboxConversationsParamsStatusArchived ListInboxConversationsParamsStatus = "archived"
)

// Defines values for ListInboxConversationsParamsSortOrder.
const (
	ListInboxConversationsParamsSortOrderAsc  ListInboxConversationsParamsSortOrder = "asc"
	ListInboxConversationsParamsSortOrderDesc ListInboxConversationsParamsSortOrder = "desc"
)

// Defines values for UpdateInboxConversationJSONBodyStatus.
const (
	UpdateInboxConversationJSONBodyStatusActive   UpdateInboxConversationJSONBodyStatus = "active"
	UpdateInboxConversationJSONBodyStatusArchived UpdateInboxConversationJSONBodyStatus = "archived"
)

// Defines values for ListInboxReviewsParamsPlatform.
const (
	ListInboxReviewsParamsPlatformFacebook       ListInboxReviewsParamsPlatform = "facebook"
	ListInboxReviewsParamsPlatformGooglebusiness ListInboxReviewsParamsPlatform = "googlebusiness"
)

// Defines values for ListInboxReviewsParamsSortBy.
const (
	Date   ListInboxReviewsParamsSortBy = "date"
	Rating ListInboxReviewsParamsSortBy = "rating"
)

// Defines values for ListInboxReviewsParamsSortOrder.
const (
	ListInboxReviewsParamsSortOrderAsc  ListInboxReviewsParamsSortOrder = "asc"
	ListInboxReviewsParamsSortOrderDesc ListInboxReviewsParamsSortOrder = "desc"
)

// Defines values for CreateInviteTokenJSONBodyScope.
const (
	CreateInviteTokenJSONBodyScopeAll      CreateInviteTokenJSONBodyScope = "all"
	CreateInviteTokenJSONBodyScopeProfiles CreateInviteTokenJSONBodyScope = "profiles"
)

// Defines values for ListLogsParamsStatus.
const (
	ListLogsParamsStatusAll     ListLogsParamsStatus = "all"
	ListLogsParamsStatusFailed  ListLogsParamsStatus = "failed"
	ListLogsParamsStatusPending ListLogsParamsStatus = "pending"
	ListLogsParamsStatusSkipped ListLogsParamsStatus = "skipped"
	ListLogsParamsStatusSuccess ListLogsParamsStatus = "success"
)

// Defines values for ListLogsParamsPlatform.
const (
	ListLogsParamsPlatformAll            ListLogsParamsPlatform = "all"
	ListLogsParamsPlatformBluesky        ListLogsParamsPlatform = "bluesky"
	ListLogsParamsPlatformFacebook       ListLogsParamsPlatform = "facebook"
	ListLogsParamsPlatformGooglebusiness ListLogsParamsPlatform = "googlebusiness"
	ListLogsParamsPlatformInstagram      ListLogsParamsPlatform = "instagram"
	ListLogsParamsPlatformLinkedin       ListLogsParamsPlatform = "linkedin"
	ListLogsParamsPlatformPinterest      ListLogsParamsPlatform = "pinterest"
	ListLogsParamsPlatformReddit         ListLogsParamsPlatform = "reddit"
	ListLogsParamsPlatformSnapchat       ListLogsParamsPlatform = "snapchat"
	ListLogsParamsPlatformTelegram       ListLogsParamsPlatform = "telegram"
	ListLogsParamsPlatformThreads        ListLogsParamsPlatform = "threads"
	ListLogsParamsPlatformTiktok         ListLogsParamsPlatform = "tiktok"
	ListLogsParamsPlatformTwitter        ListLogsParamsPlatform = "twitter"
	ListLogsParamsPlatformYoutube        ListLogsParamsPlatform = "youtube"
)

// Defines values for ListLogsParamsAction.
const (
	ListLogsParamsActionAll            ListLogsParamsAction = "all"
	ListLogsParamsActionCancelled      ListLogsParamsAction = "cancelled"
	ListLogsParamsActionMediaUpload    ListLogsParamsAction = "media_upload"
	ListLogsParamsActionPublish        ListLogsParamsAction = "publish"
	ListLogsParamsActionRateLimitPause ListLogsParamsAction = "rate_limit_pause"
	ListLogsParamsActionRetry          ListLogsParamsAction = "retry"
	ListLogsParamsActionTokenRefresh   ListLogsParamsAction = "token_refresh"
)

// Defines values for GetMediaPresignedUrlJSONBodyContentType.
const (
	Applicationpdf GetMediaPresignedUrlJSONBodyContentType = "application/pdf"
	Imagegif       GetMediaPresignedUrlJSONBodyContentType = "image/gif"
	Imagejpeg      GetMediaPresignedUrlJSONBodyContentType = "image/jpeg"
	Imagejpg       GetMediaPresignedUrlJSONBodyContentType = "image/jpg"
	Imagepng       GetMediaPresignedUrlJSONBodyContentType = "image/png"
	Imagewebp      GetMediaPresignedUrlJSONBodyContentType = "image/webp"
	Videoavi       GetMediaPresignedUrlJSONBodyContentType = "video/avi"
	Videomp4       GetMediaPresignedUrlJSONBodyContentType = "video/mp4"
	Videompeg      GetMediaPresignedUrlJSONBodyContentType = "video/mpeg"
	Videoquicktime GetMediaPresignedUrlJSONBodyContentType = "video/quicktime"
	Videowebm      GetMediaPresignedUrlJSONBodyContentType = "video/webm"
	VideoxM4v      GetMediaPresignedUrlJSONBodyContentType = "video/x-m4v"
	VideoxMsvideo  GetMediaPresignedUrlJSONBodyContentType = "video/x-msvideo"
)

// Defines values for ListPostsParamsStatus.
const (
	ListPostsParamsStatusDraft     ListPostsParamsStatus = "draft"
	ListPostsParamsStatusFailed    ListPostsParamsStatus = "failed"
	ListPostsParamsStatusPublished ListPostsParamsStatus = "published"
	ListPostsParamsStatusScheduled ListPostsParamsStatus = "scheduled"
)

// Defines values for CreatePostJSONBodyMediaItemsType.
const (
	CreatePostJSONBodyMediaItemsTypeDocument CreatePostJSONBodyMediaItemsType = "document"
	CreatePostJSONBodyMediaItemsTypeGif      CreatePostJSONBodyMediaItemsType = "gif"
	CreatePostJSONBodyMediaItemsTypeImage    CreatePostJSONBodyMediaItemsType = "image"
	CreatePostJSONBodyMediaItemsTypeVideo    CreatePostJSONBodyMediaItemsType = "video"
)

// Defines values for CreatePostJSONBodyPlatformsCustomMediaType.
const (
	CreatePostJSONBodyPlatformsCustomMediaTypeDocument CreatePostJSONBodyPlatformsCustomMediaType = "document"
	CreatePostJSONBodyPlatformsCustomMediaTypeGif      CreatePostJSONBodyPlatformsCustomMediaType = "gif"
	CreatePostJSONBodyPlatformsCustomMediaTypeImage    CreatePostJSONBodyPlatformsCustomMediaType = "image"
	CreatePostJSONBodyPlatformsCustomMediaTypeVideo    CreatePostJSONBodyPlatformsCustomMediaType = "video"
)

// Defines values for ListQueueSlotsParamsAll.
const (
	True ListQueueSlotsParamsAll = "true"
)

// Defines values for GetRedditFeedParamsSort.
const (
	GetRedditFeedParamsSortHot    GetRedditFeedParamsSort = "hot"
	GetRedditFeedParamsSortNew    GetRedditFeedParamsSort = "new"
	GetRedditFeedParamsSortRising GetRedditFeedParamsSort = "rising"
	GetRedditFeedParamsSortTop    GetRedditFeedParamsSort = "top"
)

// Defines values for GetRedditFeedParamsT.
const (
	All   GetRedditFeedParamsT = "all"
	Day   GetRedditFeedParamsT = "day"
	Hour  GetRedditFeedParamsT = "hour"
	Month GetRedditFeedParamsT = "month"
	Week  GetRedditFeedParamsT = "week"
	Year  GetRedditFeedParamsT = "year"
)

// Defines values for SearchRedditParamsRestrictSr.
const (
	N0 SearchRedditParamsRestrictSr = "0"
	N1 SearchRedditParamsRestrictSr = "1"
)

// Defines values for SearchRedditParamsSort.
const (
	SearchRedditParamsSortComments  SearchRedditParamsSort = "comments"
	SearchRedditParamsSortHot       SearchRedditParamsSort = "hot"
	SearchRedditParamsSortNew       SearchRedditParamsSort = "new"
	SearchRedditParamsSortRelevance SearchRedditParamsSort = "relevance"
	SearchRedditParamsSortTop       SearchRedditParamsSort = "top"
)

// Defines values for DownloadTikTokVideoParamsAction.
const (
	DownloadTikTokVideoParamsActionDownload DownloadTikTokVideoParamsAction = "download"
	DownloadTikTokVideoParamsActionFormats  DownloadTikTokVideoParamsAction = "formats"
)

// Defines values for DownloadTwitterMediaParamsAction.
const (
	DownloadTwitterMediaParamsActionDownload DownloadTwitterMediaParamsAction = "download"
	DownloadTwitterMediaParamsActionFormats  DownloadTwitterMediaParamsAction = "formats"
)

// Defines values for DownloadYouTubeVideoParamsAction.
const (
	Download DownloadYouTubeVideoParamsAction = "download"
	Formats  DownloadYouTubeVideoParamsAction = "formats"
)

// Defines values for DownloadYouTubeVideoParamsFormat.
const (
	DownloadYouTubeVideoParamsFormatAudio DownloadYouTubeVideoParamsFormat = "audio"
	DownloadYouTubeVideoParamsFormatVideo DownloadYouTubeVideoParamsFormat = "video"
)

// Defines values for DownloadYouTubeVideoParamsQuality.
const (
	Hd DownloadYouTubeVideoParamsQuality = "hd"
	Sd DownloadYouTubeVideoParamsQuality = "sd"
)

// Defines values for GetWebhookLogsParamsStatus.
const (
	GetWebhookLogsParamsStatusFailed  GetWebhookLogsParamsStatus = "failed"
	GetWebhookLogsParamsStatusSuccess GetWebhookLogsParamsStatus = "success"
)

// Defines values for GetWebhookLogsParamsEvent.
const (
	GetWebhookLogsParamsEventAccountConnected    GetWebhookLogsParamsEvent = "account.connected"
	GetWebhookLogsParamsEventAccountDisconnected GetWebhookLogsParamsEvent = "account.disconnected"
	GetWebhookLogsParamsEventMessageReceived     GetWebhookLogsParamsEvent = "message.received"
	GetWebhookLogsParamsEventPostFailed          GetWebhookLogsParamsEvent = "post.failed"
	GetWebhookLogsParamsEventPostPartial         GetWebhookLogsParamsEvent = "post.partial"
	GetWebhookLogsParamsEventPostPublished       GetWebhookLogsParamsEvent = "post.published"
	GetWebhookLogsParamsEventPostScheduled       GetWebhookLogsParamsEvent = "post.scheduled"
	GetWebhookLogsParamsEventWebhookTest         GetWebhookLogsParamsEvent = "webhook.test"
)

// Defines values for CreateWebhookSettingsJSONBodyEvents.
const (
	CreateWebhookSettingsJSONBodyEventsAccountConnected    CreateWebhookSettingsJSONBodyEvents = "account.connected"
	CreateWebhookSettingsJSONBodyEventsAccountDisconnected CreateWebhookSettingsJSONBodyEvents = "account.disconnected"
	CreateWebhookSettingsJSONBodyEventsMessageReceived     CreateWebhookSettingsJSONBodyEvents = "message.received"
	CreateWebhookSettingsJSONBodyEventsPostFailed          CreateWebhookSettingsJSONBodyEvents = "post.failed"
	CreateWebhookSettingsJSONBodyEventsPostPartial         CreateWebhookSettingsJSONBodyEvents = "post.partial"
	CreateWebhookSettingsJSONBodyEventsPostPublished       CreateWebhookSettingsJSONBodyEvents = "post.published"
	CreateWebhookSettingsJSONBodyEventsPostScheduled       CreateWebhookSettingsJSONBodyEvents = "post.scheduled"
)

// Defines values for UpdateWebhookSettingsJSONBodyEvents.
const (
	AccountConnected    UpdateWebhookSettingsJSONBodyEvents = "account.connected"
	AccountDisconnected UpdateWebhookSettingsJSONBodyEvents = "account.disconnected"
	MessageReceived     UpdateWebhookSettingsJSONBodyEvents = "message.received"
	PostFailed          UpdateWebhookSettingsJSONBodyEvents = "post.failed"
	PostPartial         UpdateWebhookSettingsJSONBodyEvents = "post.partial"
	PostPublished       UpdateWebhookSettingsJSONBodyEvents = "post.published"
	PostScheduled       UpdateWebhookSettingsJSONBodyEvents = "post.scheduled"
)

// AccountWithFollowerStats defines model for AccountWithFollowerStats.
type AccountWithFollowerStats struct {
	UnderscoreId *string `json:"_id,omitempty"`

	// CurrentFollowers Current follower count
	CurrentFollowers *float32 `json:"currentFollowers,omitempty"`

	// DataPoints Number of historical snapshots
	DataPoints  *float32 `json:"dataPoints,omitempty"`
	DisplayName *string  `json:"displayName,omitempty"`

	// FollowersCount Follower count (only included if user has analytics add-on)
	FollowersCount *float32 `json:"followersCount,omitempty"`

	// FollowersLastUpdated Last time follower count was updated (only included if user has analytics add-on)
	FollowersLastUpdated *time.Time `json:"followersLastUpdated,omitempty"`

	// Growth Follower change over period
	Growth *float32 `json:"growth,omitempty"`

	// GrowthPercentage Percentage growth
	GrowthPercentage *float32                            `json:"growthPercentage,omitempty"`
	IsActive         *bool                               `json:"isActive,omitempty"`
	LastUpdated      *time.Time                          `json:"lastUpdated,omitempty"`
	Platform         *string                             `json:"platform,omitempty"`
	ProfileId        *AccountWithFollowerStats_ProfileId `json:"profileId,omitempty"`
	ProfilePicture   *string                             `json:"profilePicture,omitempty"`

	// ProfileUrl Full profile URL for the connected account. Available for all platforms:
	// - Twitter/X: https://x.com/{username}
	// - Instagram: https://instagram.com/{username}
	// - TikTok: https://tiktok.com/@{username}
	// - YouTube: https://youtube.com/@{handle} or https://youtube.com/channel/{id}
	// - LinkedIn Personal: https://www.linkedin.com/in/{vanityName}/
	// - LinkedIn Organization: https://www.linkedin.com/company/{vanityName}/
	// - Threads: https://threads.net/@{username}
	// - Pinterest: https://pinterest.com/{username}
	// - Reddit: https://reddit.com/user/{username}
	// - Bluesky: https://bsky.app/profile/{handle}
	// - Facebook: https://facebook.com/{username} or https://facebook.com/{pageId}
	// - Google Business: Google Maps URL for the business location
	ProfileUrl *string `json:"profileUrl,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// AccountWithFollowerStatsProfileId0 defines model for .
type AccountWithFollowerStatsProfileId0 = string

// AccountWithFollowerStats_ProfileId defines model for AccountWithFollowerStats.ProfileId.
type AccountWithFollowerStats_ProfileId struct {
	union json.RawMessage
}

// AnalyticsListResponse defines model for AnalyticsListResponse.
type AnalyticsListResponse struct {
	// Accounts Connected social accounts (followerCount and followersLastUpdated only included if user has analytics add-on)
	Accounts *[]SocialAccount `json:"accounts,omitempty"`

	// HasAnalyticsAccess Whether user has analytics add-on access
	HasAnalyticsAccess *bool              `json:"hasAnalyticsAccess,omitempty"`
	Overview           *AnalyticsOverview `json:"overview,omitempty"`
	Pagination         *Pagination        `json:"pagination,omitempty"`
	Posts              *[]struct {
		UnderscoreId    *string                              `json:"_id,omitempty"`
		Analytics       *PostAnalytics                       `json:"analytics,omitempty"`
		Content         *string                              `json:"content,omitempty"`
		IsExternal      *bool                                `json:"isExternal,omitempty"`
		MediaItems      *[]MediaItem                         `json:"mediaItems,omitempty"`
		MediaType       *AnalyticsListResponsePostsMediaType `json:"mediaType,omitempty"`
		Platform        *string                              `json:"platform,omitempty"`
		PlatformPostUrl *string                              `json:"platformPostUrl,omitempty"`
		Platforms       *[]PlatformAnalytics                 `json:"platforms,omitempty"`
		PublishedAt     *time.Time                           `json:"publishedAt,omitempty"`
		ScheduledFor    *time.Time                           `json:"scheduledFor,omitempty"`
		Status          *string                              `json:"status,omitempty"`
		ThumbnailUrl    *string                              `json:"thumbnailUrl,omitempty"`
	} `json:"posts,omitempty"`
}

// AnalyticsListResponsePostsMediaType defines model for AnalyticsListResponse.Posts.MediaType.
type AnalyticsListResponsePostsMediaType string

// AnalyticsOverview defines model for AnalyticsOverview.
type AnalyticsOverview struct {
	LastSync       *time.Time `json:"lastSync,omitempty"`
	PublishedPosts *int       `json:"publishedPosts,omitempty"`
	ScheduledPosts *int       `json:"scheduledPosts,omitempty"`
	TotalPosts     *int       `json:"totalPosts,omitempty"`
}

// AnalyticsSinglePostResponse defines model for AnalyticsSinglePostResponse.
type AnalyticsSinglePostResponse struct {
	Analytics         *PostAnalytics       `json:"analytics,omitempty"`
	Content           *string              `json:"content,omitempty"`
	IsExternal        *bool                `json:"isExternal,omitempty"`
	Platform          *string              `json:"platform,omitempty"`
	PlatformAnalytics *[]PlatformAnalytics `json:"platformAnalytics,omitempty"`
	PlatformPostUrl   *string              `json:"platformPostUrl,omitempty"`
	PostId            *string              `json:"postId,omitempty"`
	PublishedAt       *time.Time           `json:"publishedAt,omitempty"`
	ScheduledFor      *time.Time           `json:"scheduledFor,omitempty"`
	Status            *string              `json:"status,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// Key Returned only once, on creation
	Key        *string `json:"key,omitempty"`
	KeyPreview *string `json:"keyPreview,omitempty"`
	Name       *string `json:"name,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
}

// FacebookPlatformData Constraints:
// - Posts cannot mix videos and images.
// - Multiple images supported via attached_media (up to 10 images for feed posts).
// - Multiple videos in the same post are not supported.
// - Stories require media (single image or video); text captions are not displayed with stories.
// - Stories are ephemeral (disappear after 24 hours).
// - Use pageId to post to multiple pages from the same account connection.
type FacebookPlatformData struct {
	// ContentType Set to 'story' to publish as a Facebook Page Story (24-hour ephemeral content). Requires media.
	ContentType *FacebookPlatformDataContentType `json:"contentType,omitempty"`

	// FirstComment Optional first comment to post immediately after publishing (feed posts only, not stories)
	FirstComment *string `json:"firstComment,omitempty"`

	// PageId Target Facebook Page ID for multi-page posting.
	// If omitted, uses the selected/default page on the connection.
	// Use GET /api/v1/accounts/{id}/facebook-page to list available pages.
	PageId *string `json:"pageId,omitempty"`
}

// FacebookPlatformDataContentType Set to 'story' to publish as a Facebook Page Story (24-hour ephemeral content). Requires media.
type FacebookPlatformDataContentType string

// FoodMenu defines model for FoodMenu.
type FoodMenu struct {
	// Cuisines Cuisine types (e.g. AMERICAN, ITALIAN, JAPANESE)
	Cuisines *[]string          `json:"cuisines,omitempty"`
	Labels   []FoodMenuLabel    `json:"labels"`
	Sections *[]FoodMenuSection `json:"sections,omitempty"`

	// SourceUrl URL of the original menu source
	SourceUrl *string `json:"sourceUrl,omitempty"`
}

// FoodMenuItem defines model for FoodMenuItem.
type FoodMenuItem struct {
	Attributes *FoodMenuItemAttributes `json:"attributes,omitempty"`
	Labels     []FoodMenuLabel         `json:"labels"`

	// Options Item variants/options (e.g. sizes, preparations)
	Options *[]struct {
		Attributes *FoodMenuItemAttributes `json:"attributes,omitempty"`
		Labels     *[]FoodMenuLabel        `json:"labels,omitempty"`
	} `json:"options,omitempty"`
}

// FoodMenuItemAttributes defines model for FoodMenuItemAttributes.
type FoodMenuItemAttributes struct {
	// Allergen Allergens (e.g. DAIRY, GLUTEN, SHELLFISH)
	Allergen *[]string `json:"allergen,omitempty"`

	// DietaryRestriction Dietary labels (e.g. VEGETARIAN, VEGAN, GLUTEN_FREE)
	DietaryRestriction *[]string `json:"dietaryRestriction,omitempty"`

	// MediaKeys Media references for item photos
	MediaKeys *[]string `json:"mediaKeys,omitempty"`

	// PreparationMethods Preparation methods (e.g. GRILLED, FRIED)
	PreparationMethods *[]string `json:"preparationMethods,omitempty"`
	Price              *Money    `json:"price,omitempty"`

	// ServesNumPeople Number of people the item serves
	ServesNumPeople *int `json:"servesNumPeople,omitempty"`

	// Spiciness Spiciness level (e.g. MILD, MEDIUM, HOT)
	Spiciness *string `json:"spiciness,omitempty"`
}

// FoodMenuLabel defines model for FoodMenuLabel.
type FoodMenuLabel struct {
	// Description Optional description
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the item/section/menu
	DisplayName string `json:"displayName"`

	// LanguageCode BCP-47 language code (e.g. en, es)
	LanguageCode *string `json:"languageCode,omitempty"`
}

// FoodMenuSection defines model for FoodMenuSection.
type FoodMenuSection struct {
	Items  *[]FoodMenuItem `json:"items,omitempty"`
	Labels []FoodMenuLabel `json:"labels"`
}

// GoogleBusinessPlatformData Google Business Profile post settings:
// - Posts support text content and a single image (no videos)
// - Images must be publicly accessible URLs
// - Call-to-action buttons drive user engagement
// - Posts appear on your Google Business Profile and in Google Search/Maps
// - Use locationId to post to multiple locations from the same account connection
type GoogleBusinessPlatformData struct {
	// CallToAction Optional call-to-action button displayed on the post
	CallToAction *struct {
		// Type Button action type:
		// - LEARN_MORE: Link to more information
		// - BOOK: Booking/reservation link
		// - ORDER: Online ordering link
		// - SHOP: E-commerce/shopping link
		// - SIGN_UP: Registration/signup link
		// - CALL: Phone call action
		Type GoogleBusinessPlatformDataCallToActionType `json:"type"`

		// Url Destination URL for the CTA button (required when callToAction is provided)
		Url string `json:"url"`
	} `json:"callToAction,omitempty"`

	// LocationId Target Google Business location ID for multi-location posting.
	// Format: "locations/123456789"
	// If omitted, uses the selected/default location on the connection.
	// Use GET /api/v1/accounts/{id}/gmb-locations to list available locations.
	LocationId *string `json:"locationId,omitempty"`
}

// GoogleBusinessPlatformDataCallToActionType Button action type:
// - LEARN_MORE: Link to more information
// - BOOK: Booking/reservation link
// - ORDER: Online ordering link
// - SHOP: E-commerce/shopping link
// - SIGN_UP: Registration/signup link
// - CALL: Phone call action
type GoogleBusinessPlatformDataCallToActionType string

// InstagramPlatformData Constraints:
// - Feed posts require images with aspect ratio between 0.8 (4:5 portrait) and 1.91 (1.91:1 landscape).
// - Images outside this range (e.g., 9:16 Stories/TikTok format) must use contentType 'story'.
// - Validation happens at post creation; invalid images are rejected immediately with helpful error messages.
// - Carousels support up to 10 media items.
// - Stories require media; no captions are published with Stories.
// - User tags: coordinates range from 0.0 to 1.0 representing position from top-left corner. Tagged users receive notifications.
//
// **Automatic Compression (similar to Bluesky):**
// - All images (story, post, carousel, thumbnails) exceeding 8 MB are automatically compressed using quality reduction and resizing.
// - Story videos exceeding 100 MB are automatically compressed.
// - Reel videos exceeding 300 MB are automatically compressed.
// - Compression uses Sharp (images) and FFmpeg (videos) to maintain quality while meeting size limits.
// - Original files are preserved; compressed versions are uploaded to blob storage automatically.
type InstagramPlatformData struct {
	// AudioName Custom name for the original audio in Reels. Replaces the default "Original Audio" label.
	// Only applies to Reels (video posts). Can only be set once - either during creation or
	// later from the Instagram audio page in the app.
	AudioName *string `json:"audioName,omitempty"`

	// Collaborators Up to 3 Instagram usernames to invite as collaborators (feed/Reels only)
	Collaborators *[]string `json:"collaborators,omitempty"`

	// ContentType Set to 'story' to publish as a Story. Default posts become Reels or feed depending on media.
	ContentType *InstagramPlatformDataContentType `json:"contentType,omitempty"`

	// FirstComment Optional first comment to add after the post is created (not applied to Stories)
	FirstComment *string `json:"firstComment,omitempty"`

	// ShareToFeed For Reels only. When true (default), the Reel appears on both the Reels tab and your main profile feed. Set to false to post to the Reels tab only.
	ShareToFeed *bool `json:"shareToFeed,omitempty"`

	// ThumbOffset Millisecond offset from the start of the video to use as the Reel thumbnail.
	// Only applies to Reels (video posts). If a custom thumbnail URL (instagramThumbnail
	// in mediaItems) is provided, it takes priority and this offset is ignored.
	// Defaults to 0 (first frame).
	ThumbOffset *int `json:"thumbOffset,omitempty"`

	// TrialParams Trial Reels configuration. Trial reels are only shared to non-followers initially.
	// They can later be "graduated" (converted to regular reels visible to followers)
	// either manually in the Instagram app or automatically based on performance.
	// Only applies to Reels (video posts).
	TrialParams *struct {
		// GraduationStrategy The graduation strategy specifies when a trial reel becomes a regular reel:
		// - MANUAL: The trial reel can only be manually graduated from the native Instagram app.
		// - SS_PERFORMANCE: The trial reel will be automatically graduated if it performs well with non-followers.
		GraduationStrategy *InstagramPlatformDataTrialParamsGraduationStrategy `json:"graduationStrategy,omitempty"`
	} `json:"trialParams,omitempty"`

	// UserTags Tag Instagram users in photos by username and position coordinates. Only works for single image posts and the first image of carousel posts. Not supported for stories or videos.
	UserTags *[]struct {
		// Username Instagram username (@ symbol is optional and will be removed automatically)
		Username string `json:"username"`

		// X X coordinate position from left edge (0.0 = left, 0.5 = center, 1.0 = right)
		X float32 `json:"x"`

		// Y Y coordinate position from top edge (0.0 = top, 0.5 = center, 1.0 = bottom)
		Y float32 `json:"y"`
	} `json:"userTags,omitempty"`
}

// InstagramPlatformDataContentType Set to 'story' to publish as a Story. Default posts become Reels or feed depending on media.
type InstagramPlatformDataContentType string

// InstagramPlatformDataTrialParamsGraduationStrategy The graduation strategy specifies when a trial reel becomes a regular reel:
// - MANUAL: The trial reel can only be manually graduated from the native Instagram app.
// - SS_PERFORMANCE: The trial reel will be automatically graduated if it performs well with non-followers.
type InstagramPlatformDataTrialParamsGraduationStrategy string

// LinkedInAggregateAnalyticsDailyResponse Response for DAILY aggregation (time series breakdown)
type LinkedInAggregateAnalyticsDailyResponse struct {
	AccountId   *string                                             `json:"accountId,omitempty"`
	AccountType *string                                             `json:"accountType,omitempty"`
	Aggregation *LinkedInAggregateAnalyticsDailyResponseAggregation `json:"aggregation,omitempty"`

	// Analytics Daily breakdown of each metric. Each metric contains an array of date/count pairs.
	// Note: 'reach' (MEMBERS_REACHED) is not available with DAILY aggregation per LinkedIn API limitations.
	Analytics *struct {
		Comments *[]struct {
			Count *int                `json:"count,omitempty"`
			Date  *openapi_types.Date `json:"date,omitempty"`
		} `json:"comments,omitempty"`
		Impressions *[]struct {
			Count *int                `json:"count,omitempty"`
			Date  *openapi_types.Date `json:"date,omitempty"`
		} `json:"impressions,omitempty"`
		Reactions *[]struct {
			Count *int                `json:"count,omitempty"`
			Date  *openapi_types.Date `json:"date,omitempty"`
		} `json:"reactions,omitempty"`
		Shares *[]struct {
			Count *int                `json:"count,omitempty"`
			Date  *openapi_types.Date `json:"date,omitempty"`
		} `json:"shares,omitempty"`
	} `json:"analytics,omitempty"`
	DateRange *struct {
		EndDate   *openapi_types.Date `json:"endDate,omitempty"`
		StartDate *openapi_types.Date `json:"startDate,omitempty"`
	} `json:"dateRange"`
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`
	Note        *string    `json:"note,omitempty"`
	Platform    *string    `json:"platform,omitempty"`

	// SkippedMetrics Metrics that were skipped due to API limitations
	SkippedMetrics *[]string `json:"skippedMetrics,omitempty"`
	Username       *string   `json:"username,omitempty"`
}

// LinkedInAggregateAnalyticsDailyResponseAggregation defines model for LinkedInAggregateAnalyticsDailyResponse.Aggregation.
type LinkedInAggregateAnalyticsDailyResponseAggregation string

// LinkedInAggregateAnalyticsTotalResponse Response for TOTAL aggregation (lifetime totals)
type LinkedInAggregateAnalyticsTotalResponse struct {
	AccountId   *string                                             `json:"accountId,omitempty"`
	AccountType *string                                             `json:"accountType,omitempty"`
	Aggregation *LinkedInAggregateAnalyticsTotalResponseAggregation `json:"aggregation,omitempty"`
	Analytics   *struct {
		// Comments Total comments across all posts
		Comments *int `json:"comments,omitempty"`

		// EngagementRate Overall engagement rate as percentage
		EngagementRate *float32 `json:"engagementRate,omitempty"`

		// Impressions Total impressions across all posts
		Impressions *int `json:"impressions,omitempty"`

		// Reach Unique members reached across all posts
		Reach *int `json:"reach,omitempty"`

		// Reactions Total reactions across all posts
		Reactions *int `json:"reactions,omitempty"`

		// Shares Total reshares across all posts
		Shares *int `json:"shares,omitempty"`
	} `json:"analytics,omitempty"`
	DateRange *struct {
		EndDate   *openapi_types.Date `json:"endDate,omitempty"`
		StartDate *openapi_types.Date `json:"startDate,omitempty"`
	} `json:"dateRange"`
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`
	Note        *string    `json:"note,omitempty"`
	Platform    *string    `json:"platform,omitempty"`
	Username    *string    `json:"username,omitempty"`
}

// LinkedInAggregateAnalyticsTotalResponseAggregation defines model for LinkedInAggregateAnalyticsTotalResponse.Aggregation.
type LinkedInAggregateAnalyticsTotalResponseAggregation string

// LinkedInPlatformData Constraints:
// - Multi-image posts support up to 20 images.
// - Multi-video posts are not supported.
// - Single PDF document posts are supported (max 100MB, ~300 pages). Documents cannot be mixed with other media.
// - Post ID is returned in the x-restli-id response header.
// - Link previews are automatically generated for URLs when no media is attached (can be disabled with disableLinkPreview).
// - Use organizationUrn to post to multiple organizations from the same account connection.
type LinkedInPlatformData struct {
	// DisableLinkPreview Set to true to disable automatic link previews for URLs in the post content (default is false)
	DisableLinkPreview *bool `json:"disableLinkPreview,omitempty"`

	// FirstComment Optional first comment to add after the post is created
	FirstComment *string `json:"firstComment,omitempty"`

	// OrganizationUrn Target LinkedIn Organization URN for multi-organization posting.
	// Format: "urn:li:organization:123456789"
	// If omitted, uses the selected/default organization on the connection.
	// Use GET /api/v1/accounts/{id}/linkedin-organizations to list available organizations.
	OrganizationUrn *string `json:"organizationUrn,omitempty"`
}

// MediaItem Media referenced in posts. URLs must be publicly reachable over HTTPS by the destination platforms.
// When using third‑party storage, ensure signed links remain valid until upload completes.
//
// **Uploading Media:**
// Use `POST /v1/media/presign` to get a presigned URL, then upload your file directly to cloud storage.
// Supports files up to 5GB. See the `/v1/media/presign` endpoint documentation for details.
//
// **Automatic Media Compression:**
// Late automatically compresses media that exceeds platform limits, so you don't need to worry about file size restrictions. Compression happens server-side during publishing.
//
// **Image compression by platform:**
// - Twitter/X: >5 MB
// - Instagram: >8 MB
// - Threads: >8 MB
// - Facebook: >10 MB
// - LinkedIn: >8 MB
// - TikTok: >20 MB
// - Pinterest: >32 MB
// - Reddit: >20 MB
// - Snapchat: >20 MB
// - Telegram: >10 MB
// - Bluesky: >1 MB
// - YouTube (thumbnails): >2 MB
// - Google Business: >5 MB
//
// **Video compression by platform:**
// - Twitter/X: >512 MB
// - Instagram Stories: >100 MB
// - Instagram Reels: >300 MB
// - Facebook: >4 GB
// - LinkedIn: >5 GB
// - TikTok: >4 GB
// - Pinterest: >2 GB
// - Snapchat: >500 MB
// - Telegram: >50 MB
//
// Note: Videos larger than 200 MB may not be compressed due to server timeout constraints. For best results, compress very large videos before uploading.
type MediaItem struct {
	Filename *string `json:"filename,omitempty"`

	// InstagramThumbnail Optional custom cover image URL for Instagram Reels
	InstagramThumbnail *string `json:"instagramThumbnail,omitempty"`

	// MimeType Optional MIME type (e.g. image/jpeg, video/mp4)
	MimeType *string `json:"mimeType,omitempty"`

	// Size Optional file size in bytes
	Size *int `json:"size,omitempty"`

	// Thumbnail Optional thumbnail image URL for videos
	Thumbnail *string `json:"thumbnail,omitempty"`

	// TiktokProcessed Internal flag indicating the image was resized for TikTok
	TiktokProcessed *bool          `json:"tiktokProcessed,omitempty"`
	Type            *MediaItemType `json:"type,omitempty"`
	Url             *string        `json:"url,omitempty"`
}

// MediaItemType defines model for MediaItem.Type.
type MediaItemType string

// Money defines model for Money.
type Money struct {
	// CurrencyCode ISO 4217 currency code (e.g. USD, EUR)
	CurrencyCode string `json:"currencyCode"`

	// Nanos Nano units (10^-9) of the amount
	Nanos *int `json:"nanos,omitempty"`

	// Units Whole units of the amount
	Units string `json:"units"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	Limit *int `json:"limit,omitempty"`
	Page  *int `json:"page,omitempty"`
	Pages *int `json:"pages,omitempty"`
	Total *int `json:"total,omitempty"`
}

// PinterestPlatformData defines model for PinterestPlatformData.
type PinterestPlatformData struct {
	// BoardId Target Pinterest board ID. If omitted, the first available board is used.
	BoardId *string `json:"boardId,omitempty"`

	// CoverImageKeyFrameTime Optional key frame time in seconds for derived video cover
	CoverImageKeyFrameTime *int `json:"coverImageKeyFrameTime,omitempty"`

	// CoverImageUrl Optional cover image for video pins
	CoverImageUrl *string `json:"coverImageUrl,omitempty"`

	// Link Destination link (pin URL)
	Link *string `json:"link,omitempty"`

	// Title Pin title. Defaults to first line of content or "Pin". Must be ≤ 100 characters.
	Title *string `json:"title,omitempty"`
}

// PlatformAnalytics defines model for PlatformAnalytics.
type PlatformAnalytics struct {
	AccountId      *string `json:"accountId,omitempty"`
	AccountMetrics *struct {
		// Followers Followers/fans count (e.g., Instagram, Facebook Pages, Twitter)
		Followers   *int       `json:"followers"`
		LastUpdated *time.Time `json:"lastUpdated"`

		// Subscribers Subscribers count (e.g., YouTube)
		Subscribers *int `json:"subscribers"`
	} `json:"accountMetrics"`
	AccountUsername *string        `json:"accountUsername,omitempty"`
	Analytics       *PostAnalytics `json:"analytics,omitempty"`
	Platform        *string        `json:"platform,omitempty"`
	Status          *string        `json:"status,omitempty"`
}

// PlatformTarget defines model for PlatformTarget.
type PlatformTarget struct {
	AccountId     *PlatformTarget_AccountId `json:"accountId,omitempty"`
	CustomContent *string                   `json:"customContent,omitempty"`
	CustomMedia   *[]MediaItem              `json:"customMedia,omitempty"`

	// ErrorCategory Error category for programmatic handling:
	// - auth_expired: Token expired or revoked, account needs reconnection
	// - user_content: Content doesn't meet platform requirements (too long, wrong format, etc.)
	// - user_abuse: Rate limits, spam detection, excessive posting
	// - account_issue: Account configuration problems (missing board, inactive account)
	// - platform_rejected: Platform rules violated (banned, suspended, policy violation)
	// - platform_error: Platform-side issues (5xx errors, maintenance)
	// - system_error: Late infrastructure issues (timeouts, network errors)
	// - unknown: Unclassified error
	ErrorCategory *PlatformTargetErrorCategory `json:"errorCategory,omitempty"`

	// ErrorMessage Human-readable error message when status is 'failed'.
	// Contains platform-specific error details explaining why the publish failed.
	// Examples:
	// - "Instagram access token has expired. Please reconnect your account."
	// - "Post text exceeds the 500 character limit for Threads."
	// - "You do not have enough karma to post in this subreddit."
	// - "Video is too long for Reels. Facebook Reels must be 90 seconds or less."
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorSource Who/what caused the error:
	// - user: User action required (fix content, reconnect account)
	// - platform: Platform-side issue (outage, API change)
	// - system: Late system issue (rare)
	ErrorSource *PlatformTargetErrorSource `json:"errorSource,omitempty"`

	// Platform Supported values: twitter, threads, instagram, youtube, facebook, linkedin, pinterest, reddit, tiktok, bluesky, googlebusiness, telegram
	Platform *string `json:"platform,omitempty"`

	// PlatformPostId The native post ID on the platform (populated after successful publish)
	PlatformPostId *string `json:"platformPostId,omitempty"`

	// PlatformPostUrl Public URL of the published post on the platform.
	// Populated after successful publish. For immediate posts (publishNow=true),
	// this is included in the response. For scheduled posts, fetch the post
	// via GET /v1/posts/{postId} after the scheduled time.
	PlatformPostUrl *string `json:"platformPostUrl,omitempty"`

	// PlatformSpecificData Platform-specific overrides and options.
	PlatformSpecificData *PlatformTarget_PlatformSpecificData `json:"platformSpecificData,omitempty"`

	// PublishedAt Timestamp when the post was published to this platform
	PublishedAt *time.Time `json:"publishedAt,omitempty"`

	// ScheduledFor Optional per-platform scheduled time override (uses post.scheduledFor when omitted)
	ScheduledFor *time.Time `json:"scheduledFor,omitempty"`

	// Status Platform-specific status: pending, publishing, published, failed
	Status *string `json:"status,omitempty"`
}

// PlatformTargetAccountId0 defines model for .
type PlatformTargetAccountId0 = string

// PlatformTarget_AccountId defines model for PlatformTarget.AccountId.
type PlatformTarget_AccountId struct {
	union json.RawMessage
}

// PlatformTargetErrorCategory Error category for programmatic handling:
// - auth_expired: Token expired or revoked, account needs reconnection
// - user_content: Content doesn't meet platform requirements (too long, wrong format, etc.)
// - user_abuse: Rate limits, spam detection, excessive posting
// - account_issue: Account configuration problems (missing board, inactive account)
// - platform_rejected: Platform rules violated (banned, suspended, policy violation)
// - platform_error: Platform-side issues (5xx errors, maintenance)
// - system_error: Late infrastructure issues (timeouts, network errors)
// - unknown: Unclassified error
type PlatformTargetErrorCategory string

// PlatformTargetErrorSource Who/what caused the error:
// - user: User action required (fix content, reconnect account)
// - platform: Platform-side issue (outage, API change)
// - system: Late system issue (rare)
type PlatformTargetErrorSource string

// PlatformTarget_PlatformSpecificData Platform-specific overrides and options.
type PlatformTarget_PlatformSpecificData struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// Post defines model for Post.
type Post struct {
	UnderscoreId *string                 `json:"_id,omitempty"`
	Content      *string                 `json:"content,omitempty"`
	CreatedAt    *time.Time              `json:"createdAt,omitempty"`
	Hashtags     *[]string               `json:"hashtags,omitempty"`
	MediaItems   *[]MediaItem            `json:"mediaItems,omitempty"`
	Mentions     *[]string               `json:"mentions,omitempty"`
	Metadata     *map[string]interface{} `json:"metadata,omitempty"`
	Platforms    *[]PlatformTarget       `json:"platforms,omitempty"`

	// QueueId Queue ID if the post was scheduled via a specific queue
	QueueId *string `json:"queueId,omitempty"`

	// QueuedFromProfile Profile ID if the post was scheduled via the queue
	QueuedFromProfile *string     `json:"queuedFromProfile,omitempty"`
	ScheduledFor      *time.Time  `json:"scheduledFor,omitempty"`
	Status            *PostStatus `json:"status,omitempty"`

	// Tags YouTube tag constraints when targeting YouTube:
	// - No count cap; duplicates removed.
	// - Each tag must be ≤ 100 chars.
	// - Combined characters across all tags ≤ 500.
	Tags     *[]string `json:"tags,omitempty"`
	Timezone *string   `json:"timezone,omitempty"`

	// Title YouTube: title must be ≤ 100 characters.
	Title      *string         `json:"title,omitempty"`
	UpdatedAt  *time.Time      `json:"updatedAt,omitempty"`
	UserId     *Post_UserId    `json:"userId,omitempty"`
	Visibility *PostVisibility `json:"visibility,omitempty"`
}

// PostStatus defines model for Post.Status.
type PostStatus string

// PostUserId0 defines model for .
type PostUserId0 = string

// Post_UserId defines model for Post.UserId.
type Post_UserId struct {
	union json.RawMessage
}

// PostVisibility defines model for Post.Visibility.
type PostVisibility string

// PostAnalytics defines model for PostAnalytics.
type PostAnalytics struct {
	Clicks         *int       `json:"clicks,omitempty"`
	Comments       *int       `json:"comments,omitempty"`
	EngagementRate *float32   `json:"engagementRate,omitempty"`
	Impressions    *int       `json:"impressions,omitempty"`
	LastUpdated    *time.Time `json:"lastUpdated,omitempty"`
	Likes          *int       `json:"likes,omitempty"`
	Reach          *int       `json:"reach,omitempty"`

	// Saves Number of saves/bookmarks (Instagram, Pinterest)
	Saves  *int `json:"saves,omitempty"`
	Shares *int `json:"shares,omitempty"`
	Views  *int `json:"views,omitempty"`
}

// PostCreateResponse defines model for PostCreateResponse.
type PostCreateResponse struct {
	Message *string `json:"message,omitempty"`
	Post    *Post   `json:"post,omitempty"`
}

// PostDeleteResponse defines model for PostDeleteResponse.
type PostDeleteResponse struct {
	Message *string `json:"message,omitempty"`
}

// PostGetResponse defines model for PostGetResponse.
type PostGetResponse struct {
	Post *Post `json:"post,omitempty"`
}

// PostLog Publishing log entry showing details of a post publishing attempt
type PostLog struct {
	UnderscoreId    *string `json:"_id,omitempty"`
	AccountId       *string `json:"accountId,omitempty"`
	AccountUsername *string `json:"accountUsername,omitempty"`

	// Action Type of action logged:
	// - `publish` - Initial publish attempt
	// - `retry` - Retry after failure
	// - `media_upload` - Media upload step
	// - `rate_limit_pause` - Account paused due to rate limits
	// - `token_refresh` - Token was refreshed
	// - `cancelled` - Post was cancelled
	Action *PostLogAction `json:"action,omitempty"`

	// AttemptNumber Attempt number (1 for first try, 2+ for retries)
	AttemptNumber *int       `json:"attemptNumber,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty"`

	// DurationMs How long the operation took in milliseconds
	DurationMs *int `json:"durationMs,omitempty"`

	// Endpoint Platform API endpoint called
	Endpoint  *string          `json:"endpoint,omitempty"`
	Platform  *PostLogPlatform `json:"platform,omitempty"`
	PostId    *PostLog_PostId  `json:"postId,omitempty"`
	ProfileId *string          `json:"profileId,omitempty"`
	Request   *struct {
		// ContentPreview First 200 chars of caption
		ContentPreview *string   `json:"contentPreview,omitempty"`
		MediaCount     *int      `json:"mediaCount,omitempty"`
		MediaTypes     *[]string `json:"mediaTypes,omitempty"`

		// MediaUrls URLs of media items sent to platform
		MediaUrls *[]string `json:"mediaUrls,omitempty"`

		// RawBody Full request body JSON (max 5000 chars)
		RawBody      *string    `json:"rawBody,omitempty"`
		ScheduledFor *time.Time `json:"scheduledFor,omitempty"`
	} `json:"request,omitempty"`
	Response *struct {
		// ErrorCode Platform-specific error code
		ErrorCode *string `json:"errorCode,omitempty"`

		// ErrorMessage Error message on failure
		ErrorMessage *string `json:"errorMessage,omitempty"`

		// PlatformPostId ID returned by platform on success
		PlatformPostId *string `json:"platformPostId,omitempty"`

		// PlatformPostUrl URL of published post
		PlatformPostUrl *string `json:"platformPostUrl,omitempty"`

		// RawBody Full response body JSON (max 5000 chars)
		RawBody *string `json:"rawBody,omitempty"`
	} `json:"response,omitempty"`
	Status *PostLogStatus `json:"status,omitempty"`

	// StatusCode HTTP status code from platform API
	StatusCode *int    `json:"statusCode,omitempty"`
	UserId     *string `json:"userId,omitempty"`
}

// PostLogAction Type of action logged:
// - `publish` - Initial publish attempt
// - `retry` - Retry after failure
// - `media_upload` - Media upload step
// - `rate_limit_pause` - Account paused due to rate limits
// - `token_refresh` - Token was refreshed
// - `cancelled` - Post was cancelled
type PostLogAction string

// PostLogPlatform defines model for PostLog.Platform.
type PostLogPlatform string

// PostLogPostId0 defines model for .
type PostLogPostId0 = string

// PostLogPostId1 Populated post reference
type PostLogPostId1 struct {
	UnderscoreId *string `json:"_id,omitempty"`
	Content      *string `json:"content,omitempty"`
	Status       *string `json:"status,omitempty"`
}

// PostLog_PostId defines model for PostLog.PostId.
type PostLog_PostId struct {
	union json.RawMessage
}

// PostLogStatus defines model for PostLog.Status.
type PostLogStatus string

// PostLogDetail defines model for PostLogDetail.
type PostLogDetail struct {
	UnderscoreId *string `json:"_id,omitempty"`

	// AccountId Populated account reference
	AccountId *struct {
		UnderscoreId *string `json:"_id,omitempty"`
		DisplayName  *string `json:"displayName,omitempty"`
		Platform     *string `json:"platform,omitempty"`
		Username     *string `json:"username,omitempty"`
	} `json:"accountId,omitempty"`
	AccountUsername *string `json:"accountUsername,omitempty"`

	// Action Type of action logged:
	// - `publish` - Initial publish attempt
	// - `retry` - Retry after failure
	// - `media_upload` - Media upload step
	// - `rate_limit_pause` - Account paused due to rate limits
	// - `token_refresh` - Token was refreshed
	// - `cancelled` - Post was cancelled
	Action *PostLogDetailAction `json:"action,omitempty"`

	// AttemptNumber Attempt number (1 for first try, 2+ for retries)
	AttemptNumber *int       `json:"attemptNumber,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty"`

	// DurationMs How long the operation took in milliseconds
	DurationMs *int `json:"durationMs,omitempty"`

	// Endpoint Platform API endpoint called
	Endpoint *string `json:"endpoint,omitempty"`

	// Metadata Additional metadata (e.g., rate limit info)
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Platform *PostLogDetailPlatform  `json:"platform,omitempty"`

	// PostId Populated post with full details
	PostId *struct {
		UnderscoreId *string                   `json:"_id,omitempty"`
		Content      *string                   `json:"content,omitempty"`
		MediaItems   *[]map[string]interface{} `json:"mediaItems,omitempty"`
		Platforms    *[]map[string]interface{} `json:"platforms,omitempty"`
		ScheduledFor *time.Time                `json:"scheduledFor,omitempty"`
		Status       *string                   `json:"status,omitempty"`
	} `json:"postId,omitempty"`
	ProfileId *string `json:"profileId,omitempty"`
	Request   *struct {
		// ContentPreview First 200 chars of caption
		ContentPreview *string   `json:"contentPreview,omitempty"`
		MediaCount     *int      `json:"mediaCount,omitempty"`
		MediaTypes     *[]string `json:"mediaTypes,omitempty"`

		// MediaUrls URLs of media items sent to platform
		MediaUrls *[]string `json:"mediaUrls,omitempty"`

		// RawBody Full request body JSON (max 5000 chars)
		RawBody      *string    `json:"rawBody,omitempty"`
		ScheduledFor *time.Time `json:"scheduledFor,omitempty"`
	} `json:"request,omitempty"`
	Response *struct {
		// ErrorCode Platform-specific error code
		ErrorCode *string `json:"errorCode,omitempty"`

		// ErrorMessage Error message on failure
		ErrorMessage *string `json:"errorMessage,omitempty"`

		// PlatformPostId ID returned by platform on success
		PlatformPostId *string `json:"platformPostId,omitempty"`

		// PlatformPostUrl URL of published post
		PlatformPostUrl *string `json:"platformPostUrl,omitempty"`

		// RawBody Full response body JSON (max 5000 chars)
		RawBody *string `json:"rawBody,omitempty"`
	} `json:"response,omitempty"`
	Status *PostLogDetailStatus `json:"status,omitempty"`

	// StatusCode HTTP status code from platform API
	StatusCode *int    `json:"statusCode,omitempty"`
	UserId     *string `json:"userId,omitempty"`
}

// PostLogDetailAction Type of action logged:
// - `publish` - Initial publish attempt
// - `retry` - Retry after failure
// - `media_upload` - Media upload step
// - `rate_limit_pause` - Account paused due to rate limits
// - `token_refresh` - Token was refreshed
// - `cancelled` - Post was cancelled
type PostLogDetailAction string

// PostLogDetailPlatform defines model for PostLogDetail.Platform.
type PostLogDetailPlatform string

// PostLogDetailStatus defines model for PostLogDetail.Status.
type PostLogDetailStatus string

// PostRetryResponse defines model for PostRetryResponse.
type PostRetryResponse struct {
	Message *string `json:"message,omitempty"`
	Post    *Post   `json:"post,omitempty"`
}

// PostUpdateResponse defines model for PostUpdateResponse.
type PostUpdateResponse struct {
	Message *string `json:"message,omitempty"`
	Post    *Post   `json:"post,omitempty"`
}

// PostsListResponse defines model for PostsListResponse.
type PostsListResponse struct {
	Pagination *Pagination `json:"pagination,omitempty"`
	Posts      *[]Post     `json:"posts,omitempty"`
}

// Profile defines model for Profile.
type Profile struct {
	UnderscoreId *string    `json:"_id,omitempty"`
	Color        *string    `json:"color,omitempty"`
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	Description  *string    `json:"description,omitempty"`
	IsDefault    *bool      `json:"isDefault,omitempty"`

	// IsOverLimit Only present when `includeOverLimit=true` is used. Indicates if this profile
	// exceeds the user's plan limit. Over-limit profiles cannot be used for posting
	// but can be managed (disconnected accounts, deleted).
	IsOverLimit *bool   `json:"isOverLimit,omitempty"`
	Name        *string `json:"name,omitempty"`
	UserId      *string `json:"userId,omitempty"`
}

// ProfileCreateResponse defines model for ProfileCreateResponse.
type ProfileCreateResponse struct {
	Message *string  `json:"message,omitempty"`
	Profile *Profile `json:"profile,omitempty"`
}

// ProfilesListResponse defines model for ProfilesListResponse.
type ProfilesListResponse struct {
	Profiles *[]Profile `json:"profiles,omitempty"`
}

// QueueSchedule defines model for QueueSchedule.
type QueueSchedule struct {
	// UnderscoreId Unique queue identifier
	UnderscoreId *string `json:"_id,omitempty"`

	// Active Whether the queue is active
	Active    *bool      `json:"active,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// IsDefault Whether this is the default queue for the profile (used when no queueId specified)
	IsDefault *bool `json:"isDefault,omitempty"`

	// Name Queue name (e.g., "Morning Posts", "Evening Content")
	Name *string `json:"name,omitempty"`

	// ProfileId Profile ID this queue belongs to
	ProfileId *string      `json:"profileId,omitempty"`
	Slots     *[]QueueSlot `json:"slots,omitempty"`

	// Timezone IANA timezone (e.g., America/New_York)
	Timezone  *string    `json:"timezone,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// QueueSlot defines model for QueueSlot.
type QueueSlot struct {
	// DayOfWeek Day of week (0=Sunday, 6=Saturday)
	DayOfWeek *int `json:"dayOfWeek,omitempty"`

	// Time Time in HH:mm format (24-hour)
	Time *string `json:"time,omitempty"`
}

// SnapchatPlatformData Snapchat Public Profile API constraints:
//
// **General Requirements:**
// - Snapchat requires a Public Profile to publish content
// - Media is required for all content types (no text-only posts)
// - Only one media item per post is supported
// - Media is automatically encrypted using AES-256-CBC before upload
//
// **Content Types:**
// - **Story** (default): Ephemeral content visible for 24 hours. No caption/text supported.
// - **Saved Story**: Permanent story on your Public Profile. Uses post content as title (max 45 chars).
// - **Spotlight**: Video content for Snapchat's entertainment feed. Supports description (max 160 chars) with hashtags.
//
// **Media Constraints:**
// - Images: max 20 MB, JPEG/PNG format
// - Videos: max 500 MB, MP4 format, 5-60 seconds duration, minimum 540x960px resolution
// - Aspect ratio: 9:16 recommended
//
// **Analytics:**
// - Views, screenshots, shares, unique viewers, completion rate available
// - Analytics are fetched per content type (story/saved_story/spotlight)
type SnapchatPlatformData struct {
	// ContentType Type of Snapchat content to publish:
	// - `story` - Ephemeral snap visible for 24 hours (default)
	// - `saved_story` - Permanent story saved to Public Profile
	// - `spotlight` - Video posted to Spotlight (Snapchat's TikTok-like feed)
	ContentType *SnapchatPlatformDataContentType `json:"contentType,omitempty"`
}

// SnapchatPlatformDataContentType Type of Snapchat content to publish:
// - `story` - Ephemeral snap visible for 24 hours (default)
// - `saved_story` - Permanent story saved to Public Profile
// - `spotlight` - Video posted to Spotlight (Snapchat's TikTok-like feed)
type SnapchatPlatformDataContentType string

// SocialAccount defines model for SocialAccount.
type SocialAccount struct {
	UnderscoreId *string `json:"_id,omitempty"`
	DisplayName  *string `json:"displayName,omitempty"`

	// FollowersCount Follower count (only included if user has analytics add-on)
	FollowersCount *float32 `json:"followersCount,omitempty"`

	// FollowersLastUpdated Last time follower count was updated (only included if user has analytics add-on)
	FollowersLastUpdated *time.Time               `json:"followersLastUpdated,omitempty"`
	IsActive             *bool                    `json:"isActive,omitempty"`
	Platform             *string                  `json:"platform,omitempty"`
	ProfileId            *SocialAccount_ProfileId `json:"profileId,omitempty"`

	// ProfileUrl Full profile URL for the connected account. Available for all platforms:
	// - Twitter/X: https://x.com/{username}
	// - Instagram: https://instagram.com/{username}
	// - TikTok: https://tiktok.com/@{username}
	// - YouTube: https://youtube.com/@{handle} or https://youtube.com/channel/{id}
	// - LinkedIn Personal: https://www.linkedin.com/in/{vanityName}/
	// - LinkedIn Organization: https://www.linkedin.com/company/{vanityName}/
	// - Threads: https://threads.net/@{username}
	// - Pinterest: https://pinterest.com/{username}
	// - Reddit: https://reddit.com/user/{username}
	// - Bluesky: https://bsky.app/profile/{handle}
	// - Facebook: https://facebook.com/{username} or https://facebook.com/{pageId}
	// - Google Business: Google Maps URL for the business location
	ProfileUrl *string `json:"profileUrl,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// SocialAccountProfileId0 defines model for .
type SocialAccountProfileId0 = string

// SocialAccount_ProfileId defines model for SocialAccount.ProfileId.
type SocialAccount_ProfileId struct {
	union json.RawMessage
}

// TelegramPlatformData Telegram channel/group posting settings:
// - Supports text, images (up to 10), videos (up to 10), and mixed media albums
// - Posts to channels display the channel name and logo as author
// - Posts to groups display the bot name (Late) as author
// - Message IDs are returned for analytics tracking
// - Captions support up to 1024 characters for media posts, 4096 for text-only
//
// **Analytics:**
// - **Not available via API.** The Telegram Bot API does not expose message analytics (views, forwards, reactions).
// - View counts are only visible to channel admins directly in the Telegram app.
// - This is a Telegram platform limitation that affects all third-party tools.
type TelegramPlatformData struct {
	// DisableNotification Send the message silently (users will receive notification without sound)
	DisableNotification *bool `json:"disableNotification,omitempty"`

	// DisableWebPagePreview Disable link preview generation for URLs in the message
	DisableWebPagePreview *bool `json:"disableWebPagePreview,omitempty"`

	// ParseMode Text formatting mode for the message (default is HTML)
	ParseMode *TelegramPlatformDataParseMode `json:"parseMode,omitempty"`

	// ProtectContent Protect message content from forwarding and saving
	ProtectContent *bool `json:"protectContent,omitempty"`
}

// TelegramPlatformDataParseMode Text formatting mode for the message (default is HTML)
type TelegramPlatformDataParseMode string

// ThreadsPlatformData Constraints:
// - Carousel posts support up to 10 images (no videos in carousels).
// - Single posts support one image or one video.
// - Videos must be H.264/AAC MP4 format, max 5 minutes duration.
// - Images must be JPEG or PNG, max 8 MB each.
// - threadItems creates a reply chain (Threads equivalent of Twitter threads).
type ThreadsPlatformData struct {
	// ThreadItems Sequence of posts in a Threads thread (root then replies in order).
	ThreadItems *[]struct {
		Content    *string      `json:"content,omitempty"`
		MediaItems *[]MediaItem `json:"mediaItems,omitempty"`
	} `json:"threadItems,omitempty"`
}

// TikTokPlatformData TikTok platform-specific settings for video/photo posting.
//
// **Constraints:**
// - Photo carousels support up to 35 images.
// - **Title length limits**:
//   - Videos: up to 2200 chars (full content used as title)
//   - Photos: content is automatically truncated to 90 chars for title (hashtags/URLs stripped). Use 'description' field for longer text (up to 4000 chars).
//
// - privacyLevel must be chosen from creator_info.privacy_level_options (no defaulting).
// - allowDuet and allowStitch required for videos; allowComment for all.
// - contentPreviewConfirmed and expressConsentGiven must be true before posting.
//
// **Note:** Both camelCase and snake_case field names are accepted for backwards compatibility.
// The nested `tiktokSettings` object format is also still supported but deprecated.
type TikTokPlatformData struct {
	// AllowComment Allow comments on the post
	AllowComment *bool `json:"allowComment,omitempty"`

	// AllowDuet Allow duets (required for video posts)
	AllowDuet *bool `json:"allowDuet,omitempty"`

	// AllowStitch Allow stitches (required for video posts)
	AllowStitch *bool `json:"allowStitch,omitempty"`

	// AutoAddMusic When true, TikTok may add recommended music (photos only)
	AutoAddMusic *bool `json:"autoAddMusic,omitempty"`

	// BrandPartnerPromote Whether the post promotes a brand partner
	BrandPartnerPromote *bool `json:"brandPartnerPromote,omitempty"`

	// CommercialContentType Type of commercial content disclosure
	CommercialContentType *TikTokPlatformDataCommercialContentType `json:"commercialContentType,omitempty"`

	// ContentPreviewConfirmed User has confirmed they previewed the content
	ContentPreviewConfirmed *bool `json:"contentPreviewConfirmed,omitempty"`

	// Description Optional long-form description for photo posts (max 4000 chars).
	// Recommended for photo posts when content exceeds 90 characters, as photo titles are automatically truncated to 90 chars (after stripping hashtags/URLs).
	Description *string `json:"description,omitempty"`

	// Draft When true, Late sends the post to the TikTok Creator Inbox as a draft instead of publishing it immediately. When omitted or false, TikTok uses direct posting (live publish) as usual.
	Draft *bool `json:"draft,omitempty"`

	// ExpressConsentGiven User has given express consent for posting
	ExpressConsentGiven *bool `json:"expressConsentGiven,omitempty"`

	// IsBrandOrganicPost Whether the post is a brand organic post
	IsBrandOrganicPost *bool `json:"isBrandOrganicPost,omitempty"`

	// MediaType Optional override. Defaults based on provided media items.
	MediaType *TikTokPlatformDataMediaType `json:"mediaType,omitempty"`

	// PhotoCoverIndex Optional for photo carousels. Index of image to use as cover, 0-based (defaults to 0/first image).
	PhotoCoverIndex *int `json:"photoCoverIndex,omitempty"`

	// PrivacyLevel One of the values returned by the TikTok creator info API for the account
	PrivacyLevel *string `json:"privacyLevel,omitempty"`

	// VideoCoverTimestampMs Optional for video posts. Timestamp in milliseconds to select which frame to use as thumbnail (defaults to 1000ms/1 second).
	VideoCoverTimestampMs *int `json:"videoCoverTimestampMs,omitempty"`

	// VideoMadeWithAi Set true to disclose AI-generated content
	VideoMadeWithAi *bool `json:"videoMadeWithAi,omitempty"`
}

// TikTokPlatformDataCommercialContentType Type of commercial content disclosure
type TikTokPlatformDataCommercialContentType string

// TikTokPlatformDataMediaType Optional override. Defaults based on provided media items.
type TikTokPlatformDataMediaType string

// TwitterPlatformData defines model for TwitterPlatformData.
type TwitterPlatformData struct {
	// ThreadItems Sequence of tweets in a thread. First item is the root tweet.
	ThreadItems *[]struct {
		Content    *string      `json:"content,omitempty"`
		MediaItems *[]MediaItem `json:"mediaItems,omitempty"`
	} `json:"threadItems,omitempty"`
}

// UsageStats defines model for UsageStats.
type UsageStats struct {
	BillingPeriod *UsageStatsBillingPeriod `json:"billingPeriod,omitempty"`
	Limits        *struct {
		Profiles *int `json:"profiles,omitempty"`
		Uploads  *int `json:"uploads,omitempty"`
	} `json:"limits,omitempty"`
	PlanName   *string    `json:"planName,omitempty"`
	SignupDate *time.Time `json:"signupDate,omitempty"`
	Usage      *struct {
		LastReset *time.Time `json:"lastReset,omitempty"`
		Profiles  *int       `json:"profiles,omitempty"`
		Uploads   *int       `json:"uploads,omitempty"`
	} `json:"usage,omitempty"`
}

// UsageStatsBillingPeriod defines model for UsageStats.BillingPeriod.
type UsageStatsBillingPeriod string

// User defines model for User.
type User struct {
	UnderscoreId *string    `json:"_id,omitempty"`
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	Email        *string    `json:"email,omitempty"`
	Name         *string    `json:"name,omitempty"`
	Role         *string    `json:"role,omitempty"`
}

// Webhook Individual webhook configuration for receiving real-time notifications
type Webhook struct {
	// UnderscoreId Unique webhook identifier
	UnderscoreId *string `json:"_id,omitempty"`

	// CustomHeaders Custom headers included in webhook requests
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// Events Events subscribed to
	Events *[]WebhookEvents `json:"events,omitempty"`

	// FailureCount Consecutive delivery failures (resets on success, webhook disabled at 10)
	FailureCount *int `json:"failureCount,omitempty"`

	// IsActive Whether webhook delivery is enabled
	IsActive *bool `json:"isActive,omitempty"`

	// LastFiredAt Timestamp of last successful webhook delivery
	LastFiredAt *time.Time `json:"lastFiredAt,omitempty"`

	// Name Webhook name (for identification)
	Name *string `json:"name,omitempty"`

	// Secret Secret key for HMAC-SHA256 signature (not returned in responses for security)
	Secret *string `json:"secret,omitempty"`

	// Url Webhook endpoint URL
	Url *string `json:"url,omitempty"`
}

// WebhookEvents defines model for Webhook.Events.
type WebhookEvents string

// WebhookLog Webhook delivery log entry
type WebhookLog struct {
	UnderscoreId *string `json:"_id,omitempty"`

	// AttemptNumber Delivery attempt number (max 3 retries)
	AttemptNumber *int       `json:"attemptNumber,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty"`

	// ErrorMessage Error message if delivery failed
	ErrorMessage *string          `json:"errorMessage,omitempty"`
	Event        *WebhookLogEvent `json:"event,omitempty"`

	// RequestPayload Payload sent to webhook endpoint
	RequestPayload *map[string]interface{} `json:"requestPayload,omitempty"`

	// ResponseBody Response body from webhook endpoint (truncated to 10KB)
	ResponseBody *string `json:"responseBody,omitempty"`

	// ResponseTime Response time in milliseconds
	ResponseTime *int              `json:"responseTime,omitempty"`
	Status       *WebhookLogStatus `json:"status,omitempty"`

	// StatusCode HTTP status code from webhook endpoint
	StatusCode *int    `json:"statusCode,omitempty"`
	Url        *string `json:"url,omitempty"`

	// WebhookId ID of the webhook that was triggered
	WebhookId *string `json:"webhookId,omitempty"`

	// WebhookName Name of the webhook that was triggered
	WebhookName *string `json:"webhookName,omitempty"`
}

// WebhookLogEvent defines model for WebhookLog.Event.
type WebhookLogEvent string

// WebhookLogStatus defines model for WebhookLog.Status.
type WebhookLogStatus string

// YouTubeDailyViewsResponse defines model for YouTubeDailyViewsResponse.
type YouTubeDailyViewsResponse struct {
	DailyViews *[]struct {
		// AverageViewDuration Average view duration in seconds
		AverageViewDuration     *float32            `json:"averageViewDuration,omitempty"`
		Comments                *int                `json:"comments,omitempty"`
		Date                    *openapi_types.Date `json:"date,omitempty"`
		EstimatedMinutesWatched *float32            `json:"estimatedMinutesWatched,omitempty"`
		Likes                   *int                `json:"likes,omitempty"`
		Shares                  *int                `json:"shares,omitempty"`
		SubscribersGained       *int                `json:"subscribersGained,omitempty"`
		SubscribersLost         *int                `json:"subscribersLost,omitempty"`
		Views                   *int                `json:"views,omitempty"`
	} `json:"dailyViews,omitempty"`
	DateRange *struct {
		EndDate   *openapi_types.Date `json:"endDate,omitempty"`
		StartDate *openapi_types.Date `json:"startDate,omitempty"`
	} `json:"dateRange,omitempty"`

	// LastSyncedAt When the data was last synced from YouTube
	LastSyncedAt *time.Time `json:"lastSyncedAt"`
	ScopeStatus  *struct {
		HasAnalyticsScope *bool `json:"hasAnalyticsScope,omitempty"`
	} `json:"scopeStatus,omitempty"`
	Success *bool `json:"success,omitempty"`

	// TotalViews Sum of views across all days in the range
	TotalViews *int `json:"totalViews,omitempty"`

	// VideoId The YouTube video ID
	VideoId *string `json:"videoId,omitempty"`
}

// YouTubePlatformData YouTube video upload settings:
// - Videos ≤ 3 minutes are automatically detected as YouTube Shorts
// - Videos > 3 minutes become regular YouTube videos
// - Custom thumbnails supported for regular videos (via mediaItem.thumbnail)
// - Custom thumbnails NOT supported for Shorts via API
// - Scheduled videos are uploaded immediately as the specified visibility and published at scheduled time
// - Visibility defaults to "public" if not specified
// - madeForKids defaults to false (not child-directed)
// - Set containsSyntheticMedia: true if your video contains AI-generated content
type YouTubePlatformData struct {
	// CategoryId YouTube video category ID. Defaults to '22' (People & Blogs).
	// Common categories: 1 (Film & Animation), 2 (Autos & Vehicles), 10 (Music),
	// 15 (Pets & Animals), 17 (Sports), 20 (Gaming), 22 (People & Blogs),
	// 23 (Comedy), 24 (Entertainment), 25 (News & Politics), 26 (Howto & Style),
	// 27 (Education), 28 (Science & Technology).
	CategoryId *string `json:"categoryId,omitempty"`

	// ContainsSyntheticMedia AI-generated content disclosure flag. Set to true if your video contains AI-generated or synthetic content
	// that could be mistaken for real people, places, or events. This helps viewers understand when realistic
	// content has been created or altered using AI. YouTube may add a label to videos when this is set.
	// Added to YouTube Data API in October 2024.
	ContainsSyntheticMedia *bool `json:"containsSyntheticMedia,omitempty"`

	// FirstComment Optional first comment to post immediately after video upload. Up to 10,000 characters (YouTube's comment limit).
	FirstComment *string `json:"firstComment,omitempty"`

	// MadeForKids COPPA compliance: Audience designation for the video.
	// - true: Video is made for kids (child-directed content)
	// - false: Video is NOT made for kids (default)
	//
	// This field maps to YouTube's `selfDeclaredMadeForKids` setting. Videos marked as made for kids
	// have restricted features (no comments, no notifications, limited ad targeting).
	//
	// IMPORTANT: If not specified, defaults to false. YouTube requires this to be explicitly set,
	// otherwise the video may be blocked from views until configured in YouTube Studio.
	MadeForKids *bool `json:"madeForKids,omitempty"`

	// Title Video title. Defaults to first line of content or "Untitled Video". Must be ≤ 100 characters.
	Title *string `json:"title,omitempty"`

	// Visibility Video visibility setting:
	// - public: Anyone can search for and watch (default)
	// - unlisted: Only people with the link can watch
	// - private: Only you and people you specifically share with can watch
	Visibility *YouTubePlatformDataVisibility `json:"visibility,omitempty"`
}

// YouTubePlatformDataVisibility Video visibility setting:
// - public: Anyone can search for and watch (default)
// - unlisted: Only people with the link can watch
// - private: Only you and people you specifically share with can watch
type YouTubePlatformDataVisibility string

// YouTubeScopeMissingResponse defines model for YouTubeScopeMissingResponse.
type YouTubeScopeMissingResponse struct {
	Code        *string `json:"code,omitempty"`
	Error       *string `json:"error,omitempty"`
	ScopeStatus *struct {
		HasAnalyticsScope *bool `json:"hasAnalyticsScope,omitempty"`

		// ReauthorizeUrl URL to redirect user for reauthorization
		ReauthorizeUrl          *string `json:"reauthorizeUrl,omitempty"`
		RequiresReauthorization *bool   `json:"requiresReauthorization,omitempty"`
	} `json:"scopeStatus,omitempty"`
	Success *bool `json:"success,omitempty"`
}

// LimitParam defines model for LimitParam.
type LimitParam = int

// PageParam defines model for PageParam.
type PageParam = int

// NotFound defines model for NotFound.
type NotFound struct {
	Error *string `json:"error,omitempty"`
}

// Unauthorized defines model for Unauthorized.
type Unauthorized struct {
	Error *string `json:"error,omitempty"`
}

// CreateAccountGroupJSONBody defines parameters for CreateAccountGroup.
type CreateAccountGroupJSONBody struct {
	AccountIds []string `json:"accountIds"`
	Name       string   `json:"name"`
}

// UpdateAccountGroupJSONBody defines parameters for UpdateAccountGroup.
type UpdateAccountGroupJSONBody struct {
	AccountIds *[]string `json:"accountIds,omitempty"`
	Name       *string   `json:"name,omitempty"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// ProfileId Filter accounts by profile ID
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// IncludeOverLimit When true, includes accounts from profiles that exceed the user's plan limit.
	// Useful for disconnecting accounts from over-limit profiles so they can be deleted.
	IncludeOverLimit *bool `form:"includeOverLimit,omitempty" json:"includeOverLimit,omitempty"`
}

// GetFollowerStatsParams defines parameters for GetFollowerStats.
type GetFollowerStatsParams struct {
	// AccountIds Comma-separated list of account IDs (optional, defaults to all user's accounts)
	AccountIds *string `form:"accountIds,omitempty" json:"accountIds,omitempty"`

	// ProfileId Filter by profile ID
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// FromDate Start date in YYYY-MM-DD format (defaults to 30 days ago)
	FromDate *openapi_types.Date `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date in YYYY-MM-DD format (defaults to today)
	ToDate *openapi_types.Date `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Granularity Data aggregation level
	Granularity *GetFollowerStatsParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`
}

// GetFollowerStatsParamsGranularity defines parameters for GetFollowerStats.
type GetFollowerStatsParamsGranularity string

// GetAllAccountsHealthParams defines parameters for GetAllAccountsHealth.
type GetAllAccountsHealthParams struct {
	// ProfileId Filter by profile ID
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// Platform Filter by platform
	Platform *GetAllAccountsHealthParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`

	// Status Filter by health status
	Status *GetAllAccountsHealthParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetAllAccountsHealthParamsPlatform defines parameters for GetAllAccountsHealth.
type GetAllAccountsHealthParamsPlatform string

// GetAllAccountsHealthParamsStatus defines parameters for GetAllAccountsHealth.
type GetAllAccountsHealthParamsStatus string

// UpdateAccountJSONBody defines parameters for UpdateAccount.
type UpdateAccountJSONBody struct {
	DisplayName *string `json:"displayName,omitempty"`
	Username    *string `json:"username,omitempty"`
}

// UpdateFacebookPageJSONBody defines parameters for UpdateFacebookPage.
type UpdateFacebookPageJSONBody struct {
	SelectedPageId string `json:"selectedPageId"`
}

// UpdateGoogleBusinessAttributesJSONBody defines parameters for UpdateGoogleBusinessAttributes.
type UpdateGoogleBusinessAttributesJSONBody struct {
	// AttributeMask Comma-separated attribute names to update (e.g. 'has_delivery,has_takeout')
	AttributeMask string `json:"attributeMask"`
	Attributes    []struct {
		Name              *string `json:"name,omitempty"`
		RepeatedEnumValue *struct {
			SetValues   *[]string `json:"setValues,omitempty"`
			UnsetValues *[]string `json:"unsetValues,omitempty"`
		} `json:"repeatedEnumValue,omitempty"`
		Values *[]interface{} `json:"values,omitempty"`
	} `json:"attributes"`
}

// UpdateGoogleBusinessFoodMenusJSONBody defines parameters for UpdateGoogleBusinessFoodMenus.
type UpdateGoogleBusinessFoodMenusJSONBody struct {
	// Menus Array of food menus to set
	Menus []FoodMenu `json:"menus"`

	// UpdateMask Field mask for partial updates (e.g. "menus")
	UpdateMask *string `json:"updateMask,omitempty"`
}

// GetGoogleBusinessLocationDetailsParams defines parameters for GetGoogleBusinessLocationDetails.
type GetGoogleBusinessLocationDetailsParams struct {
	// ReadMask Comma-separated fields to return. Defaults to common fields.
	// Available: name, title, phoneNumbers, categories, storefrontAddress, websiteUri,
	// regularHours, specialHours, serviceArea, profile, openInfo, metadata, moreHours
	ReadMask *string `form:"readMask,omitempty" json:"readMask,omitempty"`
}

// UpdateGoogleBusinessLocationDetailsJSONBody defines parameters for UpdateGoogleBusinessLocationDetails.
type UpdateGoogleBusinessLocationDetailsJSONBody struct {
	PhoneNumbers *struct {
		AdditionalPhones *[]string `json:"additionalPhones,omitempty"`
		PrimaryPhone     *string   `json:"primaryPhone,omitempty"`
	} `json:"phoneNumbers,omitempty"`
	Profile *struct {
		Description *string `json:"description,omitempty"`
	} `json:"profile,omitempty"`
	RegularHours *struct {
		Periods *[]struct {
			CloseDay  *string `json:"closeDay,omitempty"`
			CloseTime *string `json:"closeTime,omitempty"`
			OpenDay   *string `json:"openDay,omitempty"`
			OpenTime  *string `json:"openTime,omitempty"`
		} `json:"periods,omitempty"`
	} `json:"regularHours,omitempty"`
	SpecialHours *struct {
		SpecialHourPeriods *[]struct {
			CloseTime *string `json:"closeTime,omitempty"`
			Closed    *bool   `json:"closed,omitempty"`
			EndDate   *struct {
				Day   *int `json:"day,omitempty"`
				Month *int `json:"month,omitempty"`
				Year  *int `json:"year,omitempty"`
			} `json:"endDate,omitempty"`
			OpenTime  *string `json:"openTime,omitempty"`
			StartDate *struct {
				Day   *int `json:"day,omitempty"`
				Month *int `json:"month,omitempty"`
				Year  *int `json:"year,omitempty"`
			} `json:"startDate,omitempty"`
		} `json:"specialHourPeriods,omitempty"`
	} `json:"specialHours,omitempty"`

	// UpdateMask Required. Comma-separated fields to update (e.g. 'regularHours', 'specialHours', 'profile.description')
	UpdateMask string  `json:"updateMask"`
	WebsiteUri *string `json:"websiteUri,omitempty"`
}

// UpdateGmbLocationJSONBody defines parameters for UpdateGmbLocation.
type UpdateGmbLocationJSONBody struct {
	SelectedLocationId string `json:"selectedLocationId"`
}

// DeleteGoogleBusinessMediaParams defines parameters for DeleteGoogleBusinessMedia.
type DeleteGoogleBusinessMediaParams struct {
	// MediaId The media item ID to delete
	MediaId string `form:"mediaId" json:"mediaId"`
}

// ListGoogleBusinessMediaParams defines parameters for ListGoogleBusinessMedia.
type ListGoogleBusinessMediaParams struct {
	// PageSize Number of items to return (max 100)
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken Pagination token from previous response
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateGoogleBusinessMediaJSONBody defines parameters for CreateGoogleBusinessMedia.
type CreateGoogleBusinessMediaJSONBody struct {
	// Category Where the photo appears on the listing
	Category *CreateGoogleBusinessMediaJSONBodyCategory `json:"category,omitempty"`

	// Description Photo description
	Description *string                                       `json:"description,omitempty"`
	MediaFormat *CreateGoogleBusinessMediaJSONBodyMediaFormat `json:"mediaFormat,omitempty"`

	// SourceUrl Publicly accessible image URL
	SourceUrl string `json:"sourceUrl"`
}

// CreateGoogleBusinessMediaJSONBodyCategory defines parameters for CreateGoogleBusinessMedia.
type CreateGoogleBusinessMediaJSONBodyCategory string

// CreateGoogleBusinessMediaJSONBodyMediaFormat defines parameters for CreateGoogleBusinessMedia.
type CreateGoogleBusinessMediaJSONBodyMediaFormat string

// DeleteGoogleBusinessPlaceActionParams defines parameters for DeleteGoogleBusinessPlaceAction.
type DeleteGoogleBusinessPlaceActionParams struct {
	// Name The resource name of the place action link (e.g. locations/123/placeActionLinks/456)
	Name string `form:"name" json:"name"`
}

// ListGoogleBusinessPlaceActionsParams defines parameters for ListGoogleBusinessPlaceActions.
type ListGoogleBusinessPlaceActionsParams struct {
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateGoogleBusinessPlaceActionJSONBody defines parameters for CreateGoogleBusinessPlaceAction.
type CreateGoogleBusinessPlaceActionJSONBody struct {
	// PlaceActionType Type of action
	PlaceActionType CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType `json:"placeActionType"`

	// Uri The action URL
	Uri string `json:"uri"`
}

// CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType defines parameters for CreateGoogleBusinessPlaceAction.
type CreateGoogleBusinessPlaceActionJSONBodyPlaceActionType string

// GetGoogleBusinessReviewsParams defines parameters for GetGoogleBusinessReviews.
type GetGoogleBusinessReviewsParams struct {
	// PageSize Number of reviews to fetch per page (max 50)
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken Pagination token from previous response
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetLinkedInAggregateAnalyticsParams defines parameters for GetLinkedInAggregateAnalytics.
type GetLinkedInAggregateAnalyticsParams struct {
	// Aggregation Type of aggregation for the analytics data.
	// - `TOTAL` (default): Returns single totals for each metric
	// - `DAILY`: Returns daily breakdown of metrics
	//
	// Note: `MEMBERS_REACHED` metric is not available with `DAILY` aggregation.
	Aggregation *GetLinkedInAggregateAnalyticsParamsAggregation `form:"aggregation,omitempty" json:"aggregation,omitempty"`

	// StartDate Start date for analytics data in YYYY-MM-DD format.
	// If provided without endDate, endDate defaults to today.
	// If omitted entirely, returns lifetime analytics.
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for analytics data in YYYY-MM-DD format (exclusive).
	// If provided without startDate, startDate defaults to 30 days before endDate.
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Metrics Comma-separated list of metrics to fetch. If omitted, fetches all available metrics.
	// Valid values: IMPRESSION, MEMBERS_REACHED, REACTION, COMMENT, RESHARE
	Metrics *string `form:"metrics,omitempty" json:"metrics,omitempty"`
}

// GetLinkedInAggregateAnalyticsParamsAggregation defines parameters for GetLinkedInAggregateAnalytics.
type GetLinkedInAggregateAnalyticsParamsAggregation string

// GetLinkedInMentionsParams defines parameters for GetLinkedInMentions.
type GetLinkedInMentionsParams struct {
	// Url LinkedIn profile URL, company URL, or vanity name.
	// - Person: `miquelpalet`, `linkedin.com/in/miquelpalet`
	// - Organization: `company/microsoft`, `linkedin.com/company/microsoft`
	Url string `form:"url" json:"url"`

	// DisplayName The exact display name as shown on LinkedIn.
	// - **Person mentions:** Required for clickable mentions. If not provided, a name is derived from the vanity URL which may not match exactly.
	// - **Organization mentions:** Optional. If not provided, the company name is automatically retrieved from LinkedIn.
	DisplayName *string `form:"displayName,omitempty" json:"displayName,omitempty"`
}

// UpdateLinkedInOrganizationJSONBody defines parameters for UpdateLinkedInOrganization.
type UpdateLinkedInOrganizationJSONBody struct {
	AccountType          UpdateLinkedInOrganizationJSONBodyAccountType `json:"accountType"`
	SelectedOrganization *map[string]interface{}                       `json:"selectedOrganization,omitempty"`
}

// UpdateLinkedInOrganizationJSONBodyAccountType defines parameters for UpdateLinkedInOrganization.
type UpdateLinkedInOrganizationJSONBodyAccountType string

// GetLinkedInPostAnalyticsParams defines parameters for GetLinkedInPostAnalytics.
type GetLinkedInPostAnalyticsParams struct {
	// Urn The LinkedIn post URN
	Urn string `form:"urn" json:"urn"`
}

// UpdatePinterestBoardsJSONBody defines parameters for UpdatePinterestBoards.
type UpdatePinterestBoardsJSONBody struct {
	DefaultBoardId   string  `json:"defaultBoardId"`
	DefaultBoardName *string `json:"defaultBoardName,omitempty"`
}

// UpdateRedditSubredditsJSONBody defines parameters for UpdateRedditSubreddits.
type UpdateRedditSubredditsJSONBody struct {
	DefaultSubreddit string `json:"defaultSubreddit"`
}

// GetAnalyticsParams defines parameters for GetAnalytics.
type GetAnalyticsParams struct {
	// PostId Returns analytics for a single post. Accepts both Late Post IDs (from `POST /v1/posts`)
	// and External Post IDs (from this endpoint's list response). The API automatically
	// resolves Late Post IDs to their corresponding External Post analytics.
	PostId *string `form:"postId,omitempty" json:"postId,omitempty"`

	// Platform Filter by platform (default "all")
	Platform *string `form:"platform,omitempty" json:"platform,omitempty"`

	// ProfileId Filter by profile ID (default "all")
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// Source Filter by post source:
	// - `late` - Only posts scheduled/published via Late API
	// - `external` - Only posts synced from the platform (not posted via Late)
	// - `all` - All posts (default)
	Source *GetAnalyticsParamsSource `form:"source,omitempty" json:"source,omitempty"`

	// FromDate Inclusive lower bound
	FromDate *openapi_types.Date `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate Inclusive upper bound
	ToDate *openapi_types.Date `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Limit Page size (default 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number (default 1)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// SortBy Sort by date or engagement
	SortBy *GetAnalyticsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Order Sort order
	Order *GetAnalyticsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// GetAnalyticsParamsSource defines parameters for GetAnalytics.
type GetAnalyticsParamsSource string

// GetAnalyticsParamsSortBy defines parameters for GetAnalytics.
type GetAnalyticsParamsSortBy string

// GetAnalyticsParamsOrder defines parameters for GetAnalytics.
type GetAnalyticsParamsOrder string

// GetYouTubeDailyViewsParams defines parameters for GetYouTubeDailyViews.
type GetYouTubeDailyViewsParams struct {
	// VideoId The YouTube video ID (e.g., "dQw4w9WgXcQ")
	VideoId string `form:"videoId" json:"videoId"`

	// AccountId The Late account ID for the YouTube account
	AccountId string `form:"accountId" json:"accountId"`

	// StartDate Start date (YYYY-MM-DD). Defaults to 30 days ago.
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date (YYYY-MM-DD). Defaults to 3 days ago (YouTube data latency).
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`
}

// CreateApiKeyJSONBody defines parameters for CreateApiKey.
type CreateApiKeyJSONBody struct {
	// ExpiresIn Days until expiry
	ExpiresIn *int   `json:"expiresIn,omitempty"`
	Name      string `json:"name"`
}

// ConnectBlueskyCredentialsJSONBody defines parameters for ConnectBlueskyCredentials.
type ConnectBlueskyCredentialsJSONBody struct {
	// AppPassword App password generated from Bluesky Settings > App Passwords
	AppPassword string `json:"appPassword"`

	// Identifier Your Bluesky handle (e.g. user.bsky.social) or email address
	Identifier string `json:"identifier"`

	// RedirectUri Optional URL to redirect to after successful connection
	RedirectUri *string `json:"redirectUri,omitempty"`

	// State Required state parameter formatted as `{userId}-{profileId}`.
	// - `userId`: Your Late user ID (get from `GET /v1/users` → `currentUserId`)
	// - `profileId`: The profile ID to connect the account to (get from `GET /v1/profiles`)
	State string `json:"state"`
}

// ListFacebookPagesParams defines parameters for ListFacebookPages.
type ListFacebookPagesParams struct {
	// ProfileId Profile ID from your connection flow
	ProfileId string `form:"profileId" json:"profileId"`

	// TempToken Temporary Facebook access token from the OAuth callback redirect
	TempToken string `form:"tempToken" json:"tempToken"`
}

// SelectFacebookPageJSONBody defines parameters for SelectFacebookPage.
type SelectFacebookPageJSONBody struct {
	// PageId The Facebook Page ID selected by the user
	PageId string `json:"pageId"`

	// ProfileId Profile ID from your connection flow
	ProfileId string `json:"profileId"`

	// RedirectUrl Optional custom redirect URL to return to after selection
	RedirectUrl *string `json:"redirect_url,omitempty"`

	// TempToken Temporary Facebook access token from OAuth
	TempToken string `json:"tempToken"`

	// UserProfile Decoded user profile object from the OAuth callback
	UserProfile *struct {
		Id             *string `json:"id,omitempty"`
		Name           *string `json:"name,omitempty"`
		ProfilePicture *string `json:"profilePicture,omitempty"`
	} `json:"userProfile,omitempty"`
}

// ListGoogleBusinessLocationsParams defines parameters for ListGoogleBusinessLocations.
type ListGoogleBusinessLocationsParams struct {
	// ProfileId Profile ID from your connection flow
	ProfileId string `form:"profileId" json:"profileId"`

	// TempToken Temporary Google access token from the OAuth callback redirect
	TempToken string `form:"tempToken" json:"tempToken"`
}

// SelectGoogleBusinessLocationJSONBody defines parameters for SelectGoogleBusinessLocation.
type SelectGoogleBusinessLocationJSONBody struct {
	// LocationId The Google Business location ID selected by the user
	LocationId string `json:"locationId"`

	// ProfileId Profile ID from your connection flow
	ProfileId string `json:"profileId"`

	// RedirectUrl Optional custom redirect URL to return to after selection
	RedirectUrl *string `json:"redirect_url,omitempty"`

	// TempToken Temporary Google access token from OAuth
	TempToken string `json:"tempToken"`

	// UserProfile Decoded user profile object from the OAuth callback. **Important:** This contains
	// the refresh token needed for token refresh. Always include this field.
	UserProfile *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`

		// RefreshToken Google refresh token for long-lived access
		RefreshToken *string `json:"refreshToken,omitempty"`

		// Scope Granted OAuth scopes
		Scope *string `json:"scope,omitempty"`

		// TokenExpiresIn Token expiration time in seconds
		TokenExpiresIn *int `json:"tokenExpiresIn,omitempty"`
	} `json:"userProfile,omitempty"`
}

// ListLinkedInOrganizationsParams defines parameters for ListLinkedInOrganizations.
type ListLinkedInOrganizationsParams struct {
	// TempToken The temporary LinkedIn access token from the OAuth redirect
	TempToken string `form:"tempToken" json:"tempToken"`

	// OrgIds Comma-separated list of organization IDs to fetch details for (max 100)
	OrgIds string `form:"orgIds" json:"orgIds"`
}

// SelectLinkedInOrganizationJSONBody defines parameters for SelectLinkedInOrganization.
type SelectLinkedInOrganizationJSONBody struct {
	AccountType          SelectLinkedInOrganizationJSONBodyAccountType `json:"accountType"`
	ProfileId            string                                        `json:"profileId"`
	RedirectUrl          *string                                       `json:"redirect_url,omitempty"`
	SelectedOrganization *map[string]interface{}                       `json:"selectedOrganization,omitempty"`
	TempToken            string                                        `json:"tempToken"`
	UserProfile          map[string]interface{}                        `json:"userProfile"`
}

// SelectLinkedInOrganizationJSONBodyAccountType defines parameters for SelectLinkedInOrganization.
type SelectLinkedInOrganizationJSONBodyAccountType string

// GetPendingOAuthDataParams defines parameters for GetPendingOAuthData.
type GetPendingOAuthDataParams struct {
	// Token The pending data token from the OAuth redirect URL (`pendingDataToken` parameter)
	Token string `form:"token" json:"token"`
}

// ListPinterestBoardsForSelectionParams defines parameters for ListPinterestBoardsForSelection.
type ListPinterestBoardsForSelectionParams struct {
	// ProfileId Your Late profile ID
	ProfileId string `form:"profileId" json:"profileId"`

	// TempToken Temporary Pinterest access token from the OAuth callback redirect
	TempToken string `form:"tempToken" json:"tempToken"`

	// XConnectToken Short-lived connect token from the OAuth redirect
	XConnectToken string `json:"X-Connect-Token"`
}

// SelectPinterestBoardJSONBody defines parameters for SelectPinterestBoard.
type SelectPinterestBoardJSONBody struct {
	// BoardId The Pinterest Board ID selected by the user
	BoardId string `json:"boardId"`

	// BoardName The board name (for display purposes)
	BoardName *string `json:"boardName,omitempty"`

	// ExpiresIn Token expiration time in seconds
	ExpiresIn *int `json:"expiresIn,omitempty"`

	// ProfileId Your Late profile ID
	ProfileId string `json:"profileId"`

	// RedirectUrl Custom redirect URL after connection completes
	RedirectUrl *string `json:"redirect_url,omitempty"`

	// RefreshToken Pinterest refresh token (if available)
	RefreshToken *string `json:"refreshToken,omitempty"`

	// TempToken Temporary Pinterest access token from OAuth
	TempToken string `json:"tempToken"`

	// UserProfile User profile data from OAuth redirect
	UserProfile *map[string]interface{} `json:"userProfile,omitempty"`
}

// ListSnapchatProfilesParams defines parameters for ListSnapchatProfiles.
type ListSnapchatProfilesParams struct {
	// ProfileId Your Late profile ID
	ProfileId string `form:"profileId" json:"profileId"`

	// TempToken Temporary Snapchat access token from the OAuth callback redirect
	TempToken string `form:"tempToken" json:"tempToken"`

	// XConnectToken Short-lived connect token from the OAuth redirect
	XConnectToken string `json:"X-Connect-Token"`
}

// SelectSnapchatProfileJSONBody defines parameters for SelectSnapchatProfile.
type SelectSnapchatProfileJSONBody struct {
	// ExpiresIn Token expiration time in seconds
	ExpiresIn *int `json:"expiresIn,omitempty"`

	// ProfileId Your Late profile ID
	ProfileId string `json:"profileId"`

	// RedirectUrl Custom redirect URL after connection completes
	RedirectUrl *string `json:"redirect_url,omitempty"`

	// RefreshToken Snapchat refresh token (if available)
	RefreshToken *string `json:"refreshToken,omitempty"`

	// SelectedPublicProfile The selected Snapchat Public Profile
	SelectedPublicProfile struct {
		// DisplayName Display name of the public profile
		DisplayName string `json:"display_name"`

		// Id Snapchat Public Profile ID
		Id string `json:"id"`

		// ProfileImageUrl Profile image URL
		ProfileImageUrl *string `json:"profile_image_url,omitempty"`

		// SubscriberCount Number of subscribers
		SubscriberCount *int `json:"subscriber_count,omitempty"`

		// Username Username/handle
		Username *string `json:"username,omitempty"`
	} `json:"selectedPublicProfile"`

	// TempToken Temporary Snapchat access token from OAuth
	TempToken string `json:"tempToken"`

	// UserProfile User profile data from OAuth redirect
	UserProfile map[string]interface{} `json:"userProfile"`
}

// SelectSnapchatProfileParams defines parameters for SelectSnapchatProfile.
type SelectSnapchatProfileParams struct {
	// XConnectToken Short-lived connect token from the OAuth redirect (for API users)
	XConnectToken *string `json:"X-Connect-Token,omitempty"`
}

// GetTelegramConnectStatusParams defines parameters for GetTelegramConnectStatus.
type GetTelegramConnectStatusParams struct {
	// ProfileId The profile ID to connect the Telegram account to
	ProfileId string `form:"profileId" json:"profileId"`
}

// CompleteTelegramConnectParams defines parameters for CompleteTelegramConnect.
type CompleteTelegramConnectParams struct {
	// Code The access code to check status for
	Code string `form:"code" json:"code"`
}

// InitiateTelegramConnectJSONBody defines parameters for InitiateTelegramConnect.
type InitiateTelegramConnectJSONBody struct {
	// ChatId The Telegram chat ID. Can be:
	// - Numeric ID (e.g., "-1001234567890")
	// - Username with @ prefix (e.g., "@mychannel")
	ChatId string `json:"chatId"`

	// ProfileId The profile ID to connect the account to
	ProfileId string `json:"profileId"`
}

// GetConnectUrlParams defines parameters for GetConnectUrl.
type GetConnectUrlParams struct {
	// ProfileId Your Late profile ID (get from /v1/profiles)
	ProfileId string `form:"profileId" json:"profileId"`

	// RedirectUrl Optional: Your custom redirect URL after connection completes.
	//
	// **Standard Mode:** Omit `headless=true` to use our hosted page selection UI.
	// After the user selects a Facebook Page, Late redirects here with:
	// `?connected=facebook&profileId=X&username=Y`
	//
	// **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile & Snapchat):**
	// Pass `headless=true` as a query parameter on this endpoint (not inside `redirect_url`), e.g.:
	// `GET /v1/connect/facebook?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
	// `GET /v1/connect/linkedin?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
	// `GET /v1/connect/pinterest?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
	// `GET /v1/connect/googlebusiness?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
	// `GET /v1/connect/snapchat?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
	//
	// After OAuth, the user is redirected directly to your `redirect_url` with OAuth data:
	// - **Facebook:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=facebook&step=select_page`
	// - **LinkedIn:** `?profileId=X&pendingDataToken=TOKEN&connect_token=CT&platform=linkedin&step=select_organization`
	//   Use `GET /v1/connect/pending-data?token=TOKEN` to fetch tempToken, userProfile, organizations, refreshToken.
	// - **Pinterest:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=pinterest&step=select_board`
	// - **Google Business:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=googlebusiness&step=select_location`
	// - **Snapchat:** `?profileId=X&tempToken=Y&userProfile=Z&publicProfiles=PROFILES&connect_token=CT&platform=snapchat&step=select_public_profile`
	//   (publicProfiles contains `id`, `display_name`, `username`, `profile_image_url`, `subscriber_count`)
	//
	// Then use the respective endpoints to build your custom UI:
	// - Facebook: `/v1/connect/facebook/select-page` (GET to fetch, POST to save)
	// - LinkedIn: `/v1/connect/linkedin/organizations` (GET to fetch logos), `/v1/connect/linkedin/select-organization` (POST to save)
	// - Pinterest: `/v1/connect/pinterest/select-board` (GET to fetch, POST to save)
	// - Google Business: `/v1/connect/googlebusiness/locations` (GET) and `/v1/connect/googlebusiness/select-location` (POST)
	// - Snapchat: `/v1/connect/snapchat/select-profile` (POST to save selected public profile)
	//
	// Example: `https://yourdomain.com/integrations/callback`
	RedirectUrl *string `form:"redirect_url,omitempty" json:"redirect_url,omitempty"`
}

// GetConnectUrlParamsPlatform defines parameters for GetConnectUrl.
type GetConnectUrlParamsPlatform string

// HandleOAuthCallbackJSONBody defines parameters for HandleOAuthCallback.
type HandleOAuthCallbackJSONBody struct {
	Code      string `json:"code"`
	ProfileId string `json:"profileId"`
	State     string `json:"state"`
}

// ListInboxCommentsParams defines parameters for ListInboxComments.
type ListInboxCommentsParams struct {
	// ProfileId Filter by profile ID
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// Platform Filter by platform
	Platform *ListInboxCommentsParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`

	// MinComments Minimum comment count
	MinComments *int `form:"minComments,omitempty" json:"minComments,omitempty"`

	// Since Posts created after this date
	Since *time.Time `form:"since,omitempty" json:"since,omitempty"`

	// SortBy Sort field
	SortBy *ListInboxCommentsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order
	SortOrder *ListInboxCommentsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	Limit     *int                              `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor    *string                           `form:"cursor,omitempty" json:"cursor,omitempty"`

	// AccountId Filter by specific social account ID
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// ListInboxCommentsParamsPlatform defines parameters for ListInboxComments.
type ListInboxCommentsParamsPlatform string

// ListInboxCommentsParamsSortBy defines parameters for ListInboxComments.
type ListInboxCommentsParamsSortBy string

// ListInboxCommentsParamsSortOrder defines parameters for ListInboxComments.
type ListInboxCommentsParamsSortOrder string

// DeleteInboxCommentParams defines parameters for DeleteInboxComment.
type DeleteInboxCommentParams struct {
	AccountId string `form:"accountId" json:"accountId"`
	CommentId string `form:"commentId" json:"commentId"`
}

// GetInboxPostCommentsParams defines parameters for GetInboxPostComments.
type GetInboxPostCommentsParams struct {
	AccountId string `form:"accountId" json:"accountId"`

	// Subreddit (Reddit only) Subreddit name
	Subreddit *string `form:"subreddit,omitempty" json:"subreddit,omitempty"`

	// Limit Maximum number of comments to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CommentId (Reddit only) Get replies to a specific comment
	CommentId *string `form:"commentId,omitempty" json:"commentId,omitempty"`
}

// ReplyToInboxPostJSONBody defines parameters for ReplyToInboxPost.
type ReplyToInboxPostJSONBody struct {
	AccountId string `json:"accountId"`

	// CommentId Reply to specific comment (optional)
	CommentId *string `json:"commentId,omitempty"`
	Message   string  `json:"message"`

	// ParentCid (Bluesky only) Parent content identifier
	ParentCid *string `json:"parentCid,omitempty"`

	// RootCid (Bluesky only) Root post CID
	RootCid *string `json:"rootCid,omitempty"`

	// RootUri (Bluesky only) Root post URI
	RootUri *string `json:"rootUri,omitempty"`

	// Subreddit (Reddit only) Subreddit name for replies
	Subreddit *string `json:"subreddit,omitempty"`
}

// UnhideInboxCommentParams defines parameters for UnhideInboxComment.
type UnhideInboxCommentParams struct {
	AccountId string `form:"accountId" json:"accountId"`
}

// HideInboxCommentJSONBody defines parameters for HideInboxComment.
type HideInboxCommentJSONBody struct {
	// AccountId The social account ID
	AccountId string `json:"accountId"`
}

// UnlikeInboxCommentParams defines parameters for UnlikeInboxComment.
type UnlikeInboxCommentParams struct {
	AccountId string `form:"accountId" json:"accountId"`

	// LikeUri (Bluesky only) The like URI returned when liking
	LikeUri *string `form:"likeUri,omitempty" json:"likeUri,omitempty"`
}

// LikeInboxCommentJSONBody defines parameters for LikeInboxComment.
type LikeInboxCommentJSONBody struct {
	// AccountId The social account ID
	AccountId string `json:"accountId"`

	// Cid (Bluesky only) Content identifier for the comment
	Cid *string `json:"cid,omitempty"`
}

// SendPrivateReplyToCommentJSONBody defines parameters for SendPrivateReplyToComment.
type SendPrivateReplyToCommentJSONBody struct {
	// AccountId The Instagram social account ID
	AccountId string `json:"accountId"`

	// Message The message text to send as a private DM
	Message string `json:"message"`
}

// ListInboxConversationsParams defines parameters for ListInboxConversations.
type ListInboxConversationsParams struct {
	// ProfileId Filter by profile ID
	ProfileId *string `form:"profileId,omitempty" json:"profileId,omitempty"`

	// Platform Filter by platform
	Platform *ListInboxConversationsParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`

	// Status Filter by conversation status
	Status *ListInboxConversationsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortOrder Sort order by updated time
	SortOrder *ListInboxConversationsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Limit Maximum number of conversations to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor for next page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// AccountId Filter by specific social account ID
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// ListInboxConversationsParamsPlatform defines parameters for ListInboxConversations.
type ListInboxConversationsParamsPlatform string

// ListInboxConversationsParamsStatus defines parameters for ListInboxConversations.
type ListInboxConversationsParamsStatus string

// ListInboxConversationsParamsSortOrder defines parameters for ListInboxConversations.
type ListInboxConversationsParamsSortOrder string

// GetInboxConversationParams defines parameters for GetInboxConversation.
type GetInboxConversationParams struct {
	// AccountId The social account ID
	AccountId string `form:"accountId" json:"accountId"`
}

// UpdateInboxConversationJSONBody defines parameters for UpdateInboxConversation.
type UpdateInboxConversationJSONBody struct {
	// AccountId Social account ID
	AccountId string                                `json:"accountId"`
	Status    UpdateInboxConversationJSONBodyStatus `json:"status"`
}

// UpdateInboxConversationJSONBodyStatus defines parameters for UpdateInboxConversation.
type UpdateInboxConversationJSONBodyStatus string

// GetInboxConversationMessagesParams defines parameters for GetInboxConversationMessages.
type GetInboxConversationMessagesParams struct {
	// AccountId Social account ID
	AccountId string `form:"accountId" json:"accountId"`
}

// SendInboxMessageJSONBody defines parameters for SendInboxMessage.
type SendInboxMessageJSONBody struct {
	// AccountId Social account ID
	AccountId string `json:"accountId"`

	// Message Message text
	Message string `json:"message"`
}

// SendInboxMessageMultipartBody defines parameters for SendInboxMessage.
type SendInboxMessageMultipartBody struct {
	// AccountId Social account ID
	AccountId string `json:"accountId"`

	// Attachment File attachment (images, videos, documents). See description for platform support.
	// Supported formats: JPEG, PNG, GIF, MP4. Max size: 25MB.
	Attachment *openapi_types.File `json:"attachment,omitempty"`

	// Message Message text (optional when sending attachment)
	Message *string `json:"message,omitempty"`
}

// ListInboxReviewsParams defines parameters for ListInboxReviews.
type ListInboxReviewsParams struct {
	ProfileId *string                         `form:"profileId,omitempty" json:"profileId,omitempty"`
	Platform  *ListInboxReviewsParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`
	MinRating *int                            `form:"minRating,omitempty" json:"minRating,omitempty"`
	MaxRating *int                            `form:"maxRating,omitempty" json:"maxRating,omitempty"`

	// HasReply Filter by reply status
	HasReply  *bool                            `form:"hasReply,omitempty" json:"hasReply,omitempty"`
	SortBy    *ListInboxReviewsParamsSortBy    `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	SortOrder *ListInboxReviewsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	Limit     *int                             `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor    *string                          `form:"cursor,omitempty" json:"cursor,omitempty"`

	// AccountId Filter by specific social account ID
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// ListInboxReviewsParamsPlatform defines parameters for ListInboxReviews.
type ListInboxReviewsParamsPlatform string

// ListInboxReviewsParamsSortBy defines parameters for ListInboxReviews.
type ListInboxReviewsParamsSortBy string

// ListInboxReviewsParamsSortOrder defines parameters for ListInboxReviews.
type ListInboxReviewsParamsSortOrder string

// DeleteInboxReviewReplyJSONBody defines parameters for DeleteInboxReviewReply.
type DeleteInboxReviewReplyJSONBody struct {
	AccountId string `json:"accountId"`
}

// ReplyToInboxReviewJSONBody defines parameters for ReplyToInboxReview.
type ReplyToInboxReviewJSONBody struct {
	AccountId string `json:"accountId"`
	Message   string `json:"message"`
}

// CreateInviteTokenJSONBody defines parameters for CreateInviteToken.
type CreateInviteTokenJSONBody struct {
	// ProfileIds Required if scope is 'profiles'. Array of profile IDs to grant access to.
	ProfileIds *[]string `json:"profileIds,omitempty"`

	// Scope 'all' grants access to all profiles, 'profiles' restricts to specific profiles
	Scope CreateInviteTokenJSONBodyScope `json:"scope"`
}

// CreateInviteTokenJSONBodyScope defines parameters for CreateInviteToken.
type CreateInviteTokenJSONBodyScope string

// ListLogsParams defines parameters for ListLogs.
type ListLogsParams struct {
	// Status Filter by log status
	Status *ListLogsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Platform Filter by platform
	Platform *ListLogsParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`

	// Action Filter by action type
	Action *ListLogsParamsAction `form:"action,omitempty" json:"action,omitempty"`

	// Days Number of days to look back (max 7)
	Days *int `form:"days,omitempty" json:"days,omitempty"`

	// Limit Maximum number of logs to return (max 100)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Skip Number of logs to skip (for pagination)
	Skip *int `form:"skip,omitempty" json:"skip,omitempty"`
}

// ListLogsParamsStatus defines parameters for ListLogs.
type ListLogsParamsStatus string

// ListLogsParamsPlatform defines parameters for ListLogs.
type ListLogsParamsPlatform string

// ListLogsParamsAction defines parameters for ListLogs.
type ListLogsParamsAction string

// GetMediaPresignedUrlJSONBody defines parameters for GetMediaPresignedUrl.
type GetMediaPresignedUrlJSONBody struct {
	// ContentType MIME type of the file
	ContentType GetMediaPresignedUrlJSONBodyContentType `json:"contentType"`

	// Filename Name of the file to upload
	Filename string `json:"filename"`

	// Size Optional file size in bytes for pre-validation (max 5GB)
	Size *int `json:"size,omitempty"`
}

// GetMediaPresignedUrlJSONBodyContentType defines parameters for GetMediaPresignedUrl.
type GetMediaPresignedUrlJSONBodyContentType string

// ListPostsParams defines parameters for ListPosts.
type ListPostsParams struct {
	// Page Page number (1-based)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Limit Page size
	Limit         *LimitParam            `form:"limit,omitempty" json:"limit,omitempty"`
	Status        *ListPostsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
	Platform      *string                `form:"platform,omitempty" json:"platform,omitempty"`
	ProfileId     *string                `form:"profileId,omitempty" json:"profileId,omitempty"`
	CreatedBy     *string                `form:"createdBy,omitempty" json:"createdBy,omitempty"`
	DateFrom      *openapi_types.Date    `form:"dateFrom,omitempty" json:"dateFrom,omitempty"`
	DateTo        *openapi_types.Date    `form:"dateTo,omitempty" json:"dateTo,omitempty"`
	IncludeHidden *bool                  `form:"includeHidden,omitempty" json:"includeHidden,omitempty"`
}

// ListPostsParamsStatus defines parameters for ListPosts.
type ListPostsParamsStatus string

// CreatePostJSONBody defines parameters for CreatePost.
type CreatePostJSONBody struct {
	// Content Post caption/text content. Optional when media is attached (images, videos, etc.).
	// Required for text-only posts. Can also be omitted if all platforms have customContent set.
	Content             *string   `json:"content,omitempty"`
	CrosspostingEnabled *bool     `json:"crosspostingEnabled,omitempty"`
	Hashtags            *[]string `json:"hashtags,omitempty"`
	IsDraft             *bool     `json:"isDraft,omitempty"`
	MediaItems          *[]struct {
		Type *CreatePostJSONBodyMediaItemsType `json:"type,omitempty"`
		Url  *string                           `json:"url,omitempty"`
	} `json:"mediaItems,omitempty"`
	Mentions  *[]string               `json:"mentions,omitempty"`
	Metadata  *map[string]interface{} `json:"metadata,omitempty"`
	Platforms *[]struct {
		AccountId     *string `json:"accountId,omitempty"`
		CustomContent *string `json:"customContent,omitempty"`
		CustomMedia   *[]struct {
			Type *CreatePostJSONBodyPlatformsCustomMediaType `json:"type,omitempty"`
			Url  *string                                     `json:"url,omitempty"`
		} `json:"customMedia,omitempty"`
		Platform             *string                                            `json:"platform,omitempty"`
		PlatformSpecificData *CreatePostJSONBody_Platforms_PlatformSpecificData `json:"platformSpecificData,omitempty"`

		// ScheduledFor Optional per-platform scheduled time override. When omitted, the top-level scheduledFor is used.
		ScheduledFor *time.Time `json:"scheduledFor,omitempty"`
	} `json:"platforms,omitempty"`
	PublishNow *bool `json:"publishNow,omitempty"`

	// QueueId Specific queue ID to use when scheduling via queue.
	// Only used when queuedFromProfile is also provided.
	// If omitted, uses the profile's default queue.
	QueueId *string `json:"queueId,omitempty"`

	// QueuedFromProfile Profile ID to schedule via queue.
	//
	// When provided (without `scheduledFor`), the post will be automatically assigned
	// to the next available slot from the profile's queue. The system uses distributed
	// locking to prevent race conditions when multiple posts are scheduled concurrently.
	// Do not call `/v1/queue/next-slot` and then use that time in `scheduledFor`.
	// That bypasses the queue system and can cause duplicate slot assignments.
	QueuedFromProfile *string    `json:"queuedFromProfile,omitempty"`
	ScheduledFor      *time.Time `json:"scheduledFor,omitempty"`

	// Tags Tags/keywords for the post. YouTube-specific constraints:
	// - No count limit; duplicates are automatically removed
	// - Each tag must be ≤ 100 characters
	// - Combined total across all tags ≤ 500 characters (YouTube's limit)
	Tags *[]string `json:"tags,omitempty"`

	// TiktokSettings TikTok platform-specific settings for video/photo posting.
	//
	// **Constraints:**
	// - Photo carousels support up to 35 images.
	// - **Title length limits**:
	//   - Videos: up to 2200 chars (full content used as title)
	//   - Photos: content is automatically truncated to 90 chars for title (hashtags/URLs stripped). Use 'description' field for longer text (up to 4000 chars).
	// - privacyLevel must be chosen from creator_info.privacy_level_options (no defaulting).
	// - allowDuet and allowStitch required for videos; allowComment for all.
	// - contentPreviewConfirmed and expressConsentGiven must be true before posting.
	//
	// **Note:** Both camelCase and snake_case field names are accepted for backwards compatibility.
	// The nested `tiktokSettings` object format is also still supported but deprecated.
	TiktokSettings *TikTokPlatformData `json:"tiktokSettings,omitempty"`
	Timezone       *string             `json:"timezone,omitempty"`
	Title          *string             `json:"title,omitempty"`
}

// CreatePostJSONBodyMediaItemsType defines parameters for CreatePost.
type CreatePostJSONBodyMediaItemsType string

// CreatePostJSONBodyPlatformsCustomMediaType defines parameters for CreatePost.
type CreatePostJSONBodyPlatformsCustomMediaType string

// CreatePostJSONBody_Platforms_PlatformSpecificData defines parameters for CreatePost.
type CreatePostJSONBody_Platforms_PlatformSpecificData struct {
	union json.RawMessage
}

// BulkUploadPostsMultipartBody defines parameters for BulkUploadPosts.
type BulkUploadPostsMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// BulkUploadPostsParams defines parameters for BulkUploadPosts.
type BulkUploadPostsParams struct {
	DryRun *bool `form:"dryRun,omitempty" json:"dryRun,omitempty"`
}

// UpdatePostJSONBody defines parameters for UpdatePost.
type UpdatePostJSONBody map[string]interface{}

// GetPostLogsParams defines parameters for GetPostLogs.
type GetPostLogsParams struct {
	// Limit Maximum number of logs to return (max 100)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListProfilesParams defines parameters for ListProfiles.
type ListProfilesParams struct {
	// IncludeOverLimit When true, includes profiles that exceed the user's plan limit.
	// Over-limit profiles will have `isOverLimit: true` in the response.
	// Useful for managing/deleting profiles after a plan downgrade.
	IncludeOverLimit *bool `form:"includeOverLimit,omitempty" json:"includeOverLimit,omitempty"`
}

// CreateProfileJSONBody defines parameters for CreateProfile.
type CreateProfileJSONBody struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	IsDefault   *bool   `json:"isDefault,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// GetNextQueueSlotParams defines parameters for GetNextQueueSlot.
type GetNextQueueSlotParams struct {
	ProfileId string `form:"profileId" json:"profileId"`

	// QueueId Specific queue ID (optional, defaults to profile's default queue)
	QueueId *string `form:"queueId,omitempty" json:"queueId,omitempty"`
}

// PreviewQueueParams defines parameters for PreviewQueue.
type PreviewQueueParams struct {
	ProfileId string `form:"profileId" json:"profileId"`
	Count     *int   `form:"count,omitempty" json:"count,omitempty"`
}

// DeleteQueueSlotParams defines parameters for DeleteQueueSlot.
type DeleteQueueSlotParams struct {
	ProfileId string `form:"profileId" json:"profileId"`

	// QueueId Queue ID to delete
	QueueId string `form:"queueId" json:"queueId"`
}

// ListQueueSlotsParams defines parameters for ListQueueSlots.
type ListQueueSlotsParams struct {
	// ProfileId Profile ID to get queues for
	ProfileId string `form:"profileId" json:"profileId"`

	// QueueId Specific queue ID to retrieve (optional)
	QueueId *string `form:"queueId,omitempty" json:"queueId,omitempty"`

	// All Set to 'true' to list all queues for the profile
	All *ListQueueSlotsParamsAll `form:"all,omitempty" json:"all,omitempty"`
}

// ListQueueSlotsParamsAll defines parameters for ListQueueSlots.
type ListQueueSlotsParamsAll string

// CreateQueueSlotJSONBody defines parameters for CreateQueueSlot.
type CreateQueueSlotJSONBody struct {
	Active *bool `json:"active,omitempty"`

	// Name Queue name (e.g., Evening Posts)
	Name string `json:"name"`

	// ProfileId Profile ID
	ProfileId string      `json:"profileId"`
	Slots     []QueueSlot `json:"slots"`

	// Timezone IANA timezone
	Timezone string `json:"timezone"`
}

// UpdateQueueSlotJSONBody defines parameters for UpdateQueueSlot.
type UpdateQueueSlotJSONBody struct {
	Active *bool `json:"active,omitempty"`

	// Name Queue name
	Name      *string `json:"name,omitempty"`
	ProfileId string  `json:"profileId"`

	// QueueId Queue ID to update (optional)
	QueueId *string `json:"queueId,omitempty"`

	// ReshuffleExisting Whether to reschedule existing queued posts to match new slots
	ReshuffleExisting *bool `json:"reshuffleExisting,omitempty"`

	// SetAsDefault Make this queue the default
	SetAsDefault *bool       `json:"setAsDefault,omitempty"`
	Slots        []QueueSlot `json:"slots"`
	Timezone     string      `json:"timezone"`
}

// GetRedditFeedParams defines parameters for GetRedditFeed.
type GetRedditFeedParams struct {
	AccountId string                   `form:"accountId" json:"accountId"`
	Subreddit *string                  `form:"subreddit,omitempty" json:"subreddit,omitempty"`
	Sort      *GetRedditFeedParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
	Limit     *int                     `form:"limit,omitempty" json:"limit,omitempty"`
	After     *string                  `form:"after,omitempty" json:"after,omitempty"`
	T         *GetRedditFeedParamsT    `form:"t,omitempty" json:"t,omitempty"`
}

// GetRedditFeedParamsSort defines parameters for GetRedditFeed.
type GetRedditFeedParamsSort string

// GetRedditFeedParamsT defines parameters for GetRedditFeed.
type GetRedditFeedParamsT string

// SearchRedditParams defines parameters for SearchReddit.
type SearchRedditParams struct {
	AccountId  string                        `form:"accountId" json:"accountId"`
	Subreddit  *string                       `form:"subreddit,omitempty" json:"subreddit,omitempty"`
	Q          string                        `form:"q" json:"q"`
	RestrictSr *SearchRedditParamsRestrictSr `form:"restrict_sr,omitempty" json:"restrict_sr,omitempty"`
	Sort       *SearchRedditParamsSort       `form:"sort,omitempty" json:"sort,omitempty"`
	Limit      *int                          `form:"limit,omitempty" json:"limit,omitempty"`
	After      *string                       `form:"after,omitempty" json:"after,omitempty"`
}

// SearchRedditParamsRestrictSr defines parameters for SearchReddit.
type SearchRedditParamsRestrictSr string

// SearchRedditParamsSort defines parameters for SearchReddit.
type SearchRedditParamsSort string

// DownloadBlueskyMediaParams defines parameters for DownloadBlueskyMedia.
type DownloadBlueskyMediaParams struct {
	// Url Bluesky post URL
	Url string `form:"url" json:"url"`
}

// DownloadFacebookVideoParams defines parameters for DownloadFacebookVideo.
type DownloadFacebookVideoParams struct {
	// Url Facebook video or reel URL
	Url string `form:"url" json:"url"`
}

// DownloadInstagramMediaParams defines parameters for DownloadInstagramMedia.
type DownloadInstagramMediaParams struct {
	// Url Instagram reel or post URL
	Url string `form:"url" json:"url"`
}

// CheckInstagramHashtagsJSONBody defines parameters for CheckInstagramHashtags.
type CheckInstagramHashtagsJSONBody struct {
	Hashtags []string `json:"hashtags"`
}

// DownloadLinkedInVideoParams defines parameters for DownloadLinkedInVideo.
type DownloadLinkedInVideoParams struct {
	// Url LinkedIn post URL
	Url string `form:"url" json:"url"`
}

// DownloadTikTokVideoParams defines parameters for DownloadTikTokVideo.
type DownloadTikTokVideoParams struct {
	// Url TikTok video URL or ID
	Url string `form:"url" json:"url"`

	// Action 'formats' to list available formats
	Action *DownloadTikTokVideoParamsAction `form:"action,omitempty" json:"action,omitempty"`

	// FormatId Specific format ID (0 = no watermark, etc.)
	FormatId *string `form:"formatId,omitempty" json:"formatId,omitempty"`
}

// DownloadTikTokVideoParamsAction defines parameters for DownloadTikTokVideo.
type DownloadTikTokVideoParamsAction string

// DownloadTwitterMediaParams defines parameters for DownloadTwitterMedia.
type DownloadTwitterMediaParams struct {
	// Url Twitter/X post URL
	Url      string                            `form:"url" json:"url"`
	Action   *DownloadTwitterMediaParamsAction `form:"action,omitempty" json:"action,omitempty"`
	FormatId *string                           `form:"formatId,omitempty" json:"formatId,omitempty"`
}

// DownloadTwitterMediaParamsAction defines parameters for DownloadTwitterMedia.
type DownloadTwitterMediaParamsAction string

// DownloadYouTubeVideoParams defines parameters for DownloadYouTubeVideo.
type DownloadYouTubeVideoParams struct {
	// Url YouTube video URL or video ID
	Url string `form:"url" json:"url"`

	// Action Action to perform: 'download' returns download URL, 'formats' lists available formats
	Action *DownloadYouTubeVideoParamsAction `form:"action,omitempty" json:"action,omitempty"`

	// Format Desired format (when action=download)
	Format *DownloadYouTubeVideoParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Quality Desired quality (when action=download)
	Quality *DownloadYouTubeVideoParamsQuality `form:"quality,omitempty" json:"quality,omitempty"`

	// FormatId Specific format ID from formats list
	FormatId *string `form:"formatId,omitempty" json:"formatId,omitempty"`
}

// DownloadYouTubeVideoParamsAction defines parameters for DownloadYouTubeVideo.
type DownloadYouTubeVideoParamsAction string

// DownloadYouTubeVideoParamsFormat defines parameters for DownloadYouTubeVideo.
type DownloadYouTubeVideoParamsFormat string

// DownloadYouTubeVideoParamsQuality defines parameters for DownloadYouTubeVideo.
type DownloadYouTubeVideoParamsQuality string

// GetYouTubeTranscriptParams defines parameters for GetYouTubeTranscript.
type GetYouTubeTranscriptParams struct {
	// Url YouTube video URL or video ID
	Url string `form:"url" json:"url"`

	// Lang Language code for transcript
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`
}

// GetWebhookLogsParams defines parameters for GetWebhookLogs.
type GetWebhookLogsParams struct {
	// Limit Maximum number of logs to return (max 100)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Filter by delivery status
	Status *GetWebhookLogsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Event Filter by event type
	Event *GetWebhookLogsParamsEvent `form:"event,omitempty" json:"event,omitempty"`

	// WebhookId Filter by webhook ID
	WebhookId *string `form:"webhookId,omitempty" json:"webhookId,omitempty"`
}

// GetWebhookLogsParamsStatus defines parameters for GetWebhookLogs.
type GetWebhookLogsParamsStatus string

// GetWebhookLogsParamsEvent defines parameters for GetWebhookLogs.
type GetWebhookLogsParamsEvent string

// DeleteWebhookSettingsParams defines parameters for DeleteWebhookSettings.
type DeleteWebhookSettingsParams struct {
	// Id Webhook ID to delete
	Id string `form:"id" json:"id"`
}

// CreateWebhookSettingsJSONBody defines parameters for CreateWebhookSettings.
type CreateWebhookSettingsJSONBody struct {
	// CustomHeaders Custom headers to include in webhook requests
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// Events Events to subscribe to
	Events *[]CreateWebhookSettingsJSONBodyEvents `json:"events,omitempty"`

	// IsActive Enable or disable webhook delivery
	IsActive *bool `json:"isActive,omitempty"`

	// Name Webhook name (max 50 characters)
	Name *string `json:"name,omitempty"`

	// Secret Secret key for HMAC-SHA256 signature verification
	Secret *string `json:"secret,omitempty"`

	// Url Webhook endpoint URL (must be HTTPS in production)
	Url *string `json:"url,omitempty"`
}

// CreateWebhookSettingsJSONBodyEvents defines parameters for CreateWebhookSettings.
type CreateWebhookSettingsJSONBodyEvents string

// UpdateWebhookSettingsJSONBody defines parameters for UpdateWebhookSettings.
type UpdateWebhookSettingsJSONBody struct {
	// UnderscoreId Webhook ID to update (required)
	UnderscoreId string `json:"_id"`

	// CustomHeaders Custom headers to include in webhook requests
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// Events Events to subscribe to
	Events *[]UpdateWebhookSettingsJSONBodyEvents `json:"events,omitempty"`

	// IsActive Enable or disable webhook delivery
	IsActive *bool `json:"isActive,omitempty"`

	// Name Webhook name (max 50 characters)
	Name *string `json:"name,omitempty"`

	// Secret Secret key for HMAC-SHA256 signature verification
	Secret *string `json:"secret,omitempty"`

	// Url Webhook endpoint URL (must be HTTPS in production)
	Url *string `json:"url,omitempty"`
}

// UpdateWebhookSettingsJSONBodyEvents defines parameters for UpdateWebhookSettings.
type UpdateWebhookSettingsJSONBodyEvents string

// TestWebhookJSONBody defines parameters for TestWebhook.
type TestWebhookJSONBody struct {
	// WebhookId ID of the webhook to test
	WebhookId string `json:"webhookId"`
}

// CreateAccountGroupJSONRequestBody defines body for CreateAccountGroup for application/json ContentType.
type CreateAccountGroupJSONRequestBody CreateAccountGroupJSONBody

// UpdateAccountGroupJSONRequestBody defines body for UpdateAccountGroup for application/json ContentType.
type UpdateAccountGroupJSONRequestBody UpdateAccountGroupJSONBody

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody UpdateAccountJSONBody

// UpdateFacebookPageJSONRequestBody defines body for UpdateFacebookPage for application/json ContentType.
type UpdateFacebookPageJSONRequestBody UpdateFacebookPageJSONBody

// UpdateGoogleBusinessAttributesJSONRequestBody defines body for UpdateGoogleBusinessAttributes for application/json ContentType.
type UpdateGoogleBusinessAttributesJSONRequestBody UpdateGoogleBusinessAttributesJSONBody

// UpdateGoogleBusinessFoodMenusJSONRequestBody defines body for UpdateGoogleBusinessFoodMenus for application/json ContentType.
type UpdateGoogleBusinessFoodMenusJSONRequestBody UpdateGoogleBusinessFoodMenusJSONBody

// UpdateGoogleBusinessLocationDetailsJSONRequestBody defines body for UpdateGoogleBusinessLocationDetails for application/json ContentType.
type UpdateGoogleBusinessLocationDetailsJSONRequestBody UpdateGoogleBusinessLocationDetailsJSONBody

// UpdateGmbLocationJSONRequestBody defines body for UpdateGmbLocation for application/json ContentType.
type UpdateGmbLocationJSONRequestBody UpdateGmbLocationJSONBody

// CreateGoogleBusinessMediaJSONRequestBody defines body for CreateGoogleBusinessMedia for application/json ContentType.
type CreateGoogleBusinessMediaJSONRequestBody CreateGoogleBusinessMediaJSONBody

// CreateGoogleBusinessPlaceActionJSONRequestBody defines body for CreateGoogleBusinessPlaceAction for application/json ContentType.
type CreateGoogleBusinessPlaceActionJSONRequestBody CreateGoogleBusinessPlaceActionJSONBody

// UpdateLinkedInOrganizationJSONRequestBody defines body for UpdateLinkedInOrganization for application/json ContentType.
type UpdateLinkedInOrganizationJSONRequestBody UpdateLinkedInOrganizationJSONBody

// UpdatePinterestBoardsJSONRequestBody defines body for UpdatePinterestBoards for application/json ContentType.
type UpdatePinterestBoardsJSONRequestBody UpdatePinterestBoardsJSONBody

// UpdateRedditSubredditsJSONRequestBody defines body for UpdateRedditSubreddits for application/json ContentType.
type UpdateRedditSubredditsJSONRequestBody UpdateRedditSubredditsJSONBody

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody CreateApiKeyJSONBody

// ConnectBlueskyCredentialsJSONRequestBody defines body for ConnectBlueskyCredentials for application/json ContentType.
type ConnectBlueskyCredentialsJSONRequestBody ConnectBlueskyCredentialsJSONBody

// SelectFacebookPageJSONRequestBody defines body for SelectFacebookPage for application/json ContentType.
type SelectFacebookPageJSONRequestBody SelectFacebookPageJSONBody

// SelectGoogleBusinessLocationJSONRequestBody defines body for SelectGoogleBusinessLocation for application/json ContentType.
type SelectGoogleBusinessLocationJSONRequestBody SelectGoogleBusinessLocationJSONBody

// SelectLinkedInOrganizationJSONRequestBody defines body for SelectLinkedInOrganization for application/json ContentType.
type SelectLinkedInOrganizationJSONRequestBody SelectLinkedInOrganizationJSONBody

// SelectPinterestBoardJSONRequestBody defines body for SelectPinterestBoard for application/json ContentType.
type SelectPinterestBoardJSONRequestBody SelectPinterestBoardJSONBody

// SelectSnapchatProfileJSONRequestBody defines body for SelectSnapchatProfile for application/json ContentType.
type SelectSnapchatProfileJSONRequestBody SelectSnapchatProfileJSONBody

// InitiateTelegramConnectJSONRequestBody defines body for InitiateTelegramConnect for application/json ContentType.
type InitiateTelegramConnectJSONRequestBody InitiateTelegramConnectJSONBody

// HandleOAuthCallbackJSONRequestBody defines body for HandleOAuthCallback for application/json ContentType.
type HandleOAuthCallbackJSONRequestBody HandleOAuthCallbackJSONBody

// ReplyToInboxPostJSONRequestBody defines body for ReplyToInboxPost for application/json ContentType.
type ReplyToInboxPostJSONRequestBody ReplyToInboxPostJSONBody

// HideInboxCommentJSONRequestBody defines body for HideInboxComment for application/json ContentType.
type HideInboxCommentJSONRequestBody HideInboxCommentJSONBody

// LikeInboxCommentJSONRequestBody defines body for LikeInboxComment for application/json ContentType.
type LikeInboxCommentJSONRequestBody LikeInboxCommentJSONBody

// SendPrivateReplyToCommentJSONRequestBody defines body for SendPrivateReplyToComment for application/json ContentType.
type SendPrivateReplyToCommentJSONRequestBody SendPrivateReplyToCommentJSONBody

// UpdateInboxConversationJSONRequestBody defines body for UpdateInboxConversation for application/json ContentType.
type UpdateInboxConversationJSONRequestBody UpdateInboxConversationJSONBody

// SendInboxMessageJSONRequestBody defines body for SendInboxMessage for application/json ContentType.
type SendInboxMessageJSONRequestBody SendInboxMessageJSONBody

// SendInboxMessageMultipartRequestBody defines body for SendInboxMessage for multipart/form-data ContentType.
type SendInboxMessageMultipartRequestBody SendInboxMessageMultipartBody

// DeleteInboxReviewReplyJSONRequestBody defines body for DeleteInboxReviewReply for application/json ContentType.
type DeleteInboxReviewReplyJSONRequestBody DeleteInboxReviewReplyJSONBody

// ReplyToInboxReviewJSONRequestBody defines body for ReplyToInboxReview for application/json ContentType.
type ReplyToInboxReviewJSONRequestBody ReplyToInboxReviewJSONBody

// CreateInviteTokenJSONRequestBody defines body for CreateInviteToken for application/json ContentType.
type CreateInviteTokenJSONRequestBody CreateInviteTokenJSONBody

// GetMediaPresignedUrlJSONRequestBody defines body for GetMediaPresignedUrl for application/json ContentType.
type GetMediaPresignedUrlJSONRequestBody GetMediaPresignedUrlJSONBody

// CreatePostJSONRequestBody defines body for CreatePost for application/json ContentType.
type CreatePostJSONRequestBody CreatePostJSONBody

// BulkUploadPostsMultipartRequestBody defines body for BulkUploadPosts for multipart/form-data ContentType.
type BulkUploadPostsMultipartRequestBody BulkUploadPostsMultipartBody

// UpdatePostJSONRequestBody defines body for UpdatePost for application/json ContentType.
type UpdatePostJSONRequestBody UpdatePostJSONBody

// CreateProfileJSONRequestBody defines body for CreateProfile for application/json ContentType.
type CreateProfileJSONRequestBody CreateProfileJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// CreateQueueSlotJSONRequestBody defines body for CreateQueueSlot for application/json ContentType.
type CreateQueueSlotJSONRequestBody CreateQueueSlotJSONBody

// UpdateQueueSlotJSONRequestBody defines body for UpdateQueueSlot for application/json ContentType.
type UpdateQueueSlotJSONRequestBody UpdateQueueSlotJSONBody

// CheckInstagramHashtagsJSONRequestBody defines body for CheckInstagramHashtags for application/json ContentType.
type CheckInstagramHashtagsJSONRequestBody CheckInstagramHashtagsJSONBody

// CreateWebhookSettingsJSONRequestBody defines body for CreateWebhookSettings for application/json ContentType.
type CreateWebhookSettingsJSONRequestBody CreateWebhookSettingsJSONBody

// UpdateWebhookSettingsJSONRequestBody defines body for UpdateWebhookSettings for application/json ContentType.
type UpdateWebhookSettingsJSONRequestBody UpdateWebhookSettingsJSONBody

// TestWebhookJSONRequestBody defines body for TestWebhook for application/json ContentType.
type TestWebhookJSONRequestBody TestWebhookJSONBody

// Getter for additional properties for PlatformTarget_PlatformSpecificData. Returns the specified
// element and whether it was found
func (a PlatformTarget_PlatformSpecificData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PlatformTarget_PlatformSpecificData
func (a *PlatformTarget_PlatformSpecificData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// AsAccountWithFollowerStatsProfileId0 returns the union data inside the AccountWithFollowerStats_ProfileId as a AccountWithFollowerStatsProfileId0
func (t AccountWithFollowerStats_ProfileId) AsAccountWithFollowerStatsProfileId0() (AccountWithFollowerStatsProfileId0, error) {
	var body AccountWithFollowerStatsProfileId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountWithFollowerStatsProfileId0 overwrites any union data inside the AccountWithFollowerStats_ProfileId as the provided AccountWithFollowerStatsProfileId0
func (t *AccountWithFollowerStats_ProfileId) FromAccountWithFollowerStatsProfileId0(v AccountWithFollowerStatsProfileId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountWithFollowerStatsProfileId0 performs a merge with any union data inside the AccountWithFollowerStats_ProfileId, using the provided AccountWithFollowerStatsProfileId0
func (t *AccountWithFollowerStats_ProfileId) MergeAccountWithFollowerStatsProfileId0(v AccountWithFollowerStatsProfileId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProfile returns the union data inside the AccountWithFollowerStats_ProfileId as a Profile
func (t AccountWithFollowerStats_ProfileId) AsProfile() (Profile, error) {
	var body Profile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProfile overwrites any union data inside the AccountWithFollowerStats_ProfileId as the provided Profile
func (t *AccountWithFollowerStats_ProfileId) FromProfile(v Profile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProfile performs a merge with any union data inside the AccountWithFollowerStats_ProfileId, using the provided Profile
func (t *AccountWithFollowerStats_ProfileId) MergeProfile(v Profile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AccountWithFollowerStats_ProfileId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AccountWithFollowerStats_ProfileId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformTargetAccountId0 returns the union data inside the PlatformTarget_AccountId as a PlatformTargetAccountId0
func (t PlatformTarget_AccountId) AsPlatformTargetAccountId0() (PlatformTargetAccountId0, error) {
	var body PlatformTargetAccountId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTargetAccountId0 overwrites any union data inside the PlatformTarget_AccountId as the provided PlatformTargetAccountId0
func (t *PlatformTarget_AccountId) FromPlatformTargetAccountId0(v PlatformTargetAccountId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTargetAccountId0 performs a merge with any union data inside the PlatformTarget_AccountId, using the provided PlatformTargetAccountId0
func (t *PlatformTarget_AccountId) MergePlatformTargetAccountId0(v PlatformTargetAccountId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSocialAccount returns the union data inside the PlatformTarget_AccountId as a SocialAccount
func (t PlatformTarget_AccountId) AsSocialAccount() (SocialAccount, error) {
	var body SocialAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSocialAccount overwrites any union data inside the PlatformTarget_AccountId as the provided SocialAccount
func (t *PlatformTarget_AccountId) FromSocialAccount(v SocialAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSocialAccount performs a merge with any union data inside the PlatformTarget_AccountId, using the provided SocialAccount
func (t *PlatformTarget_AccountId) MergeSocialAccount(v SocialAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformTarget_AccountId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformTarget_AccountId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTwitterPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a TwitterPlatformData
func (t PlatformTarget_PlatformSpecificData) AsTwitterPlatformData() (TwitterPlatformData, error) {
	var body TwitterPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTwitterPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided TwitterPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromTwitterPlatformData(v TwitterPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTwitterPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided TwitterPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeTwitterPlatformData(v TwitterPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThreadsPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a ThreadsPlatformData
func (t PlatformTarget_PlatformSpecificData) AsThreadsPlatformData() (ThreadsPlatformData, error) {
	var body ThreadsPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThreadsPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided ThreadsPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromThreadsPlatformData(v ThreadsPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThreadsPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided ThreadsPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeThreadsPlatformData(v ThreadsPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFacebookPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a FacebookPlatformData
func (t PlatformTarget_PlatformSpecificData) AsFacebookPlatformData() (FacebookPlatformData, error) {
	var body FacebookPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFacebookPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided FacebookPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromFacebookPlatformData(v FacebookPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFacebookPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided FacebookPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeFacebookPlatformData(v FacebookPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstagramPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a InstagramPlatformData
func (t PlatformTarget_PlatformSpecificData) AsInstagramPlatformData() (InstagramPlatformData, error) {
	var body InstagramPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstagramPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided InstagramPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromInstagramPlatformData(v InstagramPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstagramPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided InstagramPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeInstagramPlatformData(v InstagramPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkedInPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a LinkedInPlatformData
func (t PlatformTarget_PlatformSpecificData) AsLinkedInPlatformData() (LinkedInPlatformData, error) {
	var body LinkedInPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkedInPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided LinkedInPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromLinkedInPlatformData(v LinkedInPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkedInPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided LinkedInPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeLinkedInPlatformData(v LinkedInPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPinterestPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a PinterestPlatformData
func (t PlatformTarget_PlatformSpecificData) AsPinterestPlatformData() (PinterestPlatformData, error) {
	var body PinterestPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPinterestPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided PinterestPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromPinterestPlatformData(v PinterestPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePinterestPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided PinterestPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergePinterestPlatformData(v PinterestPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsYouTubePlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a YouTubePlatformData
func (t PlatformTarget_PlatformSpecificData) AsYouTubePlatformData() (YouTubePlatformData, error) {
	var body YouTubePlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromYouTubePlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided YouTubePlatformData
func (t *PlatformTarget_PlatformSpecificData) FromYouTubePlatformData(v YouTubePlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeYouTubePlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided YouTubePlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeYouTubePlatformData(v YouTubePlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoogleBusinessPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a GoogleBusinessPlatformData
func (t PlatformTarget_PlatformSpecificData) AsGoogleBusinessPlatformData() (GoogleBusinessPlatformData, error) {
	var body GoogleBusinessPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleBusinessPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided GoogleBusinessPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromGoogleBusinessPlatformData(v GoogleBusinessPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleBusinessPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided GoogleBusinessPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeGoogleBusinessPlatformData(v GoogleBusinessPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTikTokPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a TikTokPlatformData
func (t PlatformTarget_PlatformSpecificData) AsTikTokPlatformData() (TikTokPlatformData, error) {
	var body TikTokPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTikTokPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided TikTokPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromTikTokPlatformData(v TikTokPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTikTokPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided TikTokPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeTikTokPlatformData(v TikTokPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTelegramPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a TelegramPlatformData
func (t PlatformTarget_PlatformSpecificData) AsTelegramPlatformData() (TelegramPlatformData, error) {
	var body TelegramPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTelegramPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided TelegramPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromTelegramPlatformData(v TelegramPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTelegramPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided TelegramPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeTelegramPlatformData(v TelegramPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnapchatPlatformData returns the union data inside the PlatformTarget_PlatformSpecificData as a SnapchatPlatformData
func (t PlatformTarget_PlatformSpecificData) AsSnapchatPlatformData() (SnapchatPlatformData, error) {
	var body SnapchatPlatformData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapchatPlatformData overwrites any union data inside the PlatformTarget_PlatformSpecificData as the provided SnapchatPlatformData
func (t *PlatformTarget_PlatformSpecificData) FromSnapchatPlatformData(v SnapchatPlatformData) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapchatPlatformData performs a merge with any union data inside the PlatformTarget_PlatformSpecificData, using the provided SnapchatPlatformData
func (t *PlatformTarget_PlatformSpecificData) MergeSnapchatPlatformData(v SnapchatPlatformData) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostUserId0 returns the union data inside the Post_UserId as a PostUserId0
func (t Post_UserId) AsPostUserId0() (PostUserId0, error) {
	var body PostUserId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostUserId0 overwrites any union data inside the Post_UserId as the provided PostUserId0
func (t *Post_UserId) FromPostUserId0(v PostUserId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostUserId0 performs a merge with any union data inside the Post_UserId, using the provided PostUserId0
func (t *Post_UserId) MergePostUserId0(v PostUserId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUser returns the union data inside the Post_UserId as a User
func (t Post_UserId) AsUser() (User, error) {
	var body User
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUser overwrites any union data inside the Post_UserId as the provided User
func (t *Post_UserId) FromUser(v User) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUser performs a merge with any union data inside the Post_UserId, using the provided User
func (t *Post_UserId) MergeUser(v User) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Post_UserId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Post_UserId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPostLogPostId0 returns the union data inside the PostLog_PostId as a PostLogPostId0
func (t PostLog_PostId) AsPostLogPostId0() (PostLogPostId0, error) {
	var body PostLogPostId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostLogPostId0 overwrites any union data inside the PostLog_PostId as the provided PostLogPostId0
func (t *PostLog_PostId) FromPostLogPostId0(v PostLogPostId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostLogPostId0 performs a merge with any union data inside the PostLog_PostId, using the provided PostLogPostId0
func (t *PostLog_PostId) MergePostLogPostId0(v PostLogPostId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostLogPostId1 returns the union data inside the PostLog_PostId as a PostLogPostId1
func (t PostLog_PostId) AsPostLogPostId1() (PostLogPostId1, error) {
	var body PostLogPostId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostLogPostId1 overwrites any union data inside the PostLog_PostId as the provided PostLogPostId1
func (t *PostLog_PostId) FromPostLogPostId1(v PostLogPostId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostLogPostId1 performs a merge with any union data inside the PostLog_PostId, using the provided PostLogPostId1
func (t *PostLog_PostId) MergePostLogPostId1(v PostLogPostId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PostLog_PostId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PostLog_PostId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSocialAccountProfileId0 returns the union data inside the SocialAccount_ProfileId as a SocialAccountProfileId0
func (t SocialAccount_ProfileId) AsSocialAccountProfileId0() (SocialAccountProfileId0, error) {
	var body SocialAccountProfileId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSocialAccountProfileId0 overwrites any union data inside the SocialAccount_ProfileId as the provided SocialAccountProfileId0
func (t *SocialAccount_ProfileId) FromSocialAccountProfileId0(v SocialAccountProfileId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSocialAccountProfileId0 performs a merge with any union data inside the SocialAccount_ProfileId, using the provided SocialAccountProfileId0
func (t *SocialAccount_ProfileId) MergeSocialAccountProfileId0(v SocialAccountProfileId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProfile returns the union data inside the SocialAccount_ProfileId as a Profile
func (t SocialAccount_ProfileId) AsProfile() (Profile, error) {
	var body Profile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProfile overwrites any union data inside the SocialAccount_ProfileId as the provided Profile
func (t *SocialAccount_ProfileId) FromProfile(v Profile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProfile performs a merge with any union data inside the SocialAccount_ProfileId, using the provided Profile
func (t *SocialAccount_ProfileId) MergeProfile(v Profile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SocialAccount_ProfileId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SocialAccount_ProfileId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// Override default JSON handling for PlatformTarget_PlatformSpecificData to handle AdditionalProperties and union
func (a *PlatformTarget_PlatformSpecificData) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PlatformTarget_PlatformSpecificData to handle AdditionalProperties and union
func (a PlatformTarget_PlatformSpecificData) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccountGroups request
	ListAccountGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccountGroupWithBody request with any body
	CreateAccountGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccountGroup(ctx context.Context, body CreateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccountGroup request
	DeleteAccountGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountGroupWithBody request with any body
	UpdateAccountGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccountGroup(ctx context.Context, groupId string, body UpdateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowerStats request
	GetFollowerStats(ctx context.Context, params *GetFollowerStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccountsHealth request
	GetAllAccountsHealth(ctx context.Context, params *GetAllAccountsHealthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccount request
	DeleteAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountWithBody request with any body
	UpdateAccountWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccount(ctx context.Context, accountId string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFacebookPages request
	GetFacebookPages(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFacebookPageWithBody request with any body
	UpdateFacebookPageWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFacebookPage(ctx context.Context, accountId string, body UpdateFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoogleBusinessAttributes request
	GetGoogleBusinessAttributes(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGoogleBusinessAttributesWithBody request with any body
	UpdateGoogleBusinessAttributesWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGoogleBusinessAttributes(ctx context.Context, accountId string, body UpdateGoogleBusinessAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoogleBusinessFoodMenus request
	GetGoogleBusinessFoodMenus(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGoogleBusinessFoodMenusWithBody request with any body
	UpdateGoogleBusinessFoodMenusWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGoogleBusinessFoodMenus(ctx context.Context, accountId string, body UpdateGoogleBusinessFoodMenusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoogleBusinessLocationDetails request
	GetGoogleBusinessLocationDetails(ctx context.Context, accountId string, params *GetGoogleBusinessLocationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGoogleBusinessLocationDetailsWithBody request with any body
	UpdateGoogleBusinessLocationDetailsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGoogleBusinessLocationDetails(ctx context.Context, accountId string, body UpdateGoogleBusinessLocationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGmbLocations request
	GetGmbLocations(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGmbLocationWithBody request with any body
	UpdateGmbLocationWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGmbLocation(ctx context.Context, accountId string, body UpdateGmbLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGoogleBusinessMedia request
	DeleteGoogleBusinessMedia(ctx context.Context, accountId string, params *DeleteGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGoogleBusinessMedia request
	ListGoogleBusinessMedia(ctx context.Context, accountId string, params *ListGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGoogleBusinessMediaWithBody request with any body
	CreateGoogleBusinessMediaWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGoogleBusinessMedia(ctx context.Context, accountId string, body CreateGoogleBusinessMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGoogleBusinessPlaceAction request
	DeleteGoogleBusinessPlaceAction(ctx context.Context, accountId string, params *DeleteGoogleBusinessPlaceActionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGoogleBusinessPlaceActions request
	ListGoogleBusinessPlaceActions(ctx context.Context, accountId string, params *ListGoogleBusinessPlaceActionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGoogleBusinessPlaceActionWithBody request with any body
	CreateGoogleBusinessPlaceActionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGoogleBusinessPlaceAction(ctx context.Context, accountId string, body CreateGoogleBusinessPlaceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoogleBusinessReviews request
	GetGoogleBusinessReviews(ctx context.Context, accountId string, params *GetGoogleBusinessReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountHealth request
	GetAccountHealth(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkedInAggregateAnalytics request
	GetLinkedInAggregateAnalytics(ctx context.Context, accountId string, params *GetLinkedInAggregateAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkedInMentions request
	GetLinkedInMentions(ctx context.Context, accountId string, params *GetLinkedInMentionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLinkedInOrganizationWithBody request with any body
	UpdateLinkedInOrganizationWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLinkedInOrganization(ctx context.Context, accountId string, body UpdateLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkedInOrganizations request
	GetLinkedInOrganizations(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkedInPostAnalytics request
	GetLinkedInPostAnalytics(ctx context.Context, accountId string, params *GetLinkedInPostAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPinterestBoards request
	GetPinterestBoards(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePinterestBoardsWithBody request with any body
	UpdatePinterestBoardsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePinterestBoards(ctx context.Context, accountId string, body UpdatePinterestBoardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRedditSubreddits request
	GetRedditSubreddits(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRedditSubredditsWithBody request with any body
	UpdateRedditSubredditsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRedditSubreddits(ctx context.Context, accountId string, body UpdateRedditSubredditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalytics request
	GetAnalytics(ctx context.Context, params *GetAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetYouTubeDailyViews request
	GetYouTubeDailyViews(ctx context.Context, params *GetYouTubeDailyViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeys request
	ListApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyWithBody request with any body
	CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKey request
	DeleteApiKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectBlueskyCredentialsWithBody request with any body
	ConnectBlueskyCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectBlueskyCredentials(ctx context.Context, body ConnectBlueskyCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFacebookPages request
	ListFacebookPages(ctx context.Context, params *ListFacebookPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectFacebookPageWithBody request with any body
	SelectFacebookPageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectFacebookPage(ctx context.Context, body SelectFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGoogleBusinessLocations request
	ListGoogleBusinessLocations(ctx context.Context, params *ListGoogleBusinessLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectGoogleBusinessLocationWithBody request with any body
	SelectGoogleBusinessLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectGoogleBusinessLocation(ctx context.Context, body SelectGoogleBusinessLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLinkedInOrganizations request
	ListLinkedInOrganizations(ctx context.Context, params *ListLinkedInOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectLinkedInOrganizationWithBody request with any body
	SelectLinkedInOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectLinkedInOrganization(ctx context.Context, body SelectLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingOAuthData request
	GetPendingOAuthData(ctx context.Context, params *GetPendingOAuthDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPinterestBoardsForSelection request
	ListPinterestBoardsForSelection(ctx context.Context, params *ListPinterestBoardsForSelectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectPinterestBoardWithBody request with any body
	SelectPinterestBoardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectPinterestBoard(ctx context.Context, body SelectPinterestBoardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSnapchatProfiles request
	ListSnapchatProfiles(ctx context.Context, params *ListSnapchatProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectSnapchatProfileWithBody request with any body
	SelectSnapchatProfileWithBody(ctx context.Context, params *SelectSnapchatProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectSnapchatProfile(ctx context.Context, params *SelectSnapchatProfileParams, body SelectSnapchatProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTelegramConnectStatus request
	GetTelegramConnectStatus(ctx context.Context, params *GetTelegramConnectStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteTelegramConnect request
	CompleteTelegramConnect(ctx context.Context, params *CompleteTelegramConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateTelegramConnectWithBody request with any body
	InitiateTelegramConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InitiateTelegramConnect(ctx context.Context, body InitiateTelegramConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectUrl request
	GetConnectUrl(ctx context.Context, platform GetConnectUrlParamsPlatform, params *GetConnectUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HandleOAuthCallbackWithBody request with any body
	HandleOAuthCallbackWithBody(ctx context.Context, platform string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HandleOAuthCallback(ctx context.Context, platform string, body HandleOAuthCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInboxComments request
	ListInboxComments(ctx context.Context, params *ListInboxCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInboxComment request
	DeleteInboxComment(ctx context.Context, postId string, params *DeleteInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInboxPostComments request
	GetInboxPostComments(ctx context.Context, postId string, params *GetInboxPostCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplyToInboxPostWithBody request with any body
	ReplyToInboxPostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplyToInboxPost(ctx context.Context, postId string, body ReplyToInboxPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnhideInboxComment request
	UnhideInboxComment(ctx context.Context, postId string, commentId string, params *UnhideInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HideInboxCommentWithBody request with any body
	HideInboxCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HideInboxComment(ctx context.Context, postId string, commentId string, body HideInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlikeInboxComment request
	UnlikeInboxComment(ctx context.Context, postId string, commentId string, params *UnlikeInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LikeInboxCommentWithBody request with any body
	LikeInboxCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LikeInboxComment(ctx context.Context, postId string, commentId string, body LikeInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPrivateReplyToCommentWithBody request with any body
	SendPrivateReplyToCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendPrivateReplyToComment(ctx context.Context, postId string, commentId string, body SendPrivateReplyToCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInboxConversations request
	ListInboxConversations(ctx context.Context, params *ListInboxConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInboxConversation request
	GetInboxConversation(ctx context.Context, conversationId string, params *GetInboxConversationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInboxConversationWithBody request with any body
	UpdateInboxConversationWithBody(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInboxConversation(ctx context.Context, conversationId string, body UpdateInboxConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInboxConversationMessages request
	GetInboxConversationMessages(ctx context.Context, conversationId string, params *GetInboxConversationMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendInboxMessageWithBody request with any body
	SendInboxMessageWithBody(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendInboxMessage(ctx context.Context, conversationId string, body SendInboxMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInboxReviews request
	ListInboxReviews(ctx context.Context, params *ListInboxReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInboxReviewReplyWithBody request with any body
	DeleteInboxReviewReplyWithBody(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteInboxReviewReply(ctx context.Context, reviewId string, body DeleteInboxReviewReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplyToInboxReviewWithBody request with any body
	ReplyToInboxReviewWithBody(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplyToInboxReview(ctx context.Context, reviewId string, body ReplyToInboxReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInviteTokenWithBody request with any body
	CreateInviteTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInviteToken(ctx context.Context, body CreateInviteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogs request
	ListLogs(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLog request
	GetLog(ctx context.Context, logId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaPresignedUrlWithBody request with any body
	GetMediaPresignedUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMediaPresignedUrl(ctx context.Context, body GetMediaPresignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPosts request
	ListPosts(ctx context.Context, params *ListPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostWithBody request with any body
	CreatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePost(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUploadPostsWithBody request with any body
	BulkUploadPostsWithBody(ctx context.Context, params *BulkUploadPostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePost request
	DeletePost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPost request
	GetPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePostWithBody request with any body
	UpdatePostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePost(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostLogs request
	GetPostLogs(ctx context.Context, postId string, params *GetPostLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryPost request
	RetryPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProfiles request
	ListProfiles(ctx context.Context, params *ListProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProfileWithBody request with any body
	CreateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProfile(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProfile request
	DeleteProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfile request
	GetProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNextQueueSlot request
	GetNextQueueSlot(ctx context.Context, params *GetNextQueueSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewQueue request
	PreviewQueue(ctx context.Context, params *PreviewQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQueueSlot request
	DeleteQueueSlot(ctx context.Context, params *DeleteQueueSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQueueSlots request
	ListQueueSlots(ctx context.Context, params *ListQueueSlotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQueueSlotWithBody request with any body
	CreateQueueSlotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQueueSlot(ctx context.Context, body CreateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateQueueSlotWithBody request with any body
	UpdateQueueSlotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateQueueSlot(ctx context.Context, body UpdateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRedditFeed request
	GetRedditFeed(ctx context.Context, params *GetRedditFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchReddit request
	SearchReddit(ctx context.Context, params *SearchRedditParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadBlueskyMedia request
	DownloadBlueskyMedia(ctx context.Context, params *DownloadBlueskyMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadFacebookVideo request
	DownloadFacebookVideo(ctx context.Context, params *DownloadFacebookVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadInstagramMedia request
	DownloadInstagramMedia(ctx context.Context, params *DownloadInstagramMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckInstagramHashtagsWithBody request with any body
	CheckInstagramHashtagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckInstagramHashtags(ctx context.Context, body CheckInstagramHashtagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadLinkedInVideo request
	DownloadLinkedInVideo(ctx context.Context, params *DownloadLinkedInVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadTikTokVideo request
	DownloadTikTokVideo(ctx context.Context, params *DownloadTikTokVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadTwitterMedia request
	DownloadTwitterMedia(ctx context.Context, params *DownloadTwitterMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadYouTubeVideo request
	DownloadYouTubeVideo(ctx context.Context, params *DownloadYouTubeVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetYouTubeTranscript request
	GetYouTubeTranscript(ctx context.Context, params *GetYouTubeTranscriptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageStats request
	GetUsageStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookLogs request
	GetWebhookLogs(ctx context.Context, params *GetWebhookLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookSettings request
	DeleteWebhookSettings(ctx context.Context, params *DeleteWebhookSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookSettings request
	GetWebhookSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookSettingsWithBody request with any body
	CreateWebhookSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhookSettings(ctx context.Context, body CreateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookSettingsWithBody request with any body
	UpdateWebhookSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookSettings(ctx context.Context, body UpdateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestWebhookWithBody request with any body
	TestWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestWebhook(ctx context.Context, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccountGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountGroup(ctx context.Context, body CreateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccountGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountGroup(ctx context.Context, groupId string, body UpdateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowerStats(ctx context.Context, params *GetFollowerStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowerStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccountsHealth(ctx context.Context, params *GetAllAccountsHealthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccountsHealthRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccount(ctx context.Context, accountId string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFacebookPages(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFacebookPagesRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFacebookPageWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFacebookPageRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFacebookPage(ctx context.Context, accountId string, body UpdateFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFacebookPageRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoogleBusinessAttributes(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoogleBusinessAttributesRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessAttributesWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessAttributesRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessAttributes(ctx context.Context, accountId string, body UpdateGoogleBusinessAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessAttributesRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoogleBusinessFoodMenus(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoogleBusinessFoodMenusRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessFoodMenusWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessFoodMenusRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessFoodMenus(ctx context.Context, accountId string, body UpdateGoogleBusinessFoodMenusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessFoodMenusRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoogleBusinessLocationDetails(ctx context.Context, accountId string, params *GetGoogleBusinessLocationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoogleBusinessLocationDetailsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessLocationDetailsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessLocationDetailsRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoogleBusinessLocationDetails(ctx context.Context, accountId string, body UpdateGoogleBusinessLocationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoogleBusinessLocationDetailsRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGmbLocations(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGmbLocationsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGmbLocationWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGmbLocationRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGmbLocation(ctx context.Context, accountId string, body UpdateGmbLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGmbLocationRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGoogleBusinessMedia(ctx context.Context, accountId string, params *DeleteGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGoogleBusinessMediaRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGoogleBusinessMedia(ctx context.Context, accountId string, params *ListGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGoogleBusinessMediaRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleBusinessMediaWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleBusinessMediaRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleBusinessMedia(ctx context.Context, accountId string, body CreateGoogleBusinessMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleBusinessMediaRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGoogleBusinessPlaceAction(ctx context.Context, accountId string, params *DeleteGoogleBusinessPlaceActionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGoogleBusinessPlaceActionRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGoogleBusinessPlaceActions(ctx context.Context, accountId string, params *ListGoogleBusinessPlaceActionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGoogleBusinessPlaceActionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleBusinessPlaceActionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleBusinessPlaceActionRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleBusinessPlaceAction(ctx context.Context, accountId string, body CreateGoogleBusinessPlaceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleBusinessPlaceActionRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoogleBusinessReviews(ctx context.Context, accountId string, params *GetGoogleBusinessReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoogleBusinessReviewsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountHealth(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountHealthRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkedInAggregateAnalytics(ctx context.Context, accountId string, params *GetLinkedInAggregateAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkedInAggregateAnalyticsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkedInMentions(ctx context.Context, accountId string, params *GetLinkedInMentionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkedInMentionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkedInOrganizationWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkedInOrganizationRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkedInOrganization(ctx context.Context, accountId string, body UpdateLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkedInOrganizationRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkedInOrganizations(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkedInOrganizationsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkedInPostAnalytics(ctx context.Context, accountId string, params *GetLinkedInPostAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkedInPostAnalyticsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPinterestBoards(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPinterestBoardsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePinterestBoardsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePinterestBoardsRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePinterestBoards(ctx context.Context, accountId string, body UpdatePinterestBoardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePinterestBoardsRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRedditSubreddits(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRedditSubredditsRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedditSubredditsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedditSubredditsRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedditSubreddits(ctx context.Context, accountId string, body UpdateRedditSubredditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedditSubredditsRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalytics(ctx context.Context, params *GetAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetYouTubeDailyViews(ctx context.Context, params *GetYouTubeDailyViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetYouTubeDailyViewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectBlueskyCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectBlueskyCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectBlueskyCredentials(ctx context.Context, body ConnectBlueskyCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectBlueskyCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFacebookPages(ctx context.Context, params *ListFacebookPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFacebookPagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectFacebookPageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectFacebookPageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectFacebookPage(ctx context.Context, body SelectFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectFacebookPageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGoogleBusinessLocations(ctx context.Context, params *ListGoogleBusinessLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGoogleBusinessLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectGoogleBusinessLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectGoogleBusinessLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectGoogleBusinessLocation(ctx context.Context, body SelectGoogleBusinessLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectGoogleBusinessLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLinkedInOrganizations(ctx context.Context, params *ListLinkedInOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinkedInOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectLinkedInOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectLinkedInOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectLinkedInOrganization(ctx context.Context, body SelectLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectLinkedInOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingOAuthData(ctx context.Context, params *GetPendingOAuthDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingOAuthDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPinterestBoardsForSelection(ctx context.Context, params *ListPinterestBoardsForSelectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPinterestBoardsForSelectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectPinterestBoardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectPinterestBoardRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectPinterestBoard(ctx context.Context, body SelectPinterestBoardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectPinterestBoardRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSnapchatProfiles(ctx context.Context, params *ListSnapchatProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSnapchatProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectSnapchatProfileWithBody(ctx context.Context, params *SelectSnapchatProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectSnapchatProfileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectSnapchatProfile(ctx context.Context, params *SelectSnapchatProfileParams, body SelectSnapchatProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectSnapchatProfileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTelegramConnectStatus(ctx context.Context, params *GetTelegramConnectStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTelegramConnectStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteTelegramConnect(ctx context.Context, params *CompleteTelegramConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteTelegramConnectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateTelegramConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateTelegramConnectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateTelegramConnect(ctx context.Context, body InitiateTelegramConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateTelegramConnectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectUrl(ctx context.Context, platform GetConnectUrlParamsPlatform, params *GetConnectUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectUrlRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandleOAuthCallbackWithBody(ctx context.Context, platform string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandleOAuthCallbackRequestWithBody(c.Server, platform, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandleOAuthCallback(ctx context.Context, platform string, body HandleOAuthCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandleOAuthCallbackRequest(c.Server, platform, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInboxComments(ctx context.Context, params *ListInboxCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInboxCommentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInboxComment(ctx context.Context, postId string, params *DeleteInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInboxCommentRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInboxPostComments(ctx context.Context, postId string, params *GetInboxPostCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInboxPostCommentsRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplyToInboxPostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplyToInboxPostRequestWithBody(c.Server, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplyToInboxPost(ctx context.Context, postId string, body ReplyToInboxPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplyToInboxPostRequest(c.Server, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnhideInboxComment(ctx context.Context, postId string, commentId string, params *UnhideInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnhideInboxCommentRequest(c.Server, postId, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideInboxCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideInboxCommentRequestWithBody(c.Server, postId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideInboxComment(ctx context.Context, postId string, commentId string, body HideInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideInboxCommentRequest(c.Server, postId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlikeInboxComment(ctx context.Context, postId string, commentId string, params *UnlikeInboxCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlikeInboxCommentRequest(c.Server, postId, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikeInboxCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikeInboxCommentRequestWithBody(c.Server, postId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikeInboxComment(ctx context.Context, postId string, commentId string, body LikeInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikeInboxCommentRequest(c.Server, postId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPrivateReplyToCommentWithBody(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPrivateReplyToCommentRequestWithBody(c.Server, postId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPrivateReplyToComment(ctx context.Context, postId string, commentId string, body SendPrivateReplyToCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPrivateReplyToCommentRequest(c.Server, postId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInboxConversations(ctx context.Context, params *ListInboxConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInboxConversationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInboxConversation(ctx context.Context, conversationId string, params *GetInboxConversationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInboxConversationRequest(c.Server, conversationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInboxConversationWithBody(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInboxConversationRequestWithBody(c.Server, conversationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInboxConversation(ctx context.Context, conversationId string, body UpdateInboxConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInboxConversationRequest(c.Server, conversationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInboxConversationMessages(ctx context.Context, conversationId string, params *GetInboxConversationMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInboxConversationMessagesRequest(c.Server, conversationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendInboxMessageWithBody(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendInboxMessageRequestWithBody(c.Server, conversationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendInboxMessage(ctx context.Context, conversationId string, body SendInboxMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendInboxMessageRequest(c.Server, conversationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInboxReviews(ctx context.Context, params *ListInboxReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInboxReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInboxReviewReplyWithBody(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInboxReviewReplyRequestWithBody(c.Server, reviewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInboxReviewReply(ctx context.Context, reviewId string, body DeleteInboxReviewReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInboxReviewReplyRequest(c.Server, reviewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplyToInboxReviewWithBody(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplyToInboxReviewRequestWithBody(c.Server, reviewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplyToInboxReview(ctx context.Context, reviewId string, body ReplyToInboxReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplyToInboxReviewRequest(c.Server, reviewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInviteTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInviteTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInviteToken(ctx context.Context, body CreateInviteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInviteTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogs(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLog(ctx context.Context, logId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogRequest(c.Server, logId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaPresignedUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaPresignedUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaPresignedUrl(ctx context.Context, body GetMediaPresignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaPresignedUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPosts(ctx context.Context, params *ListPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePost(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUploadPostsWithBody(ctx context.Context, params *BulkUploadPostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadPostsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostRequestWithBody(c.Server, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePost(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostRequest(c.Server, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostLogs(ctx context.Context, postId string, params *GetPostLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostLogsRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryPostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProfiles(ctx context.Context, params *ListProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProfile(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProfileRequest(c.Server, profileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileRequest(c.Server, profileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithBody(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, profileId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, profileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNextQueueSlot(ctx context.Context, params *GetNextQueueSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNextQueueSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewQueue(ctx context.Context, params *PreviewQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewQueueRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQueueSlot(ctx context.Context, params *DeleteQueueSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQueueSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQueueSlots(ctx context.Context, params *ListQueueSlotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQueueSlotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQueueSlotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQueueSlotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQueueSlot(ctx context.Context, body CreateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQueueSlotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQueueSlotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQueueSlotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQueueSlot(ctx context.Context, body UpdateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQueueSlotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRedditFeed(ctx context.Context, params *GetRedditFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRedditFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchReddit(ctx context.Context, params *SearchRedditParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRedditRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadBlueskyMedia(ctx context.Context, params *DownloadBlueskyMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadBlueskyMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadFacebookVideo(ctx context.Context, params *DownloadFacebookVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadFacebookVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadInstagramMedia(ctx context.Context, params *DownloadInstagramMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadInstagramMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckInstagramHashtagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckInstagramHashtagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckInstagramHashtags(ctx context.Context, body CheckInstagramHashtagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckInstagramHashtagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadLinkedInVideo(ctx context.Context, params *DownloadLinkedInVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadLinkedInVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadTikTokVideo(ctx context.Context, params *DownloadTikTokVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadTikTokVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadTwitterMedia(ctx context.Context, params *DownloadTwitterMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadTwitterMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadYouTubeVideo(ctx context.Context, params *DownloadYouTubeVideoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadYouTubeVideoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetYouTubeTranscript(ctx context.Context, params *GetYouTubeTranscriptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetYouTubeTranscriptRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookLogs(ctx context.Context, params *GetWebhookLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookSettings(ctx context.Context, params *DeleteWebhookSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSettings(ctx context.Context, body CreateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSettings(ctx context.Context, body UpdateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhook(ctx context.Context, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountGroupsRequest generates requests for ListAccountGroups
func NewListAccountGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccountGroupRequest calls the generic CreateAccountGroup builder with application/json body
func NewCreateAccountGroupRequest(server string, body CreateAccountGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccountGroupRequestWithBody generates requests for CreateAccountGroup with any type of body
func NewCreateAccountGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccountGroupRequest generates requests for DeleteAccountGroup
func NewDeleteAccountGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountGroupRequest calls the generic UpdateAccountGroup builder with application/json body
func NewUpdateAccountGroupRequest(server string, groupId string, body UpdateAccountGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateAccountGroupRequestWithBody generates requests for UpdateAccountGroup with any type of body
func NewUpdateAccountGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOverLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeOverLimit", runtime.ParamLocationQuery, *params.IncludeOverLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFollowerStatsRequest generates requests for GetFollowerStats
func NewGetFollowerStatsRequest(server string, params *GetFollowerStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/follower-stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountIds", runtime.ParamLocationQuery, *params.AccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Granularity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAccountsHealthRequest generates requests for GetAllAccountsHealth
func NewGetAllAccountsHealthRequest(server string, params *GetAllAccountsHealthParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAccountRequest generates requests for DeleteAccount
func NewDeleteAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountRequest calls the generic UpdateAccount builder with application/json body
func NewUpdateAccountRequest(server string, accountId string, body UpdateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func NewUpdateAccountRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFacebookPagesRequest generates requests for GetFacebookPages
func NewGetFacebookPagesRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/facebook-page", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFacebookPageRequest calls the generic UpdateFacebookPage builder with application/json body
func NewUpdateFacebookPageRequest(server string, accountId string, body UpdateFacebookPageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFacebookPageRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateFacebookPageRequestWithBody generates requests for UpdateFacebookPage with any type of body
func NewUpdateFacebookPageRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/facebook-page", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoogleBusinessAttributesRequest generates requests for GetGoogleBusinessAttributes
func NewGetGoogleBusinessAttributesRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-attributes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGoogleBusinessAttributesRequest calls the generic UpdateGoogleBusinessAttributes builder with application/json body
func NewUpdateGoogleBusinessAttributesRequest(server string, accountId string, body UpdateGoogleBusinessAttributesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGoogleBusinessAttributesRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateGoogleBusinessAttributesRequestWithBody generates requests for UpdateGoogleBusinessAttributes with any type of body
func NewUpdateGoogleBusinessAttributesRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-attributes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoogleBusinessFoodMenusRequest generates requests for GetGoogleBusinessFoodMenus
func NewGetGoogleBusinessFoodMenusRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-food-menus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGoogleBusinessFoodMenusRequest calls the generic UpdateGoogleBusinessFoodMenus builder with application/json body
func NewUpdateGoogleBusinessFoodMenusRequest(server string, accountId string, body UpdateGoogleBusinessFoodMenusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGoogleBusinessFoodMenusRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateGoogleBusinessFoodMenusRequestWithBody generates requests for UpdateGoogleBusinessFoodMenus with any type of body
func NewUpdateGoogleBusinessFoodMenusRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-food-menus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoogleBusinessLocationDetailsRequest generates requests for GetGoogleBusinessLocationDetails
func NewGetGoogleBusinessLocationDetailsRequest(server string, accountId string, params *GetGoogleBusinessLocationDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-location-details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReadMask != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "readMask", runtime.ParamLocationQuery, *params.ReadMask); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGoogleBusinessLocationDetailsRequest calls the generic UpdateGoogleBusinessLocationDetails builder with application/json body
func NewUpdateGoogleBusinessLocationDetailsRequest(server string, accountId string, body UpdateGoogleBusinessLocationDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGoogleBusinessLocationDetailsRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateGoogleBusinessLocationDetailsRequestWithBody generates requests for UpdateGoogleBusinessLocationDetails with any type of body
func NewUpdateGoogleBusinessLocationDetailsRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-location-details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGmbLocationsRequest generates requests for GetGmbLocations
func NewGetGmbLocationsRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGmbLocationRequest calls the generic UpdateGmbLocation builder with application/json body
func NewUpdateGmbLocationRequest(server string, accountId string, body UpdateGmbLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGmbLocationRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateGmbLocationRequestWithBody generates requests for UpdateGmbLocation with any type of body
func NewUpdateGmbLocationRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGoogleBusinessMediaRequest generates requests for DeleteGoogleBusinessMedia
func NewDeleteGoogleBusinessMediaRequest(server string, accountId string, params *DeleteGoogleBusinessMediaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-media", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaId", runtime.ParamLocationQuery, params.MediaId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGoogleBusinessMediaRequest generates requests for ListGoogleBusinessMedia
func NewListGoogleBusinessMediaRequest(server string, accountId string, params *ListGoogleBusinessMediaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-media", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGoogleBusinessMediaRequest calls the generic CreateGoogleBusinessMedia builder with application/json body
func NewCreateGoogleBusinessMediaRequest(server string, accountId string, body CreateGoogleBusinessMediaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGoogleBusinessMediaRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateGoogleBusinessMediaRequestWithBody generates requests for CreateGoogleBusinessMedia with any type of body
func NewCreateGoogleBusinessMediaRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-media", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGoogleBusinessPlaceActionRequest generates requests for DeleteGoogleBusinessPlaceAction
func NewDeleteGoogleBusinessPlaceActionRequest(server string, accountId string, params *DeleteGoogleBusinessPlaceActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-place-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGoogleBusinessPlaceActionsRequest generates requests for ListGoogleBusinessPlaceActions
func NewListGoogleBusinessPlaceActionsRequest(server string, accountId string, params *ListGoogleBusinessPlaceActionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-place-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGoogleBusinessPlaceActionRequest calls the generic CreateGoogleBusinessPlaceAction builder with application/json body
func NewCreateGoogleBusinessPlaceActionRequest(server string, accountId string, body CreateGoogleBusinessPlaceActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGoogleBusinessPlaceActionRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateGoogleBusinessPlaceActionRequestWithBody generates requests for CreateGoogleBusinessPlaceAction with any type of body
func NewCreateGoogleBusinessPlaceActionRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-place-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGoogleBusinessReviewsRequest generates requests for GetGoogleBusinessReviews
func NewGetGoogleBusinessReviewsRequest(server string, accountId string, params *GetGoogleBusinessReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/gmb-reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountHealthRequest generates requests for GetAccountHealth
func NewGetAccountHealthRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/health", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinkedInAggregateAnalyticsRequest generates requests for GetLinkedInAggregateAnalytics
func NewGetLinkedInAggregateAnalyticsRequest(server string, accountId string, params *GetLinkedInAggregateAnalyticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/linkedin-aggregate-analytics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Aggregation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aggregation", runtime.ParamLocationQuery, *params.Aggregation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinkedInMentionsRequest generates requests for GetLinkedInMentions
func NewGetLinkedInMentionsRequest(server string, accountId string, params *GetLinkedInMentionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/linkedin-mentions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DisplayName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayName", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLinkedInOrganizationRequest calls the generic UpdateLinkedInOrganization builder with application/json body
func NewUpdateLinkedInOrganizationRequest(server string, accountId string, body UpdateLinkedInOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLinkedInOrganizationRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateLinkedInOrganizationRequestWithBody generates requests for UpdateLinkedInOrganization with any type of body
func NewUpdateLinkedInOrganizationRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/linkedin-organization", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLinkedInOrganizationsRequest generates requests for GetLinkedInOrganizations
func NewGetLinkedInOrganizationsRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/linkedin-organizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinkedInPostAnalyticsRequest generates requests for GetLinkedInPostAnalytics
func NewGetLinkedInPostAnalyticsRequest(server string, accountId string, params *GetLinkedInPostAnalyticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/linkedin-post-analytics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urn", runtime.ParamLocationQuery, params.Urn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPinterestBoardsRequest generates requests for GetPinterestBoards
func NewGetPinterestBoardsRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/pinterest-boards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePinterestBoardsRequest calls the generic UpdatePinterestBoards builder with application/json body
func NewUpdatePinterestBoardsRequest(server string, accountId string, body UpdatePinterestBoardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePinterestBoardsRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdatePinterestBoardsRequestWithBody generates requests for UpdatePinterestBoards with any type of body
func NewUpdatePinterestBoardsRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/pinterest-boards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRedditSubredditsRequest generates requests for GetRedditSubreddits
func NewGetRedditSubredditsRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/reddit-subreddits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRedditSubredditsRequest calls the generic UpdateRedditSubreddits builder with application/json body
func NewUpdateRedditSubredditsRequest(server string, accountId string, body UpdateRedditSubredditsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRedditSubredditsRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewUpdateRedditSubredditsRequestWithBody generates requests for UpdateRedditSubreddits with any type of body
func NewUpdateRedditSubredditsRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/reddit-subreddits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAnalyticsRequest generates requests for GetAnalytics
func NewGetAnalyticsRequest(server string, params *GetAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/analytics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postId", runtime.ParamLocationQuery, *params.PostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetYouTubeDailyViewsRequest generates requests for GetYouTubeDailyViews
func NewGetYouTubeDailyViewsRequest(server string, params *GetYouTubeDailyViewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/analytics/youtube/daily-views")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoId", runtime.ParamLocationQuery, params.VideoId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApiKeysRequest generates requests for ListApiKeys
func NewListApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyRequest generates requests for DeleteApiKey
func NewDeleteApiKeyRequest(server string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectBlueskyCredentialsRequest calls the generic ConnectBlueskyCredentials builder with application/json body
func NewConnectBlueskyCredentialsRequest(server string, body ConnectBlueskyCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectBlueskyCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectBlueskyCredentialsRequestWithBody generates requests for ConnectBlueskyCredentials with any type of body
func NewConnectBlueskyCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/bluesky/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFacebookPagesRequest generates requests for ListFacebookPages
func NewListFacebookPagesRequest(server string, params *ListFacebookPagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/facebook/select-page")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tempToken", runtime.ParamLocationQuery, params.TempToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSelectFacebookPageRequest calls the generic SelectFacebookPage builder with application/json body
func NewSelectFacebookPageRequest(server string, body SelectFacebookPageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectFacebookPageRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectFacebookPageRequestWithBody generates requests for SelectFacebookPage with any type of body
func NewSelectFacebookPageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/facebook/select-page")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGoogleBusinessLocationsRequest generates requests for ListGoogleBusinessLocations
func NewListGoogleBusinessLocationsRequest(server string, params *ListGoogleBusinessLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/googlebusiness/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tempToken", runtime.ParamLocationQuery, params.TempToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSelectGoogleBusinessLocationRequest calls the generic SelectGoogleBusinessLocation builder with application/json body
func NewSelectGoogleBusinessLocationRequest(server string, body SelectGoogleBusinessLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectGoogleBusinessLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectGoogleBusinessLocationRequestWithBody generates requests for SelectGoogleBusinessLocation with any type of body
func NewSelectGoogleBusinessLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/googlebusiness/select-location")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLinkedInOrganizationsRequest generates requests for ListLinkedInOrganizations
func NewListLinkedInOrganizationsRequest(server string, params *ListLinkedInOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/linkedin/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tempToken", runtime.ParamLocationQuery, params.TempToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgIds", runtime.ParamLocationQuery, params.OrgIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSelectLinkedInOrganizationRequest calls the generic SelectLinkedInOrganization builder with application/json body
func NewSelectLinkedInOrganizationRequest(server string, body SelectLinkedInOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectLinkedInOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectLinkedInOrganizationRequestWithBody generates requests for SelectLinkedInOrganization with any type of body
func NewSelectLinkedInOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/linkedin/select-organization")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPendingOAuthDataRequest generates requests for GetPendingOAuthData
func NewGetPendingOAuthDataRequest(server string, params *GetPendingOAuthDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/pending-data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPinterestBoardsForSelectionRequest generates requests for ListPinterestBoardsForSelection
func NewListPinterestBoardsForSelectionRequest(server string, params *ListPinterestBoardsForSelectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/pinterest/select-board")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tempToken", runtime.ParamLocationQuery, params.TempToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Connect-Token", runtime.ParamLocationHeader, params.XConnectToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Connect-Token", headerParam0)

	}

	return req, nil
}

// NewSelectPinterestBoardRequest calls the generic SelectPinterestBoard builder with application/json body
func NewSelectPinterestBoardRequest(server string, body SelectPinterestBoardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectPinterestBoardRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectPinterestBoardRequestWithBody generates requests for SelectPinterestBoard with any type of body
func NewSelectPinterestBoardRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/pinterest/select-board")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSnapchatProfilesRequest generates requests for ListSnapchatProfiles
func NewListSnapchatProfilesRequest(server string, params *ListSnapchatProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/snapchat/select-profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tempToken", runtime.ParamLocationQuery, params.TempToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Connect-Token", runtime.ParamLocationHeader, params.XConnectToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Connect-Token", headerParam0)

	}

	return req, nil
}

// NewSelectSnapchatProfileRequest calls the generic SelectSnapchatProfile builder with application/json body
func NewSelectSnapchatProfileRequest(server string, params *SelectSnapchatProfileParams, body SelectSnapchatProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectSnapchatProfileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSelectSnapchatProfileRequestWithBody generates requests for SelectSnapchatProfile with any type of body
func NewSelectSnapchatProfileRequestWithBody(server string, params *SelectSnapchatProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/snapchat/select-profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XConnectToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Connect-Token", runtime.ParamLocationHeader, *params.XConnectToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Connect-Token", headerParam0)
		}

	}

	return req, nil
}

// NewGetTelegramConnectStatusRequest generates requests for GetTelegramConnectStatus
func NewGetTelegramConnectStatusRequest(server string, params *GetTelegramConnectStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/telegram")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteTelegramConnectRequest generates requests for CompleteTelegramConnect
func NewCompleteTelegramConnectRequest(server string, params *CompleteTelegramConnectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/telegram")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitiateTelegramConnectRequest calls the generic InitiateTelegramConnect builder with application/json body
func NewInitiateTelegramConnectRequest(server string, body InitiateTelegramConnectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInitiateTelegramConnectRequestWithBody(server, "application/json", bodyReader)
}

// NewInitiateTelegramConnectRequestWithBody generates requests for InitiateTelegramConnect with any type of body
func NewInitiateTelegramConnectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/telegram")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConnectUrlRequest generates requests for GetConnectUrl
func NewGetConnectUrlRequest(server string, platform GetConnectUrlParamsPlatform, params *GetConnectUrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RedirectUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_url", runtime.ParamLocationQuery, *params.RedirectUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHandleOAuthCallbackRequest calls the generic HandleOAuthCallback builder with application/json body
func NewHandleOAuthCallbackRequest(server string, platform string, body HandleOAuthCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHandleOAuthCallbackRequestWithBody(server, platform, "application/json", bodyReader)
}

// NewHandleOAuthCallbackRequestWithBody generates requests for HandleOAuthCallback with any type of body
func NewHandleOAuthCallbackRequestWithBody(server string, platform string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connect/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInboxCommentsRequest generates requests for ListInboxComments
func NewListInboxCommentsRequest(server string, params *ListInboxCommentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinComments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minComments", runtime.ParamLocationQuery, *params.MinComments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInboxCommentRequest generates requests for DeleteInboxComment
func NewDeleteInboxCommentRequest(server string, postId string, params *DeleteInboxCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commentId", runtime.ParamLocationQuery, params.CommentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInboxPostCommentsRequest generates requests for GetInboxPostComments
func NewGetInboxPostCommentsRequest(server string, postId string, params *GetInboxPostCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subreddit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subreddit", runtime.ParamLocationQuery, *params.Subreddit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commentId", runtime.ParamLocationQuery, *params.CommentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplyToInboxPostRequest calls the generic ReplyToInboxPost builder with application/json body
func NewReplyToInboxPostRequest(server string, postId string, body ReplyToInboxPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplyToInboxPostRequestWithBody(server, postId, "application/json", bodyReader)
}

// NewReplyToInboxPostRequestWithBody generates requests for ReplyToInboxPost with any type of body
func NewReplyToInboxPostRequestWithBody(server string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnhideInboxCommentRequest generates requests for UnhideInboxComment
func NewUnhideInboxCommentRequest(server string, postId string, commentId string, params *UnhideInboxCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s/%s/hide", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHideInboxCommentRequest calls the generic HideInboxComment builder with application/json body
func NewHideInboxCommentRequest(server string, postId string, commentId string, body HideInboxCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHideInboxCommentRequestWithBody(server, postId, commentId, "application/json", bodyReader)
}

// NewHideInboxCommentRequestWithBody generates requests for HideInboxComment with any type of body
func NewHideInboxCommentRequestWithBody(server string, postId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s/%s/hide", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlikeInboxCommentRequest generates requests for UnlikeInboxComment
func NewUnlikeInboxCommentRequest(server string, postId string, commentId string, params *UnlikeInboxCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s/%s/like", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LikeUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "likeUri", runtime.ParamLocationQuery, *params.LikeUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLikeInboxCommentRequest calls the generic LikeInboxComment builder with application/json body
func NewLikeInboxCommentRequest(server string, postId string, commentId string, body LikeInboxCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLikeInboxCommentRequestWithBody(server, postId, commentId, "application/json", bodyReader)
}

// NewLikeInboxCommentRequestWithBody generates requests for LikeInboxComment with any type of body
func NewLikeInboxCommentRequestWithBody(server string, postId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s/%s/like", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendPrivateReplyToCommentRequest calls the generic SendPrivateReplyToComment builder with application/json body
func NewSendPrivateReplyToCommentRequest(server string, postId string, commentId string, body SendPrivateReplyToCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendPrivateReplyToCommentRequestWithBody(server, postId, commentId, "application/json", bodyReader)
}

// NewSendPrivateReplyToCommentRequestWithBody generates requests for SendPrivateReplyToComment with any type of body
func NewSendPrivateReplyToCommentRequestWithBody(server string, postId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/comments/%s/%s/private-reply", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInboxConversationsRequest generates requests for ListInboxConversations
func NewListInboxConversationsRequest(server string, params *ListInboxConversationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/conversations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInboxConversationRequest generates requests for GetInboxConversation
func NewGetInboxConversationRequest(server string, conversationId string, params *GetInboxConversationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversationId", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/conversations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInboxConversationRequest calls the generic UpdateInboxConversation builder with application/json body
func NewUpdateInboxConversationRequest(server string, conversationId string, body UpdateInboxConversationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInboxConversationRequestWithBody(server, conversationId, "application/json", bodyReader)
}

// NewUpdateInboxConversationRequestWithBody generates requests for UpdateInboxConversation with any type of body
func NewUpdateInboxConversationRequestWithBody(server string, conversationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversationId", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/conversations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInboxConversationMessagesRequest generates requests for GetInboxConversationMessages
func NewGetInboxConversationMessagesRequest(server string, conversationId string, params *GetInboxConversationMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversationId", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/conversations/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendInboxMessageRequest calls the generic SendInboxMessage builder with application/json body
func NewSendInboxMessageRequest(server string, conversationId string, body SendInboxMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendInboxMessageRequestWithBody(server, conversationId, "application/json", bodyReader)
}

// NewSendInboxMessageRequestWithBody generates requests for SendInboxMessage with any type of body
func NewSendInboxMessageRequestWithBody(server string, conversationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "conversationId", runtime.ParamLocationPath, conversationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/conversations/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInboxReviewsRequest generates requests for ListInboxReviews
func NewListInboxReviewsRequest(server string, params *ListInboxReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/reviews")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minRating", runtime.ParamLocationQuery, *params.MinRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRating", runtime.ParamLocationQuery, *params.MaxRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasReply != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasReply", runtime.ParamLocationQuery, *params.HasReply); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInboxReviewReplyRequest calls the generic DeleteInboxReviewReply builder with application/json body
func NewDeleteInboxReviewReplyRequest(server string, reviewId string, body DeleteInboxReviewReplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteInboxReviewReplyRequestWithBody(server, reviewId, "application/json", bodyReader)
}

// NewDeleteInboxReviewReplyRequestWithBody generates requests for DeleteInboxReviewReply with any type of body
func NewDeleteInboxReviewReplyRequestWithBody(server string, reviewId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reviewId", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/reviews/%s/reply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplyToInboxReviewRequest calls the generic ReplyToInboxReview builder with application/json body
func NewReplyToInboxReviewRequest(server string, reviewId string, body ReplyToInboxReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplyToInboxReviewRequestWithBody(server, reviewId, "application/json", bodyReader)
}

// NewReplyToInboxReviewRequestWithBody generates requests for ReplyToInboxReview with any type of body
func NewReplyToInboxReviewRequestWithBody(server string, reviewId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reviewId", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/inbox/reviews/%s/reply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateInviteTokenRequest calls the generic CreateInviteToken builder with application/json body
func NewCreateInviteTokenRequest(server string, body CreateInviteTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInviteTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInviteTokenRequestWithBody generates requests for CreateInviteToken with any type of body
func NewCreateInviteTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/invite/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLogsRequest generates requests for ListLogs
func NewListLogsRequest(server string, params *ListLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogRequest generates requests for GetLog
func NewGetLogRequest(server string, logId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "logId", runtime.ParamLocationPath, logId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaPresignedUrlRequest calls the generic GetMediaPresignedUrl builder with application/json body
func NewGetMediaPresignedUrlRequest(server string, body GetMediaPresignedUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMediaPresignedUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMediaPresignedUrlRequestWithBody generates requests for GetMediaPresignedUrl with any type of body
func NewGetMediaPresignedUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/media/presign")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPostsRequest generates requests for ListPosts
func NewListPostsRequest(server string, params *ListPostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, *params.ProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBy", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateFrom", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateTo", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePostRequest calls the generic CreatePost builder with application/json body
func NewCreatePostRequest(server string, body CreatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePostRequestWithBody generates requests for CreatePost with any type of body
func NewCreatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUploadPostsRequestWithBody generates requests for BulkUploadPosts with any type of body
func NewBulkUploadPostsRequestWithBody(server string, params *BulkUploadPostsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/bulk-upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DryRun != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dryRun", runtime.ParamLocationQuery, *params.DryRun); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePostRequest generates requests for DeletePost
func NewDeletePostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostRequest generates requests for GetPost
func NewGetPostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePostRequest calls the generic UpdatePost builder with application/json body
func NewUpdatePostRequest(server string, postId string, body UpdatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePostRequestWithBody(server, postId, "application/json", bodyReader)
}

// NewUpdatePostRequestWithBody generates requests for UpdatePost with any type of body
func NewUpdatePostRequestWithBody(server string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPostLogsRequest generates requests for GetPostLogs
func NewGetPostLogsRequest(server string, postId string, params *GetPostLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryPostRequest generates requests for RetryPost
func NewRetryPostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "postId", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/posts/%s/retry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProfilesRequest generates requests for ListProfiles
func NewListProfilesRequest(server string, params *ListProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeOverLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeOverLimit", runtime.ParamLocationQuery, *params.IncludeOverLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProfileRequest calls the generic CreateProfile builder with application/json body
func NewCreateProfileRequest(server string, body CreateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProfileRequestWithBody generates requests for CreateProfile with any type of body
func NewCreateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProfileRequest generates requests for DeleteProfile
func NewDeleteProfileRequest(server string, profileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileRequest generates requests for GetProfile
func NewGetProfileRequest(server string, profileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, profileId string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, profileId, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, profileId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNextQueueSlotRequest generates requests for GetNextQueueSlot
func NewGetNextQueueSlotRequest(server string, params *GetNextQueueSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/next-slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.QueueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queueId", runtime.ParamLocationQuery, *params.QueueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewQueueRequest generates requests for PreviewQueue
func NewPreviewQueueRequest(server string, params *PreviewQueueParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteQueueSlotRequest generates requests for DeleteQueueSlot
func NewDeleteQueueSlotRequest(server string, params *DeleteQueueSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/slots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queueId", runtime.ParamLocationQuery, params.QueueId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQueueSlotsRequest generates requests for ListQueueSlots
func NewListQueueSlotsRequest(server string, params *ListQueueSlotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/slots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profileId", runtime.ParamLocationQuery, params.ProfileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.QueueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queueId", runtime.ParamLocationQuery, *params.QueueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.All != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateQueueSlotRequest calls the generic CreateQueueSlot builder with application/json body
func NewCreateQueueSlotRequest(server string, body CreateQueueSlotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQueueSlotRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateQueueSlotRequestWithBody generates requests for CreateQueueSlot with any type of body
func NewCreateQueueSlotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/slots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateQueueSlotRequest calls the generic UpdateQueueSlot builder with application/json body
func NewUpdateQueueSlotRequest(server string, body UpdateQueueSlotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateQueueSlotRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateQueueSlotRequestWithBody generates requests for UpdateQueueSlot with any type of body
func NewUpdateQueueSlotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/queue/slots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRedditFeedRequest generates requests for GetRedditFeed
func NewGetRedditFeedRequest(server string, params *GetRedditFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reddit/feed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subreddit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subreddit", runtime.ParamLocationQuery, *params.Subreddit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.T != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "t", runtime.ParamLocationQuery, *params.T); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRedditRequest generates requests for SearchReddit
func NewSearchRedditRequest(server string, params *SearchRedditParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reddit/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subreddit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subreddit", runtime.ParamLocationQuery, *params.Subreddit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RestrictSr != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrict_sr", runtime.ParamLocationQuery, *params.RestrictSr); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadBlueskyMediaRequest generates requests for DownloadBlueskyMedia
func NewDownloadBlueskyMediaRequest(server string, params *DownloadBlueskyMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/bluesky/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadFacebookVideoRequest generates requests for DownloadFacebookVideo
func NewDownloadFacebookVideoRequest(server string, params *DownloadFacebookVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/facebook/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadInstagramMediaRequest generates requests for DownloadInstagramMedia
func NewDownloadInstagramMediaRequest(server string, params *DownloadInstagramMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/instagram/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckInstagramHashtagsRequest calls the generic CheckInstagramHashtags builder with application/json body
func NewCheckInstagramHashtagsRequest(server string, body CheckInstagramHashtagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckInstagramHashtagsRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckInstagramHashtagsRequestWithBody generates requests for CheckInstagramHashtags with any type of body
func NewCheckInstagramHashtagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/instagram/hashtag-checker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadLinkedInVideoRequest generates requests for DownloadLinkedInVideo
func NewDownloadLinkedInVideoRequest(server string, params *DownloadLinkedInVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/linkedin/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadTikTokVideoRequest generates requests for DownloadTikTokVideo
func NewDownloadTikTokVideoRequest(server string, params *DownloadTikTokVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/tiktok/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormatId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "formatId", runtime.ParamLocationQuery, *params.FormatId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadTwitterMediaRequest generates requests for DownloadTwitterMedia
func NewDownloadTwitterMediaRequest(server string, params *DownloadTwitterMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/twitter/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormatId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "formatId", runtime.ParamLocationQuery, *params.FormatId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadYouTubeVideoRequest generates requests for DownloadYouTubeVideo
func NewDownloadYouTubeVideoRequest(server string, params *DownloadYouTubeVideoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/youtube/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FormatId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "formatId", runtime.ParamLocationQuery, *params.FormatId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetYouTubeTranscriptRequest generates requests for GetYouTubeTranscript
func NewGetYouTubeTranscriptRequest(server string, params *GetYouTubeTranscriptParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tools/youtube/transcript")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageStatsRequest generates requests for GetUsageStats
func NewGetUsageStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/usage-stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookLogsRequest generates requests for GetWebhookLogs
func NewGetWebhookLogsRequest(server string, params *GetWebhookLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WebhookId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "webhookId", runtime.ParamLocationQuery, *params.WebhookId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWebhookSettingsRequest generates requests for DeleteWebhookSettings
func NewDeleteWebhookSettingsRequest(server string, params *DeleteWebhookSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookSettingsRequest generates requests for GetWebhookSettings
func NewGetWebhookSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookSettingsRequest calls the generic CreateWebhookSettings builder with application/json body
func NewCreateWebhookSettingsRequest(server string, body CreateWebhookSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookSettingsRequestWithBody generates requests for CreateWebhookSettings with any type of body
func NewCreateWebhookSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateWebhookSettingsRequest calls the generic UpdateWebhookSettings builder with application/json body
func NewUpdateWebhookSettingsRequest(server string, body UpdateWebhookSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateWebhookSettingsRequestWithBody generates requests for UpdateWebhookSettings with any type of body
func NewUpdateWebhookSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestWebhookRequest calls the generic TestWebhook builder with application/json body
func NewTestWebhookRequest(server string, body TestWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewTestWebhookRequestWithBody generates requests for TestWebhook with any type of body
func NewTestWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccountGroupsWithResponse request
	ListAccountGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAccountGroupsResponse, error)

	// CreateAccountGroupWithBodyWithResponse request with any body
	CreateAccountGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountGroupResponse, error)

	CreateAccountGroupWithResponse(ctx context.Context, body CreateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountGroupResponse, error)

	// DeleteAccountGroupWithResponse request
	DeleteAccountGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAccountGroupResponse, error)

	// UpdateAccountGroupWithBodyWithResponse request with any body
	UpdateAccountGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountGroupResponse, error)

	UpdateAccountGroupWithResponse(ctx context.Context, groupId string, body UpdateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountGroupResponse, error)

	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// GetFollowerStatsWithResponse request
	GetFollowerStatsWithResponse(ctx context.Context, params *GetFollowerStatsParams, reqEditors ...RequestEditorFn) (*GetFollowerStatsResponse, error)

	// GetAllAccountsHealthWithResponse request
	GetAllAccountsHealthWithResponse(ctx context.Context, params *GetAllAccountsHealthParams, reqEditors ...RequestEditorFn) (*GetAllAccountsHealthResponse, error)

	// DeleteAccountWithResponse request
	DeleteAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error)

	// UpdateAccountWithBodyWithResponse request with any body
	UpdateAccountWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	UpdateAccountWithResponse(ctx context.Context, accountId string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	// GetFacebookPagesWithResponse request
	GetFacebookPagesWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetFacebookPagesResponse, error)

	// UpdateFacebookPageWithBodyWithResponse request with any body
	UpdateFacebookPageWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFacebookPageResponse, error)

	UpdateFacebookPageWithResponse(ctx context.Context, accountId string, body UpdateFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFacebookPageResponse, error)

	// GetGoogleBusinessAttributesWithResponse request
	GetGoogleBusinessAttributesWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGoogleBusinessAttributesResponse, error)

	// UpdateGoogleBusinessAttributesWithBodyWithResponse request with any body
	UpdateGoogleBusinessAttributesWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessAttributesResponse, error)

	UpdateGoogleBusinessAttributesWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessAttributesResponse, error)

	// GetGoogleBusinessFoodMenusWithResponse request
	GetGoogleBusinessFoodMenusWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGoogleBusinessFoodMenusResponse, error)

	// UpdateGoogleBusinessFoodMenusWithBodyWithResponse request with any body
	UpdateGoogleBusinessFoodMenusWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessFoodMenusResponse, error)

	UpdateGoogleBusinessFoodMenusWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessFoodMenusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessFoodMenusResponse, error)

	// GetGoogleBusinessLocationDetailsWithResponse request
	GetGoogleBusinessLocationDetailsWithResponse(ctx context.Context, accountId string, params *GetGoogleBusinessLocationDetailsParams, reqEditors ...RequestEditorFn) (*GetGoogleBusinessLocationDetailsResponse, error)

	// UpdateGoogleBusinessLocationDetailsWithBodyWithResponse request with any body
	UpdateGoogleBusinessLocationDetailsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessLocationDetailsResponse, error)

	UpdateGoogleBusinessLocationDetailsWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessLocationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessLocationDetailsResponse, error)

	// GetGmbLocationsWithResponse request
	GetGmbLocationsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGmbLocationsResponse, error)

	// UpdateGmbLocationWithBodyWithResponse request with any body
	UpdateGmbLocationWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGmbLocationResponse, error)

	UpdateGmbLocationWithResponse(ctx context.Context, accountId string, body UpdateGmbLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGmbLocationResponse, error)

	// DeleteGoogleBusinessMediaWithResponse request
	DeleteGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, params *DeleteGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*DeleteGoogleBusinessMediaResponse, error)

	// ListGoogleBusinessMediaWithResponse request
	ListGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, params *ListGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessMediaResponse, error)

	// CreateGoogleBusinessMediaWithBodyWithResponse request with any body
	CreateGoogleBusinessMediaWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessMediaResponse, error)

	CreateGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, body CreateGoogleBusinessMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessMediaResponse, error)

	// DeleteGoogleBusinessPlaceActionWithResponse request
	DeleteGoogleBusinessPlaceActionWithResponse(ctx context.Context, accountId string, params *DeleteGoogleBusinessPlaceActionParams, reqEditors ...RequestEditorFn) (*DeleteGoogleBusinessPlaceActionResponse, error)

	// ListGoogleBusinessPlaceActionsWithResponse request
	ListGoogleBusinessPlaceActionsWithResponse(ctx context.Context, accountId string, params *ListGoogleBusinessPlaceActionsParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessPlaceActionsResponse, error)

	// CreateGoogleBusinessPlaceActionWithBodyWithResponse request with any body
	CreateGoogleBusinessPlaceActionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessPlaceActionResponse, error)

	CreateGoogleBusinessPlaceActionWithResponse(ctx context.Context, accountId string, body CreateGoogleBusinessPlaceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessPlaceActionResponse, error)

	// GetGoogleBusinessReviewsWithResponse request
	GetGoogleBusinessReviewsWithResponse(ctx context.Context, accountId string, params *GetGoogleBusinessReviewsParams, reqEditors ...RequestEditorFn) (*GetGoogleBusinessReviewsResponse, error)

	// GetAccountHealthWithResponse request
	GetAccountHealthWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountHealthResponse, error)

	// GetLinkedInAggregateAnalyticsWithResponse request
	GetLinkedInAggregateAnalyticsWithResponse(ctx context.Context, accountId string, params *GetLinkedInAggregateAnalyticsParams, reqEditors ...RequestEditorFn) (*GetLinkedInAggregateAnalyticsResponse, error)

	// GetLinkedInMentionsWithResponse request
	GetLinkedInMentionsWithResponse(ctx context.Context, accountId string, params *GetLinkedInMentionsParams, reqEditors ...RequestEditorFn) (*GetLinkedInMentionsResponse, error)

	// UpdateLinkedInOrganizationWithBodyWithResponse request with any body
	UpdateLinkedInOrganizationWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkedInOrganizationResponse, error)

	UpdateLinkedInOrganizationWithResponse(ctx context.Context, accountId string, body UpdateLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkedInOrganizationResponse, error)

	// GetLinkedInOrganizationsWithResponse request
	GetLinkedInOrganizationsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetLinkedInOrganizationsResponse, error)

	// GetLinkedInPostAnalyticsWithResponse request
	GetLinkedInPostAnalyticsWithResponse(ctx context.Context, accountId string, params *GetLinkedInPostAnalyticsParams, reqEditors ...RequestEditorFn) (*GetLinkedInPostAnalyticsResponse, error)

	// GetPinterestBoardsWithResponse request
	GetPinterestBoardsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetPinterestBoardsResponse, error)

	// UpdatePinterestBoardsWithBodyWithResponse request with any body
	UpdatePinterestBoardsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePinterestBoardsResponse, error)

	UpdatePinterestBoardsWithResponse(ctx context.Context, accountId string, body UpdatePinterestBoardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePinterestBoardsResponse, error)

	// GetRedditSubredditsWithResponse request
	GetRedditSubredditsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRedditSubredditsResponse, error)

	// UpdateRedditSubredditsWithBodyWithResponse request with any body
	UpdateRedditSubredditsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRedditSubredditsResponse, error)

	UpdateRedditSubredditsWithResponse(ctx context.Context, accountId string, body UpdateRedditSubredditsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRedditSubredditsResponse, error)

	// GetAnalyticsWithResponse request
	GetAnalyticsWithResponse(ctx context.Context, params *GetAnalyticsParams, reqEditors ...RequestEditorFn) (*GetAnalyticsResponse, error)

	// GetYouTubeDailyViewsWithResponse request
	GetYouTubeDailyViewsWithResponse(ctx context.Context, params *GetYouTubeDailyViewsParams, reqEditors ...RequestEditorFn) (*GetYouTubeDailyViewsResponse, error)

	// ListApiKeysWithResponse request
	ListApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	// CreateApiKeyWithBodyWithResponse request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	// DeleteApiKeyWithResponse request
	DeleteApiKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error)

	// ConnectBlueskyCredentialsWithBodyWithResponse request with any body
	ConnectBlueskyCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectBlueskyCredentialsResponse, error)

	ConnectBlueskyCredentialsWithResponse(ctx context.Context, body ConnectBlueskyCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectBlueskyCredentialsResponse, error)

	// ListFacebookPagesWithResponse request
	ListFacebookPagesWithResponse(ctx context.Context, params *ListFacebookPagesParams, reqEditors ...RequestEditorFn) (*ListFacebookPagesResponse, error)

	// SelectFacebookPageWithBodyWithResponse request with any body
	SelectFacebookPageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectFacebookPageResponse, error)

	SelectFacebookPageWithResponse(ctx context.Context, body SelectFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectFacebookPageResponse, error)

	// ListGoogleBusinessLocationsWithResponse request
	ListGoogleBusinessLocationsWithResponse(ctx context.Context, params *ListGoogleBusinessLocationsParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessLocationsResponse, error)

	// SelectGoogleBusinessLocationWithBodyWithResponse request with any body
	SelectGoogleBusinessLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectGoogleBusinessLocationResponse, error)

	SelectGoogleBusinessLocationWithResponse(ctx context.Context, body SelectGoogleBusinessLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectGoogleBusinessLocationResponse, error)

	// ListLinkedInOrganizationsWithResponse request
	ListLinkedInOrganizationsWithResponse(ctx context.Context, params *ListLinkedInOrganizationsParams, reqEditors ...RequestEditorFn) (*ListLinkedInOrganizationsResponse, error)

	// SelectLinkedInOrganizationWithBodyWithResponse request with any body
	SelectLinkedInOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectLinkedInOrganizationResponse, error)

	SelectLinkedInOrganizationWithResponse(ctx context.Context, body SelectLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectLinkedInOrganizationResponse, error)

	// GetPendingOAuthDataWithResponse request
	GetPendingOAuthDataWithResponse(ctx context.Context, params *GetPendingOAuthDataParams, reqEditors ...RequestEditorFn) (*GetPendingOAuthDataResponse, error)

	// ListPinterestBoardsForSelectionWithResponse request
	ListPinterestBoardsForSelectionWithResponse(ctx context.Context, params *ListPinterestBoardsForSelectionParams, reqEditors ...RequestEditorFn) (*ListPinterestBoardsForSelectionResponse, error)

	// SelectPinterestBoardWithBodyWithResponse request with any body
	SelectPinterestBoardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectPinterestBoardResponse, error)

	SelectPinterestBoardWithResponse(ctx context.Context, body SelectPinterestBoardJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectPinterestBoardResponse, error)

	// ListSnapchatProfilesWithResponse request
	ListSnapchatProfilesWithResponse(ctx context.Context, params *ListSnapchatProfilesParams, reqEditors ...RequestEditorFn) (*ListSnapchatProfilesResponse, error)

	// SelectSnapchatProfileWithBodyWithResponse request with any body
	SelectSnapchatProfileWithBodyWithResponse(ctx context.Context, params *SelectSnapchatProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectSnapchatProfileResponse, error)

	SelectSnapchatProfileWithResponse(ctx context.Context, params *SelectSnapchatProfileParams, body SelectSnapchatProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectSnapchatProfileResponse, error)

	// GetTelegramConnectStatusWithResponse request
	GetTelegramConnectStatusWithResponse(ctx context.Context, params *GetTelegramConnectStatusParams, reqEditors ...RequestEditorFn) (*GetTelegramConnectStatusResponse, error)

	// CompleteTelegramConnectWithResponse request
	CompleteTelegramConnectWithResponse(ctx context.Context, params *CompleteTelegramConnectParams, reqEditors ...RequestEditorFn) (*CompleteTelegramConnectResponse, error)

	// InitiateTelegramConnectWithBodyWithResponse request with any body
	InitiateTelegramConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateTelegramConnectResponse, error)

	InitiateTelegramConnectWithResponse(ctx context.Context, body InitiateTelegramConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateTelegramConnectResponse, error)

	// GetConnectUrlWithResponse request
	GetConnectUrlWithResponse(ctx context.Context, platform GetConnectUrlParamsPlatform, params *GetConnectUrlParams, reqEditors ...RequestEditorFn) (*GetConnectUrlResponse, error)

	// HandleOAuthCallbackWithBodyWithResponse request with any body
	HandleOAuthCallbackWithBodyWithResponse(ctx context.Context, platform string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandleOAuthCallbackResponse, error)

	HandleOAuthCallbackWithResponse(ctx context.Context, platform string, body HandleOAuthCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*HandleOAuthCallbackResponse, error)

	// ListInboxCommentsWithResponse request
	ListInboxCommentsWithResponse(ctx context.Context, params *ListInboxCommentsParams, reqEditors ...RequestEditorFn) (*ListInboxCommentsResponse, error)

	// DeleteInboxCommentWithResponse request
	DeleteInboxCommentWithResponse(ctx context.Context, postId string, params *DeleteInboxCommentParams, reqEditors ...RequestEditorFn) (*DeleteInboxCommentResponse, error)

	// GetInboxPostCommentsWithResponse request
	GetInboxPostCommentsWithResponse(ctx context.Context, postId string, params *GetInboxPostCommentsParams, reqEditors ...RequestEditorFn) (*GetInboxPostCommentsResponse, error)

	// ReplyToInboxPostWithBodyWithResponse request with any body
	ReplyToInboxPostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplyToInboxPostResponse, error)

	ReplyToInboxPostWithResponse(ctx context.Context, postId string, body ReplyToInboxPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplyToInboxPostResponse, error)

	// UnhideInboxCommentWithResponse request
	UnhideInboxCommentWithResponse(ctx context.Context, postId string, commentId string, params *UnhideInboxCommentParams, reqEditors ...RequestEditorFn) (*UnhideInboxCommentResponse, error)

	// HideInboxCommentWithBodyWithResponse request with any body
	HideInboxCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HideInboxCommentResponse, error)

	HideInboxCommentWithResponse(ctx context.Context, postId string, commentId string, body HideInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*HideInboxCommentResponse, error)

	// UnlikeInboxCommentWithResponse request
	UnlikeInboxCommentWithResponse(ctx context.Context, postId string, commentId string, params *UnlikeInboxCommentParams, reqEditors ...RequestEditorFn) (*UnlikeInboxCommentResponse, error)

	// LikeInboxCommentWithBodyWithResponse request with any body
	LikeInboxCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikeInboxCommentResponse, error)

	LikeInboxCommentWithResponse(ctx context.Context, postId string, commentId string, body LikeInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*LikeInboxCommentResponse, error)

	// SendPrivateReplyToCommentWithBodyWithResponse request with any body
	SendPrivateReplyToCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPrivateReplyToCommentResponse, error)

	SendPrivateReplyToCommentWithResponse(ctx context.Context, postId string, commentId string, body SendPrivateReplyToCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPrivateReplyToCommentResponse, error)

	// ListInboxConversationsWithResponse request
	ListInboxConversationsWithResponse(ctx context.Context, params *ListInboxConversationsParams, reqEditors ...RequestEditorFn) (*ListInboxConversationsResponse, error)

	// GetInboxConversationWithResponse request
	GetInboxConversationWithResponse(ctx context.Context, conversationId string, params *GetInboxConversationParams, reqEditors ...RequestEditorFn) (*GetInboxConversationResponse, error)

	// UpdateInboxConversationWithBodyWithResponse request with any body
	UpdateInboxConversationWithBodyWithResponse(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInboxConversationResponse, error)

	UpdateInboxConversationWithResponse(ctx context.Context, conversationId string, body UpdateInboxConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInboxConversationResponse, error)

	// GetInboxConversationMessagesWithResponse request
	GetInboxConversationMessagesWithResponse(ctx context.Context, conversationId string, params *GetInboxConversationMessagesParams, reqEditors ...RequestEditorFn) (*GetInboxConversationMessagesResponse, error)

	// SendInboxMessageWithBodyWithResponse request with any body
	SendInboxMessageWithBodyWithResponse(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendInboxMessageResponse, error)

	SendInboxMessageWithResponse(ctx context.Context, conversationId string, body SendInboxMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendInboxMessageResponse, error)

	// ListInboxReviewsWithResponse request
	ListInboxReviewsWithResponse(ctx context.Context, params *ListInboxReviewsParams, reqEditors ...RequestEditorFn) (*ListInboxReviewsResponse, error)

	// DeleteInboxReviewReplyWithBodyWithResponse request with any body
	DeleteInboxReviewReplyWithBodyWithResponse(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInboxReviewReplyResponse, error)

	DeleteInboxReviewReplyWithResponse(ctx context.Context, reviewId string, body DeleteInboxReviewReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInboxReviewReplyResponse, error)

	// ReplyToInboxReviewWithBodyWithResponse request with any body
	ReplyToInboxReviewWithBodyWithResponse(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplyToInboxReviewResponse, error)

	ReplyToInboxReviewWithResponse(ctx context.Context, reviewId string, body ReplyToInboxReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplyToInboxReviewResponse, error)

	// CreateInviteTokenWithBodyWithResponse request with any body
	CreateInviteTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInviteTokenResponse, error)

	CreateInviteTokenWithResponse(ctx context.Context, body CreateInviteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInviteTokenResponse, error)

	// ListLogsWithResponse request
	ListLogsWithResponse(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error)

	// GetLogWithResponse request
	GetLogWithResponse(ctx context.Context, logId string, reqEditors ...RequestEditorFn) (*GetLogResponse, error)

	// GetMediaPresignedUrlWithBodyWithResponse request with any body
	GetMediaPresignedUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMediaPresignedUrlResponse, error)

	GetMediaPresignedUrlWithResponse(ctx context.Context, body GetMediaPresignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMediaPresignedUrlResponse, error)

	// ListPostsWithResponse request
	ListPostsWithResponse(ctx context.Context, params *ListPostsParams, reqEditors ...RequestEditorFn) (*ListPostsResponse, error)

	// CreatePostWithBodyWithResponse request with any body
	CreatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResponse, error)

	CreatePostWithResponse(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResponse, error)

	// BulkUploadPostsWithBodyWithResponse request with any body
	BulkUploadPostsWithBodyWithResponse(ctx context.Context, params *BulkUploadPostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPostsResponse, error)

	// DeletePostWithResponse request
	DeletePostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*DeletePostResponse, error)

	// GetPostWithResponse request
	GetPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*GetPostResponse, error)

	// UpdatePostWithBodyWithResponse request with any body
	UpdatePostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error)

	UpdatePostWithResponse(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error)

	// GetPostLogsWithResponse request
	GetPostLogsWithResponse(ctx context.Context, postId string, params *GetPostLogsParams, reqEditors ...RequestEditorFn) (*GetPostLogsResponse, error)

	// RetryPostWithResponse request
	RetryPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*RetryPostResponse, error)

	// ListProfilesWithResponse request
	ListProfilesWithResponse(ctx context.Context, params *ListProfilesParams, reqEditors ...RequestEditorFn) (*ListProfilesResponse, error)

	// CreateProfileWithBodyWithResponse request with any body
	CreateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error)

	CreateProfileWithResponse(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error)

	// DeleteProfileWithResponse request
	DeleteProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*DeleteProfileResponse, error)

	// GetProfileWithResponse request
	GetProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*GetProfileResponse, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithResponse(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// GetNextQueueSlotWithResponse request
	GetNextQueueSlotWithResponse(ctx context.Context, params *GetNextQueueSlotParams, reqEditors ...RequestEditorFn) (*GetNextQueueSlotResponse, error)

	// PreviewQueueWithResponse request
	PreviewQueueWithResponse(ctx context.Context, params *PreviewQueueParams, reqEditors ...RequestEditorFn) (*PreviewQueueResponse, error)

	// DeleteQueueSlotWithResponse request
	DeleteQueueSlotWithResponse(ctx context.Context, params *DeleteQueueSlotParams, reqEditors ...RequestEditorFn) (*DeleteQueueSlotResponse, error)

	// ListQueueSlotsWithResponse request
	ListQueueSlotsWithResponse(ctx context.Context, params *ListQueueSlotsParams, reqEditors ...RequestEditorFn) (*ListQueueSlotsResponse, error)

	// CreateQueueSlotWithBodyWithResponse request with any body
	CreateQueueSlotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQueueSlotResponse, error)

	CreateQueueSlotWithResponse(ctx context.Context, body CreateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQueueSlotResponse, error)

	// UpdateQueueSlotWithBodyWithResponse request with any body
	UpdateQueueSlotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQueueSlotResponse, error)

	UpdateQueueSlotWithResponse(ctx context.Context, body UpdateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQueueSlotResponse, error)

	// GetRedditFeedWithResponse request
	GetRedditFeedWithResponse(ctx context.Context, params *GetRedditFeedParams, reqEditors ...RequestEditorFn) (*GetRedditFeedResponse, error)

	// SearchRedditWithResponse request
	SearchRedditWithResponse(ctx context.Context, params *SearchRedditParams, reqEditors ...RequestEditorFn) (*SearchRedditResponse, error)

	// DownloadBlueskyMediaWithResponse request
	DownloadBlueskyMediaWithResponse(ctx context.Context, params *DownloadBlueskyMediaParams, reqEditors ...RequestEditorFn) (*DownloadBlueskyMediaResponse, error)

	// DownloadFacebookVideoWithResponse request
	DownloadFacebookVideoWithResponse(ctx context.Context, params *DownloadFacebookVideoParams, reqEditors ...RequestEditorFn) (*DownloadFacebookVideoResponse, error)

	// DownloadInstagramMediaWithResponse request
	DownloadInstagramMediaWithResponse(ctx context.Context, params *DownloadInstagramMediaParams, reqEditors ...RequestEditorFn) (*DownloadInstagramMediaResponse, error)

	// CheckInstagramHashtagsWithBodyWithResponse request with any body
	CheckInstagramHashtagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckInstagramHashtagsResponse, error)

	CheckInstagramHashtagsWithResponse(ctx context.Context, body CheckInstagramHashtagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckInstagramHashtagsResponse, error)

	// DownloadLinkedInVideoWithResponse request
	DownloadLinkedInVideoWithResponse(ctx context.Context, params *DownloadLinkedInVideoParams, reqEditors ...RequestEditorFn) (*DownloadLinkedInVideoResponse, error)

	// DownloadTikTokVideoWithResponse request
	DownloadTikTokVideoWithResponse(ctx context.Context, params *DownloadTikTokVideoParams, reqEditors ...RequestEditorFn) (*DownloadTikTokVideoResponse, error)

	// DownloadTwitterMediaWithResponse request
	DownloadTwitterMediaWithResponse(ctx context.Context, params *DownloadTwitterMediaParams, reqEditors ...RequestEditorFn) (*DownloadTwitterMediaResponse, error)

	// DownloadYouTubeVideoWithResponse request
	DownloadYouTubeVideoWithResponse(ctx context.Context, params *DownloadYouTubeVideoParams, reqEditors ...RequestEditorFn) (*DownloadYouTubeVideoResponse, error)

	// GetYouTubeTranscriptWithResponse request
	GetYouTubeTranscriptWithResponse(ctx context.Context, params *GetYouTubeTranscriptParams, reqEditors ...RequestEditorFn) (*GetYouTubeTranscriptResponse, error)

	// GetUsageStatsWithResponse request
	GetUsageStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageStatsResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// GetWebhookLogsWithResponse request
	GetWebhookLogsWithResponse(ctx context.Context, params *GetWebhookLogsParams, reqEditors ...RequestEditorFn) (*GetWebhookLogsResponse, error)

	// DeleteWebhookSettingsWithResponse request
	DeleteWebhookSettingsWithResponse(ctx context.Context, params *DeleteWebhookSettingsParams, reqEditors ...RequestEditorFn) (*DeleteWebhookSettingsResponse, error)

	// GetWebhookSettingsWithResponse request
	GetWebhookSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhookSettingsResponse, error)

	// CreateWebhookSettingsWithBodyWithResponse request with any body
	CreateWebhookSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSettingsResponse, error)

	CreateWebhookSettingsWithResponse(ctx context.Context, body CreateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSettingsResponse, error)

	// UpdateWebhookSettingsWithBodyWithResponse request with any body
	UpdateWebhookSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSettingsResponse, error)

	UpdateWebhookSettingsWithResponse(ctx context.Context, body UpdateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSettingsResponse, error)

	// TestWebhookWithBodyWithResponse request with any body
	TestWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error)

	TestWebhookWithResponse(ctx context.Context, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error)
}

type ListAccountGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Groups *[]struct {
			UnderscoreId *string   `json:"_id,omitempty"`
			AccountIds   *[]string `json:"accountIds,omitempty"`
			Name         *string   `json:"name,omitempty"`
		} `json:"groups,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListAccountGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Group *struct {
			UnderscoreId *string   `json:"_id,omitempty"`
			AccountIds   *[]string `json:"accountIds,omitempty"`
			Name         *string   `json:"name,omitempty"`
		} `json:"group,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateAccountGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteAccountGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Group   *map[string]interface{} `json:"group,omitempty"`
		Message *string                 `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateAccountGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts *[]SocialAccount `json:"accounts,omitempty"`

		// HasAnalyticsAccess Whether user has analytics add-on access
		HasAnalyticsAccess *bool `json:"hasAnalyticsAccess,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowerStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts  *[]AccountWithFollowerStats `json:"accounts,omitempty"`
		DateRange *struct {
			From *time.Time `json:"from,omitempty"`
			To   *time.Time `json:"to,omitempty"`
		} `json:"dateRange,omitempty"`
		Granularity *string `json:"granularity,omitempty"`
		Stats       *map[string][]struct {
			Date      *openapi_types.Date `json:"date,omitempty"`
			Followers *float32            `json:"followers,omitempty"`
		} `json:"stats,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *struct {
		Error         *string `json:"error,omitempty"`
		Message       *string `json:"message,omitempty"`
		RequiresAddon *bool   `json:"requiresAddon,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFollowerStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowerStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccountsHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts *[]struct {
			AccountId         *string                                `json:"accountId,omitempty"`
			CanFetchAnalytics *bool                                  `json:"canFetchAnalytics,omitempty"`
			CanPost           *bool                                  `json:"canPost,omitempty"`
			DisplayName       *string                                `json:"displayName,omitempty"`
			Issues            *[]string                              `json:"issues,omitempty"`
			NeedsReconnect    *bool                                  `json:"needsReconnect,omitempty"`
			Platform          *string                                `json:"platform,omitempty"`
			ProfileId         *string                                `json:"profileId,omitempty"`
			Status            *GetAllAccountsHealth200AccountsStatus `json:"status,omitempty"`
			TokenExpiresAt    *time.Time                             `json:"tokenExpiresAt,omitempty"`
			TokenValid        *bool                                  `json:"tokenValid,omitempty"`
			Username          *string                                `json:"username,omitempty"`
		} `json:"accounts,omitempty"`
		Summary *struct {
			// Error Number of accounts with errors
			Error *int `json:"error,omitempty"`

			// Healthy Number of healthy accounts
			Healthy *int `json:"healthy,omitempty"`

			// NeedsReconnect Number of accounts needing reconnection
			NeedsReconnect *int `json:"needsReconnect,omitempty"`

			// Total Total number of accounts
			Total *int `json:"total,omitempty"`

			// Warning Number of accounts with warnings
			Warning *int `json:"warning,omitempty"`
		} `json:"summary,omitempty"`
	}
	JSON401 *Unauthorized
}
type GetAllAccountsHealth200AccountsStatus string

// Status returns HTTPResponse.Status
func (r GetAllAccountsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccountsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DisplayName *string `json:"displayName,omitempty"`
		Message     *string `json:"message,omitempty"`
		Username    *string `json:"username,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFacebookPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cached *bool `json:"cached,omitempty"`
		Pages  *[]struct {
			Category *string `json:"category,omitempty"`
			FanCount *int    `json:"fan_count,omitempty"`
			Id       *string `json:"id,omitempty"`
			Name     *string `json:"name,omitempty"`
			Username *string `json:"username,omitempty"`
		} `json:"pages,omitempty"`
		SelectedPageId *string `json:"selectedPageId,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetFacebookPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFacebookPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFacebookPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message      *string `json:"message,omitempty"`
		SelectedPage *struct {
			Id   *string `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"selectedPage,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateFacebookPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFacebookPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoogleBusinessAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string `json:"accountId,omitempty"`
		Attributes *[]struct {
			// Name Attribute identifier (e.g. has_delivery)
			Name              *string `json:"name,omitempty"`
			RepeatedEnumValue *struct {
				SetValues   *[]string `json:"setValues,omitempty"`
				UnsetValues *[]string `json:"unsetValues,omitempty"`
			} `json:"repeatedEnumValue,omitempty"`

			// ValueType Value type (BOOL, ENUM, URL, REPEATED_ENUM)
			ValueType *string        `json:"valueType,omitempty"`
			Values    *[]interface{} `json:"values,omitempty"`
		} `json:"attributes,omitempty"`
		LocationId *string `json:"locationId,omitempty"`
		Success    *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetGoogleBusinessAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoogleBusinessAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGoogleBusinessAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string                   `json:"accountId,omitempty"`
		Attributes *[]map[string]interface{} `json:"attributes,omitempty"`
		LocationId *string                   `json:"locationId,omitempty"`
		Success    *bool                     `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateGoogleBusinessAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGoogleBusinessAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoogleBusinessFoodMenusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string     `json:"accountId,omitempty"`
		LocationId *string     `json:"locationId,omitempty"`
		Menus      *[]FoodMenu `json:"menus,omitempty"`

		// Name Resource name of the food menus
		Name    *string `json:"name,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *NotFound
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetGoogleBusinessFoodMenusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoogleBusinessFoodMenusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGoogleBusinessFoodMenusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string     `json:"accountId,omitempty"`
		LocationId *string     `json:"locationId,omitempty"`
		Menus      *[]FoodMenu `json:"menus,omitempty"`
		Name       *string     `json:"name,omitempty"`
		Success    *bool       `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *NotFound
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateGoogleBusinessFoodMenusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGoogleBusinessFoodMenusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoogleBusinessLocationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId    *string `json:"accountId,omitempty"`
		LocationId   *string `json:"locationId,omitempty"`
		PhoneNumbers *struct {
			AdditionalPhones *[]string `json:"additionalPhones,omitempty"`
			PrimaryPhone     *string   `json:"primaryPhone,omitempty"`
		} `json:"phoneNumbers,omitempty"`
		Profile *struct {
			// Description Business description
			Description *string `json:"description,omitempty"`
		} `json:"profile,omitempty"`
		RegularHours *struct {
			Periods *[]struct {
				CloseDay  *string                                                        `json:"closeDay,omitempty"`
				CloseTime *string                                                        `json:"closeTime,omitempty"`
				OpenDay   *GetGoogleBusinessLocationDetails200RegularHoursPeriodsOpenDay `json:"openDay,omitempty"`

				// OpenTime Opening time in HH:MM format
				OpenTime *string `json:"openTime,omitempty"`
			} `json:"periods,omitempty"`
		} `json:"regularHours,omitempty"`
		SpecialHours *struct {
			SpecialHourPeriods *[]struct {
				CloseTime *string `json:"closeTime,omitempty"`
				Closed    *bool   `json:"closed,omitempty"`
				EndDate   *struct {
					Day   *int `json:"day,omitempty"`
					Month *int `json:"month,omitempty"`
					Year  *int `json:"year,omitempty"`
				} `json:"endDate,omitempty"`
				OpenTime  *string `json:"openTime,omitempty"`
				StartDate *struct {
					Day   *int `json:"day,omitempty"`
					Month *int `json:"month,omitempty"`
					Year  *int `json:"year,omitempty"`
				} `json:"startDate,omitempty"`
			} `json:"specialHourPeriods,omitempty"`
		} `json:"specialHours,omitempty"`
		Success *bool `json:"success,omitempty"`

		// Title Business name
		Title      *string `json:"title,omitempty"`
		WebsiteUri *string `json:"websiteUri,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *NotFound
}
type GetGoogleBusinessLocationDetails200RegularHoursPeriodsOpenDay string

// Status returns HTTPResponse.Status
func (r GetGoogleBusinessLocationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoogleBusinessLocationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGoogleBusinessLocationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string `json:"accountId,omitempty"`
		LocationId *string `json:"locationId,omitempty"`
		Success    *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateGoogleBusinessLocationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGoogleBusinessLocationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGmbLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Cached    *bool `json:"cached,omitempty"`
		Locations *[]struct {
			AccountId   *string `json:"accountId,omitempty"`
			AccountName *string `json:"accountName,omitempty"`
			Address     *string `json:"address,omitempty"`
			Category    *string `json:"category,omitempty"`
			Id          *string `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
			WebsiteUrl  *string `json:"websiteUrl,omitempty"`
		} `json:"locations,omitempty"`
		SelectedLocationId *string `json:"selectedLocationId,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetGmbLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGmbLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGmbLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message          *string `json:"message,omitempty"`
		SelectedLocation *struct {
			Id   *string `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"selectedLocation,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateGmbLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGmbLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGoogleBusinessMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deleted *bool   `json:"deleted,omitempty"`
		MediaId *string `json:"mediaId,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteGoogleBusinessMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGoogleBusinessMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGoogleBusinessMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId  *string `json:"accountId,omitempty"`
		LocationId *string `json:"locationId,omitempty"`
		MediaItems *[]struct {
			CreateTime  *time.Time `json:"createTime,omitempty"`
			Description *string    `json:"description,omitempty"`

			// GoogleUrl Google-hosted URL
			GoogleUrl           *string `json:"googleUrl,omitempty"`
			LocationAssociation *struct {
				Category *string `json:"category,omitempty"`
			} `json:"locationAssociation,omitempty"`
			MediaFormat *ListGoogleBusinessMedia200MediaItemsMediaFormat `json:"mediaFormat,omitempty"`

			// Name Resource name
			Name         *string `json:"name,omitempty"`
			SourceUrl    *string `json:"sourceUrl,omitempty"`
			ThumbnailUrl *string `json:"thumbnailUrl,omitempty"`
		} `json:"mediaItems,omitempty"`
		NextPageToken        *string `json:"nextPageToken,omitempty"`
		Success              *bool   `json:"success,omitempty"`
		TotalMediaItemsCount *int    `json:"totalMediaItemsCount,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}
type ListGoogleBusinessMedia200MediaItemsMediaFormat string

// Status returns HTTPResponse.Status
func (r ListGoogleBusinessMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGoogleBusinessMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGoogleBusinessMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		GoogleUrl   *string `json:"googleUrl,omitempty"`
		MediaFormat *string `json:"mediaFormat,omitempty"`
		Name        *string `json:"name,omitempty"`
		Success     *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateGoogleBusinessMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGoogleBusinessMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGoogleBusinessPlaceActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deleted *bool   `json:"deleted,omitempty"`
		Name    *string `json:"name,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteGoogleBusinessPlaceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGoogleBusinessPlaceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGoogleBusinessPlaceActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId        *string `json:"accountId,omitempty"`
		LocationId       *string `json:"locationId,omitempty"`
		NextPageToken    *string `json:"nextPageToken,omitempty"`
		PlaceActionLinks *[]struct {
			CreateTime *time.Time `json:"createTime,omitempty"`

			// Name Resource name
			Name            *string    `json:"name,omitempty"`
			PlaceActionType *string    `json:"placeActionType,omitempty"`
			UpdateTime      *time.Time `json:"updateTime,omitempty"`

			// Uri Action URL
			Uri *string `json:"uri,omitempty"`
		} `json:"placeActionLinks,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListGoogleBusinessPlaceActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGoogleBusinessPlaceActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGoogleBusinessPlaceActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Name Resource name of the created link
		Name            *string `json:"name,omitempty"`
		PlaceActionType *string `json:"placeActionType,omitempty"`
		Success         *bool   `json:"success,omitempty"`
		Uri             *string `json:"uri,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateGoogleBusinessPlaceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGoogleBusinessPlaceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoogleBusinessReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId *string `json:"accountId,omitempty"`

		// AverageRating Overall average rating
		AverageRating *float32 `json:"averageRating,omitempty"`
		LocationId    *string  `json:"locationId,omitempty"`

		// NextPageToken Token for next page
		NextPageToken *string `json:"nextPageToken"`
		Reviews       *[]struct {
			// Comment Review text
			Comment    *string    `json:"comment,omitempty"`
			CreateTime *time.Time `json:"createTime,omitempty"`

			// Id Review ID
			Id *string `json:"id,omitempty"`

			// Name Full resource name
			Name *string `json:"name,omitempty"`

			// Rating Numeric star rating
			Rating      *int `json:"rating,omitempty"`
			ReviewReply *struct {
				// Comment Business owner reply
				Comment    *string    `json:"comment,omitempty"`
				UpdateTime *time.Time `json:"updateTime,omitempty"`
			} `json:"reviewReply"`
			Reviewer *struct {
				DisplayName     *string `json:"displayName,omitempty"`
				IsAnonymous     *bool   `json:"isAnonymous,omitempty"`
				ProfilePhotoUrl *string `json:"profilePhotoUrl"`
			} `json:"reviewer,omitempty"`

			// StarRating Google's string rating
			StarRating *GetGoogleBusinessReviews200ReviewsStarRating `json:"starRating,omitempty"`
			UpdateTime *time.Time                                    `json:"updateTime,omitempty"`
		} `json:"reviews,omitempty"`
		Success *bool `json:"success,omitempty"`

		// TotalReviewCount Total number of reviews
		TotalReviewCount *int `json:"totalReviewCount,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *NotFound
	JSON500 *ErrorResponse
}
type GetGoogleBusinessReviews200ReviewsStarRating string

// Status returns HTTPResponse.Status
func (r GetGoogleBusinessReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoogleBusinessReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId   *string `json:"accountId,omitempty"`
		DisplayName *string `json:"displayName,omitempty"`

		// Issues List of issues found
		Issues      *[]string `json:"issues,omitempty"`
		Permissions *struct {
			Analytics *[]struct {
				Granted  *bool   `json:"granted,omitempty"`
				Required *bool   `json:"required,omitempty"`
				Scope    *string `json:"scope,omitempty"`
			} `json:"analytics,omitempty"`
			CanFetchAnalytics *bool     `json:"canFetchAnalytics,omitempty"`
			CanPost           *bool     `json:"canPost,omitempty"`
			MissingRequired   *[]string `json:"missingRequired,omitempty"`
			Optional          *[]struct {
				Granted  *bool   `json:"granted,omitempty"`
				Required *bool   `json:"required,omitempty"`
				Scope    *string `json:"scope,omitempty"`
			} `json:"optional,omitempty"`
			Posting *[]struct {
				Granted  *bool   `json:"granted,omitempty"`
				Required *bool   `json:"required,omitempty"`
				Scope    *string `json:"scope,omitempty"`
			} `json:"posting,omitempty"`
		} `json:"permissions,omitempty"`
		Platform *string `json:"platform,omitempty"`

		// Recommendations Actionable recommendations to fix issues
		Recommendations *[]string `json:"recommendations,omitempty"`

		// Status Overall health status
		Status      *GetAccountHealth200Status `json:"status,omitempty"`
		TokenStatus *struct {
			ExpiresAt *time.Time `json:"expiresAt,omitempty"`

			// ExpiresIn Human-readable time until expiry
			ExpiresIn *string `json:"expiresIn,omitempty"`

			// NeedsRefresh Whether token expires within 24 hours
			NeedsRefresh *bool `json:"needsRefresh,omitempty"`

			// Valid Whether the token is valid
			Valid *bool `json:"valid,omitempty"`
		} `json:"tokenStatus,omitempty"`
		Username *string `json:"username,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}
type GetAccountHealth200Status string

// Status returns HTTPResponse.Status
func (r GetAccountHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkedInAggregateAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *struct {
		Code         *string   `json:"code,omitempty"`
		Error        *string   `json:"error,omitempty"`
		ValidOptions *[]string `json:"validOptions,omitempty"`
	}
	JSON401 *Unauthorized
	JSON402 *struct {
		Code  *string `json:"code,omitempty"`
		Error *string `json:"error,omitempty"`
	}
	JSON403 *struct {
		Action        *string `json:"action,omitempty"`
		Code          *string `json:"code,omitempty"`
		Error         *string `json:"error,omitempty"`
		RequiredScope *string `json:"requiredScope,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLinkedInAggregateAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkedInAggregateAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkedInMentionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DisplayName Display name (provided, from API, or derived from vanity URL)
		DisplayName *string `json:"displayName,omitempty"`

		// MentionFormat Ready-to-use mention format for post content
		MentionFormat *string `json:"mentionFormat,omitempty"`

		// Type The type of entity (person or organization)
		Type *GetLinkedInMentions200Type `json:"type,omitempty"`

		// Urn The LinkedIn URN (person or organization)
		Urn *string `json:"urn,omitempty"`

		// VanityName The vanity name/slug (only for organization mentions)
		VanityName *string `json:"vanityName,omitempty"`

		// Warning Warning about clickable mentions (only present for person mentions if displayName was not provided)
		Warning *string `json:"warning,omitempty"`
	}
	JSON400 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *struct {
		Error *string `json:"error,omitempty"`
	}
}
type GetLinkedInMentions200Type string

// Status returns HTTPResponse.Status
func (r GetLinkedInMentionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkedInMentionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLinkedInOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *SocialAccount `json:"account,omitempty"`
		Message *string        `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateLinkedInOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLinkedInOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkedInOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Organizations *[]struct {
			Id            *string `json:"id,omitempty"`
			LocalizedName *string `json:"localizedName,omitempty"`
			Name          *string `json:"name,omitempty"`
			VanityName    *string `json:"vanityName,omitempty"`
		} `json:"organizations,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetLinkedInOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkedInOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkedInPostAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId   *string                                 `json:"accountId,omitempty"`
		AccountType *GetLinkedInPostAnalytics200AccountType `json:"accountType,omitempty"`
		Analytics   *struct {
			// Clicks Clicks on the post (organization accounts only)
			Clicks *int `json:"clicks,omitempty"`

			// Comments Comments on the post
			Comments *int `json:"comments,omitempty"`

			// EngagementRate Engagement rate as percentage
			EngagementRate *float32 `json:"engagementRate,omitempty"`

			// Impressions Times the post was shown
			Impressions *int `json:"impressions,omitempty"`

			// Likes Reactions on the post
			Likes *int `json:"likes,omitempty"`

			// Reach Unique members who saw the post
			Reach *int `json:"reach,omitempty"`

			// Shares Reshares of the post
			Shares *int `json:"shares,omitempty"`

			// Views Video views (video posts only)
			Views *int `json:"views,omitempty"`
		} `json:"analytics,omitempty"`
		LastUpdated *time.Time `json:"lastUpdated,omitempty"`
		Platform    *string    `json:"platform,omitempty"`
		PostUrn     *string    `json:"postUrn,omitempty"`
		Username    *string    `json:"username,omitempty"`
	}
	JSON400 *struct {
		Code  *GetLinkedInPostAnalytics400Code `json:"code,omitempty"`
		Error *string                          `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *struct {
		Action        *string `json:"action,omitempty"`
		Code          *string `json:"code,omitempty"`
		Error         *string `json:"error,omitempty"`
		RequiredScope *string `json:"requiredScope,omitempty"`
	}
	JSON404 *struct {
		Code  *string `json:"code,omitempty"`
		Error *string `json:"error,omitempty"`
	}
}
type GetLinkedInPostAnalytics200AccountType string
type GetLinkedInPostAnalytics400Code string

// Status returns HTTPResponse.Status
func (r GetLinkedInPostAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkedInPostAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPinterestBoardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Boards *[]struct {
			Description *string `json:"description,omitempty"`
			Id          *string `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
			Privacy     *string `json:"privacy,omitempty"`
		} `json:"boards,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetPinterestBoardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPinterestBoardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePinterestBoardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *SocialAccount `json:"account,omitempty"`
		Message *string        `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdatePinterestBoardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePinterestBoardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRedditSubredditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DefaultSubreddit Currently set default subreddit for posting
		DefaultSubreddit *string `json:"defaultSubreddit,omitempty"`
		Subreddits       *[]struct {
			// Id Reddit subreddit ID
			Id *string `json:"id,omitempty"`

			// Name Subreddit name without r/ prefix
			Name *string `json:"name,omitempty"`

			// Over18 Whether the subreddit is NSFW
			Over18 *bool `json:"over18,omitempty"`

			// Title Subreddit title
			Title *string `json:"title,omitempty"`

			// Url Subreddit URL path
			Url *string `json:"url,omitempty"`
		} `json:"subreddits,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetRedditSubredditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRedditSubredditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRedditSubredditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateRedditSubredditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRedditSubredditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON401 *Unauthorized
	JSON402 *struct {
		Code  *string `json:"code,omitempty"`
		Error *string `json:"error,omitempty"`
	}
	JSON404 *NotFound
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetYouTubeDailyViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *YouTubeDailyViewsResponse
	JSON400      *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
	JSON402 *struct {
		Code  *string `json:"code,omitempty"`
		Error *string `json:"error,omitempty"`
	}
	JSON403 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON412 *YouTubeScopeMissingResponse
	JSON500 *struct {
		Error   *string `json:"error,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetYouTubeDailyViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetYouTubeDailyViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ApiKeys *[]ApiKey `json:"apiKeys,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		ApiKey  *ApiKey `json:"apiKey,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectBlueskyCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *SocialAccount `json:"account,omitempty"`
		Message *string        `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ConnectBlueskyCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectBlueskyCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFacebookPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Pages *[]struct {
			// AccessToken Page-specific access token
			AccessToken *string `json:"access_token,omitempty"`

			// Category Page category
			Category *string `json:"category,omitempty"`

			// Id Facebook Page ID
			Id *string `json:"id,omitempty"`

			// Name Page name
			Name *string `json:"name,omitempty"`

			// Tasks User permissions for this page
			Tasks *[]string `json:"tasks,omitempty"`

			// Username Page username/handle (may be null)
			Username *string `json:"username,omitempty"`
		} `json:"pages,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFacebookPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFacebookPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectFacebookPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			// AccountId ID of the created SocialAccount
			AccountId        *string                               `json:"accountId,omitempty"`
			DisplayName      *string                               `json:"displayName,omitempty"`
			IsActive         *bool                                 `json:"isActive,omitempty"`
			Platform         *SelectFacebookPage200AccountPlatform `json:"platform,omitempty"`
			ProfilePicture   *string                               `json:"profilePicture,omitempty"`
			SelectedPageName *string                               `json:"selectedPageName,omitempty"`
			Username         *string                               `json:"username,omitempty"`
		} `json:"account,omitempty"`
		Message *string `json:"message,omitempty"`

		// RedirectUrl Redirect URL if custom redirect_url was provided
		RedirectUrl *string `json:"redirect_url,omitempty"`
	}
	JSON401 *Unauthorized
}
type SelectFacebookPage200AccountPlatform string

// Status returns HTTPResponse.Status
func (r SelectFacebookPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectFacebookPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGoogleBusinessLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Locations *[]struct {
			// AccountId Google Business Account ID
			AccountId *string `json:"accountId,omitempty"`

			// AccountName Account name
			AccountName *string `json:"accountName,omitempty"`

			// Address Business address
			Address *string `json:"address,omitempty"`

			// Category Business category
			Category *string `json:"category,omitempty"`

			// Id Location ID
			Id *string `json:"id,omitempty"`

			// Name Business name
			Name *string `json:"name,omitempty"`
		} `json:"locations,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGoogleBusinessLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGoogleBusinessLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectGoogleBusinessLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			// AccountId ID of the created SocialAccount
			AccountId            *string                                         `json:"accountId,omitempty"`
			DisplayName          *string                                         `json:"displayName,omitempty"`
			IsActive             *bool                                           `json:"isActive,omitempty"`
			Platform             *SelectGoogleBusinessLocation200AccountPlatform `json:"platform,omitempty"`
			SelectedLocationId   *string                                         `json:"selectedLocationId,omitempty"`
			SelectedLocationName *string                                         `json:"selectedLocationName,omitempty"`
			Username             *string                                         `json:"username,omitempty"`
		} `json:"account,omitempty"`
		Message *string `json:"message,omitempty"`

		// RedirectUrl Redirect URL if custom redirect_url was provided
		RedirectUrl *string `json:"redirect_url,omitempty"`
	}
	JSON401 *Unauthorized
}
type SelectGoogleBusinessLocation200AccountPlatform string

// Status returns HTTPResponse.Status
func (r SelectGoogleBusinessLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectGoogleBusinessLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinkedInOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Organizations *[]struct {
			// Description Organization's description
			Description *string `json:"description,omitempty"`

			// Id Organization ID
			Id *string `json:"id,omitempty"`

			// Industry Organization's primary industry
			Industry *string `json:"industry,omitempty"`

			// LogoUrl Logo URL (may be absent if no logo)
			LogoUrl *string `json:"logoUrl,omitempty"`

			// VanityName Organization's vanity name/slug
			VanityName *string `json:"vanityName,omitempty"`

			// Website Organization's website URL
			Website *string `json:"website,omitempty"`
		} `json:"organizations,omitempty"`
	}
	JSON400 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListLinkedInOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinkedInOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectLinkedInOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			// AccountId ID of the created SocialAccount
			AccountId      *string                                          `json:"accountId,omitempty"`
			AccountType    *SelectLinkedInOrganization200AccountAccountType `json:"accountType,omitempty"`
			DisplayName    *string                                          `json:"displayName,omitempty"`
			IsActive       *bool                                            `json:"isActive,omitempty"`
			Platform       *SelectLinkedInOrganization200AccountPlatform    `json:"platform,omitempty"`
			ProfilePicture *string                                          `json:"profilePicture,omitempty"`
			Username       *string                                          `json:"username,omitempty"`
		} `json:"account,omitempty"`
		BulkRefresh *struct {
			Errors       *int `json:"errors,omitempty"`
			UpdatedCount *int `json:"updatedCount,omitempty"`
		} `json:"bulkRefresh,omitempty"`
		Message *string `json:"message,omitempty"`

		// RedirectUrl The redirect URL with connection params appended (only if redirect_url was provided in request)
		RedirectUrl *string `json:"redirect_url,omitempty"`
	}
	JSON401 *Unauthorized
}
type SelectLinkedInOrganization200AccountAccountType string
type SelectLinkedInOrganization200AccountPlatform string

// Status returns HTTPResponse.Status
func (r SelectLinkedInOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectLinkedInOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingOAuthDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExpiresIn Token expiry in seconds
		ExpiresIn *float32 `json:"expiresIn,omitempty"`

		// Organizations LinkedIn organizations (when selectionType is "organizations")
		Organizations *[]struct {
			Id         *string `json:"id,omitempty"`
			Name       *string `json:"name,omitempty"`
			Urn        *string `json:"urn,omitempty"`
			VanityName *string `json:"vanityName,omitempty"`
		} `json:"organizations,omitempty"`

		// Platform The platform (e.g., "linkedin")
		Platform *string `json:"platform,omitempty"`

		// ProfileId The Late profile ID
		ProfileId *string `json:"profileId,omitempty"`

		// RefreshToken Refresh token (if available)
		RefreshToken *string `json:"refreshToken,omitempty"`

		// SelectionType Type of selection data
		SelectionType *GetPendingOAuthData200SelectionType `json:"selectionType,omitempty"`

		// TempToken Temporary access token for the platform
		TempToken *string `json:"tempToken,omitempty"`

		// UserProfile User profile data (id, username, displayName, profilePicture)
		UserProfile *map[string]interface{} `json:"userProfile,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON404 *ErrorResponse
}
type GetPendingOAuthData200SelectionType string

// Status returns HTTPResponse.Status
func (r GetPendingOAuthDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingOAuthDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPinterestBoardsForSelectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Boards *[]struct {
			// Description Board description
			Description *string `json:"description,omitempty"`

			// Id Pinterest Board ID
			Id *string `json:"id,omitempty"`

			// Name Board name
			Name *string `json:"name,omitempty"`

			// Privacy Board privacy setting
			Privacy *string `json:"privacy,omitempty"`
		} `json:"boards,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPinterestBoardsForSelectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPinterestBoardsForSelectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectPinterestBoardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			// AccountId ID of the created SocialAccount
			AccountId        *string                                 `json:"accountId,omitempty"`
			DefaultBoardName *string                                 `json:"defaultBoardName,omitempty"`
			DisplayName      *string                                 `json:"displayName,omitempty"`
			IsActive         *bool                                   `json:"isActive,omitempty"`
			Platform         *SelectPinterestBoard200AccountPlatform `json:"platform,omitempty"`
			ProfilePicture   *string                                 `json:"profilePicture,omitempty"`
			Username         *string                                 `json:"username,omitempty"`
		} `json:"account,omitempty"`
		Message *string `json:"message,omitempty"`

		// RedirectUrl Redirect URL with connection params (if provided)
		RedirectUrl *string `json:"redirect_url,omitempty"`
	}
	JSON401 *Unauthorized
}
type SelectPinterestBoard200AccountPlatform string

// Status returns HTTPResponse.Status
func (r SelectPinterestBoardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectPinterestBoardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSnapchatProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PublicProfiles *[]struct {
			// DisplayName Public profile display name
			DisplayName *string `json:"display_name,omitempty"`

			// Id Snapchat Public Profile ID
			Id *string `json:"id,omitempty"`

			// ProfileImageUrl Profile image URL
			ProfileImageUrl *string `json:"profile_image_url,omitempty"`

			// SubscriberCount Number of subscribers
			SubscriberCount *int `json:"subscriber_count,omitempty"`

			// Username Public profile username/handle
			Username *string `json:"username,omitempty"`
		} `json:"publicProfiles,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListSnapchatProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSnapchatProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectSnapchatProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			// AccountId ID of the created SocialAccount
			AccountId         *string                                  `json:"accountId,omitempty"`
			DisplayName       *string                                  `json:"displayName,omitempty"`
			IsActive          *bool                                    `json:"isActive,omitempty"`
			Platform          *SelectSnapchatProfile200AccountPlatform `json:"platform,omitempty"`
			ProfilePicture    *string                                  `json:"profilePicture,omitempty"`
			PublicProfileName *string                                  `json:"publicProfileName,omitempty"`
			Username          *string                                  `json:"username,omitempty"`
		} `json:"account,omitempty"`
		Message *string `json:"message,omitempty"`

		// RedirectUrl Redirect URL with connection params (if provided in request)
		RedirectUrl *string `json:"redirect_url,omitempty"`
	}
	JSON401 *Unauthorized
}
type SelectSnapchatProfile200AccountPlatform string

// Status returns HTTPResponse.Status
func (r SelectSnapchatProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectSnapchatProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTelegramConnectStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BotUsername The Telegram bot username to message
		BotUsername *string `json:"botUsername,omitempty"`

		// Code The access code to send to the Telegram bot
		Code *string `json:"code,omitempty"`

		// ExpiresAt When the code expires
		ExpiresAt *time.Time `json:"expiresAt,omitempty"`

		// ExpiresIn Seconds until expiration
		ExpiresIn *int `json:"expiresIn,omitempty"`

		// Instructions Step-by-step connection instructions
		Instructions *[]string `json:"instructions,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetTelegramConnectStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTelegramConnectStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteTelegramConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON401 *Unauthorized
}
type CompleteTelegramConnect2000 struct {
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// ExpiresIn Seconds until expiration
	ExpiresIn *int                               `json:"expiresIn,omitempty"`
	Status    *CompleteTelegramConnect2000Status `json:"status,omitempty"`
}
type CompleteTelegramConnect2000Status string
type CompleteTelegramConnect2001 struct {
	Account *struct {
		UnderscoreId *string `json:"_id,omitempty"`
		DisplayName  *string `json:"displayName,omitempty"`
		Platform     *string `json:"platform,omitempty"`
		Username     *string `json:"username,omitempty"`
	} `json:"account,omitempty"`
	ChatId    *string                              `json:"chatId,omitempty"`
	ChatTitle *string                              `json:"chatTitle,omitempty"`
	ChatType  *CompleteTelegramConnect2001ChatType `json:"chatType,omitempty"`
	Status    *CompleteTelegramConnect2001Status   `json:"status,omitempty"`
}
type CompleteTelegramConnect2001ChatType string
type CompleteTelegramConnect2001Status string
type CompleteTelegramConnect2002 struct {
	Message *string                            `json:"message,omitempty"`
	Status  *CompleteTelegramConnect2002Status `json:"status,omitempty"`
}
type CompleteTelegramConnect2002Status string

// Status returns HTTPResponse.Status
func (r CompleteTelegramConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteTelegramConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateTelegramConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Account *struct {
			UnderscoreId *string                                    `json:"_id,omitempty"`
			ChatType     *InitiateTelegramConnect200AccountChatType `json:"chatType,omitempty"`
			DisplayName  *string                                    `json:"displayName,omitempty"`
			IsActive     *bool                                      `json:"isActive,omitempty"`
			Platform     *InitiateTelegramConnect200AccountPlatform `json:"platform,omitempty"`
			Username     *string                                    `json:"username,omitempty"`
		} `json:"account,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
}
type InitiateTelegramConnect200AccountChatType string
type InitiateTelegramConnect200AccountPlatform string

// Status returns HTTPResponse.Status
func (r InitiateTelegramConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateTelegramConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AuthUrl URL to redirect your user to for OAuth authorization
		AuthUrl *string `json:"authUrl,omitempty"`

		// State State parameter for security (handled automatically)
		State *string `json:"state,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetConnectUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HandleOAuthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r HandleOAuthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandleOAuthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboxCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AccountId       *string `json:"accountId,omitempty"`
			AccountUsername *string `json:"accountUsername,omitempty"`

			// Cid Bluesky content identifier
			Cid          *string    `json:"cid"`
			CommentCount *int       `json:"commentCount,omitempty"`
			Content      *string    `json:"content,omitempty"`
			CreatedTime  *time.Time `json:"createdTime,omitempty"`
			Id           *string    `json:"id,omitempty"`
			LikeCount    *int       `json:"likeCount,omitempty"`
			Permalink    *string    `json:"permalink"`
			Picture      *string    `json:"picture"`
			Platform     *string    `json:"platform,omitempty"`

			// Subreddit Reddit subreddit name
			Subreddit *string `json:"subreddit"`
		} `json:"data,omitempty"`
		Meta *struct {
			AccountsFailed  *int `json:"accountsFailed,omitempty"`
			AccountsQueried *int `json:"accountsQueried,omitempty"`
			FailedAccounts  *[]struct {
				AccountId       *string `json:"accountId,omitempty"`
				AccountUsername *string `json:"accountUsername"`

				// Code Error code if available
				Code     *string `json:"code"`
				Error    *string `json:"error,omitempty"`
				Platform *string `json:"platform,omitempty"`

				// RetryAfter Seconds to wait before retry (rate limits)
				RetryAfter *int `json:"retryAfter"`
			} `json:"failedAccounts,omitempty"`
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
		} `json:"meta,omitempty"`
		Pagination *struct {
			HasMore    *bool   `json:"hasMore,omitempty"`
			NextCursor *string `json:"nextCursor"`
		} `json:"pagination,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListInboxCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboxCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInboxCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Message *string `json:"message,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteInboxCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInboxCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboxPostCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments *[]struct {
			CanDelete *bool `json:"canDelete,omitempty"`

			// CanHide Whether this comment can be hidden (Facebook
			CanHide *bool `json:"canHide,omitempty"`

			// CanLike Whether this comment can be liked (Facebook
			CanLike  *bool `json:"canLike,omitempty"`
			CanReply *bool `json:"canReply,omitempty"`

			// Cid Bluesky content identifier
			Cid         *string    `json:"cid"`
			CreatedTime *time.Time `json:"createdTime,omitempty"`
			From        *struct {
				Id       *string `json:"id,omitempty"`
				IsOwner  *bool   `json:"isOwner,omitempty"`
				Name     *string `json:"name,omitempty"`
				Picture  *string `json:"picture"`
				Username *string `json:"username,omitempty"`
			} `json:"from,omitempty"`
			Id *string `json:"id,omitempty"`

			// IsHidden Whether the comment is currently hidden
			IsHidden *bool `json:"isHidden,omitempty"`

			// IsLiked Whether the current user has liked this comment
			IsLiked   *bool `json:"isLiked,omitempty"`
			LikeCount *int  `json:"likeCount,omitempty"`

			// LikeUri Bluesky like URI for unliking
			LikeUri *string `json:"likeUri"`
			Message *string `json:"message,omitempty"`

			// ParentId Parent comment ID for nested replies
			ParentId *string `json:"parentId"`

			// Platform The platform this comment is from
			Platform   *string                   `json:"platform,omitempty"`
			Replies    *[]map[string]interface{} `json:"replies,omitempty"`
			ReplyCount *int                      `json:"replyCount,omitempty"`

			// RootCid Bluesky root post CID
			RootCid *string `json:"rootCid"`

			// RootUri Bluesky root post URI
			RootUri *string `json:"rootUri"`

			// Url Direct link to the comment on the platform (if available)
			Url *string `json:"url"`
		} `json:"comments,omitempty"`
		Meta *struct {
			AccountId   *string    `json:"accountId,omitempty"`
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			Platform    *string    `json:"platform,omitempty"`
			PostId      *string    `json:"postId,omitempty"`

			// Subreddit (Reddit only) Subreddit name
			Subreddit *string `json:"subreddit"`
		} `json:"meta,omitempty"`
		Pagination *struct {
			Cursor  *string `json:"cursor"`
			HasMore *bool   `json:"hasMore,omitempty"`
		} `json:"pagination,omitempty"`
		Status *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetInboxPostCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboxPostCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplyToInboxPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Cid Bluesky CID
			Cid       *string `json:"cid"`
			CommentId *string `json:"commentId,omitempty"`
			IsReply   *bool   `json:"isReply,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ReplyToInboxPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplyToInboxPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnhideInboxCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CommentId *string `json:"commentId,omitempty"`
		Hidden    *bool   `json:"hidden,omitempty"`
		Platform  *string `json:"platform,omitempty"`
		Status    *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UnhideInboxCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnhideInboxCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HideInboxCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CommentId *string `json:"commentId,omitempty"`
		Hidden    *bool   `json:"hidden,omitempty"`
		Platform  *string `json:"platform,omitempty"`
		Status    *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r HideInboxCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HideInboxCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlikeInboxCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CommentId *string `json:"commentId,omitempty"`
		Liked     *bool   `json:"liked,omitempty"`
		Platform  *string `json:"platform,omitempty"`
		Status    *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UnlikeInboxCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlikeInboxCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LikeInboxCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CommentId *string `json:"commentId,omitempty"`

		// LikeUri (Bluesky only) URI to use for unliking
		LikeUri  *string `json:"likeUri,omitempty"`
		Liked    *bool   `json:"liked,omitempty"`
		Platform *string `json:"platform,omitempty"`
		Status   *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r LikeInboxCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LikeInboxCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPrivateReplyToCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CommentId The comment ID that was replied to
		CommentId *string `json:"commentId,omitempty"`

		// MessageId The ID of the sent message
		MessageId *string `json:"messageId,omitempty"`
		Platform  *string `json:"platform,omitempty"`
		Status    *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		Code  *SendPrivateReplyToComment400Code `json:"code,omitempty"`
		Error *string                           `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
}
type SendPrivateReplyToComment400Code string

// Status returns HTTPResponse.Status
func (r SendPrivateReplyToCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPrivateReplyToCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboxConversationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AccountId          *string                              `json:"accountId,omitempty"`
			AccountUsername    *string                              `json:"accountUsername,omitempty"`
			Id                 *string                              `json:"id,omitempty"`
			LastMessage        *string                              `json:"lastMessage,omitempty"`
			ParticipantId      *string                              `json:"participantId,omitempty"`
			ParticipantName    *string                              `json:"participantName,omitempty"`
			ParticipantPicture *string                              `json:"participantPicture"`
			Platform           *string                              `json:"platform,omitempty"`
			Status             *ListInboxConversations200DataStatus `json:"status,omitempty"`

			// UnreadCount Number of unread messages
			UnreadCount *int       `json:"unreadCount"`
			UpdatedTime *time.Time `json:"updatedTime,omitempty"`

			// Url Direct link to open the conversation on the platform (if available)
			Url *string `json:"url"`
		} `json:"data,omitempty"`
		Meta *struct {
			AccountsFailed  *int `json:"accountsFailed,omitempty"`
			AccountsQueried *int `json:"accountsQueried,omitempty"`
			FailedAccounts  *[]struct {
				AccountId       *string `json:"accountId,omitempty"`
				AccountUsername *string `json:"accountUsername"`

				// Code Error code if available
				Code     *string `json:"code"`
				Error    *string `json:"error,omitempty"`
				Platform *string `json:"platform,omitempty"`

				// RetryAfter Seconds to wait before retry (rate limits)
				RetryAfter *int `json:"retryAfter"`
			} `json:"failedAccounts,omitempty"`
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
		} `json:"meta,omitempty"`
		Pagination *struct {
			HasMore    *bool   `json:"hasMore,omitempty"`
			NextCursor *string `json:"nextCursor"`
		} `json:"pagination,omitempty"`
	}
	JSON401 *Unauthorized
}
type ListInboxConversations200DataStatus string

// Status returns HTTPResponse.Status
func (r ListInboxConversationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboxConversationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboxConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AccountId       *string    `json:"accountId,omitempty"`
			AccountUsername *string    `json:"accountUsername,omitempty"`
			Id              *string    `json:"id,omitempty"`
			LastMessage     *string    `json:"lastMessage,omitempty"`
			LastMessageAt   *time.Time `json:"lastMessageAt,omitempty"`
			ParticipantId   *string    `json:"participantId,omitempty"`
			ParticipantName *string    `json:"participantName,omitempty"`
			Participants    *[]struct {
				Id   *string `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"participants,omitempty"`
			Platform    *string                            `json:"platform,omitempty"`
			Status      *GetInboxConversation200DataStatus `json:"status,omitempty"`
			UpdatedTime *time.Time                         `json:"updatedTime,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
}
type GetInboxConversation200DataStatus string

// Status returns HTTPResponse.Status
func (r GetInboxConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboxConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInboxConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AccountId *string                               `json:"accountId,omitempty"`
			Id        *string                               `json:"id,omitempty"`
			Platform  *string                               `json:"platform,omitempty"`
			Status    *UpdateInboxConversation200DataStatus `json:"status,omitempty"`
			UpdatedAt *time.Time                            `json:"updatedAt,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}
type UpdateInboxConversation200DataStatus string

// Status returns HTTPResponse.Status
func (r UpdateInboxConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInboxConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboxConversationMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LastUpdated *time.Time `json:"lastUpdated,omitempty"`
		Messages    *[]struct {
			AccountId   *string `json:"accountId,omitempty"`
			Attachments *[]struct {
				Filename   *string                                                 `json:"filename"`
				Id         *string                                                 `json:"id,omitempty"`
				PreviewUrl *string                                                 `json:"previewUrl"`
				Type       *GetInboxConversationMessages200MessagesAttachmentsType `json:"type,omitempty"`
				Url        *string                                                 `json:"url,omitempty"`
			} `json:"attachments,omitempty"`
			ConversationId *string                                           `json:"conversationId,omitempty"`
			CreatedAt      *time.Time                                        `json:"createdAt,omitempty"`
			Direction      *GetInboxConversationMessages200MessagesDirection `json:"direction,omitempty"`
			Id             *string                                           `json:"id,omitempty"`

			// IsStoryMention Instagram story mention
			IsStoryMention *bool   `json:"isStoryMention"`
			Message        *string `json:"message,omitempty"`
			Platform       *string `json:"platform,omitempty"`
			SenderId       *string `json:"senderId,omitempty"`
			SenderName     *string `json:"senderName"`

			// StoryReply Instagram story reply
			StoryReply *bool `json:"storyReply"`

			// Subject Reddit message subject
			Subject *string `json:"subject"`
		} `json:"messages,omitempty"`
		Status *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}
type GetInboxConversationMessages200MessagesAttachmentsType string
type GetInboxConversationMessages200MessagesDirection string

// Status returns HTTPResponse.Status
func (r GetInboxConversationMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboxConversationMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendInboxMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ConversationId Twitter conversation ID
			ConversationId *string `json:"conversationId"`

			// Message Success message (Reddit only)
			Message *string `json:"message"`

			// MessageId ID of the sent message (not returned for Reddit)
			MessageId *string `json:"messageId,omitempty"`

			// SentAt Bluesky sent timestamp
			SentAt *time.Time `json:"sentAt"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *struct {
		Code  *SendInboxMessage400Code `json:"code,omitempty"`
		Error *string                  `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
}
type SendInboxMessage400Code string

// Status returns HTTPResponse.Status
func (r SendInboxMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendInboxMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboxReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AccountId       *string    `json:"accountId,omitempty"`
			AccountUsername *string    `json:"accountUsername,omitempty"`
			Created         *time.Time `json:"created,omitempty"`
			HasReply        *bool      `json:"hasReply,omitempty"`
			Id              *string    `json:"id,omitempty"`
			Platform        *string    `json:"platform,omitempty"`
			Rating          *int       `json:"rating,omitempty"`
			Reply           *struct {
				Created *time.Time `json:"created,omitempty"`
				Id      *string    `json:"id,omitempty"`
				Text    *string    `json:"text,omitempty"`
			} `json:"reply"`
			ReviewUrl *string `json:"reviewUrl"`
			Reviewer  *struct {
				Id           *string `json:"id"`
				Name         *string `json:"name,omitempty"`
				ProfileImage *string `json:"profileImage"`
			} `json:"reviewer,omitempty"`
			Text *string `json:"text,omitempty"`
		} `json:"data,omitempty"`
		Meta *struct {
			AccountsFailed  *int `json:"accountsFailed,omitempty"`
			AccountsQueried *int `json:"accountsQueried,omitempty"`
			FailedAccounts  *[]struct {
				AccountId       *string `json:"accountId,omitempty"`
				AccountUsername *string `json:"accountUsername"`

				// Code Error code if available
				Code     *string `json:"code"`
				Error    *string `json:"error,omitempty"`
				Platform *string `json:"platform,omitempty"`

				// RetryAfter Seconds to wait before retry (rate limits)
				RetryAfter *int `json:"retryAfter"`
			} `json:"failedAccounts,omitempty"`
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
		} `json:"meta,omitempty"`
		Pagination *struct {
			HasMore    *bool   `json:"hasMore,omitempty"`
			NextCursor *string `json:"nextCursor"`
		} `json:"pagination,omitempty"`
		Status  *string `json:"status,omitempty"`
		Summary *struct {
			AverageRating *float32 `json:"averageRating"`
			TotalReviews  *int     `json:"totalReviews,omitempty"`
		} `json:"summary,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListInboxReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboxReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInboxReviewReplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message  *string `json:"message,omitempty"`
		Platform *string `json:"platform,omitempty"`
		Status   *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteInboxReviewReplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInboxReviewReplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplyToInboxReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Platform *string `json:"platform,omitempty"`
		Reply    *struct {
			Created *time.Time `json:"created,omitempty"`
			Id      *string    `json:"id,omitempty"`
			Text    *string    `json:"text,omitempty"`
		} `json:"reply,omitempty"`
		Status *string `json:"status,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ReplyToInboxReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplyToInboxReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInviteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		ExpiresAt         *time.Time `json:"expiresAt,omitempty"`
		InviteUrl         *string    `json:"inviteUrl,omitempty"`
		InvitedProfileIds *[]string  `json:"invitedProfileIds,omitempty"`
		Scope             *string    `json:"scope,omitempty"`
		Token             *string    `json:"token,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateInviteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInviteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Logs       *[]PostLog `json:"logs,omitempty"`
		Pagination *struct {
			HasMore *bool `json:"hasMore,omitempty"`
			Limit   *int  `json:"limit,omitempty"`

			// Pages Total number of pages
			Pages *int `json:"pages,omitempty"`
			Skip  *int `json:"skip,omitempty"`

			// Total Total number of logs matching the query
			Total *int `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Log *PostLogDetail `json:"log,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaPresignedUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Storage key/path of the file
		Key *string `json:"key,omitempty"`

		// PublicUrl Public URL where the file will be accessible after upload
		PublicUrl *string `json:"publicUrl,omitempty"`

		// Type Detected file type based on content type
		Type *GetMediaPresignedUrl200Type `json:"type,omitempty"`

		// UploadUrl Presigned URL to PUT your file to (expires in 1 hour)
		UploadUrl *string `json:"uploadUrl,omitempty"`
	}
	JSON400 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
}
type GetMediaPresignedUrl200Type string

// Status returns HTTPResponse.Status
func (r GetMediaPresignedUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaPresignedUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostsListResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostCreateResponse
	JSON400      *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON409 *struct {
		Details *struct {
			AccountId      *string `json:"accountId,omitempty"`
			ExistingPostId *string `json:"existingPostId,omitempty"`
			Platform       *string `json:"platform,omitempty"`
		} `json:"details,omitempty"`
		Error *string `json:"error,omitempty"`
	}
	JSON429 *struct {
		// Details Additional context about the rate limit
		Details *map[string]interface{} `json:"details,omitempty"`
		Error   *string                 `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUploadPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Created *int `json:"created,omitempty"`
		Errors  *[]struct {
			Error *string `json:"error,omitempty"`
			Row   *int    `json:"row,omitempty"`
		} `json:"errors,omitempty"`
		Failed    *int    `json:"failed,omitempty"`
		Posts     *[]Post `json:"posts,omitempty"`
		Success   *bool   `json:"success,omitempty"`
		TotalRows *int    `json:"totalRows,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *struct {
		Details *map[string]interface{} `json:"details,omitempty"`
		Error   *string                 `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkUploadPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostDeleteResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostGetResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostUpdateResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of logs returned
		Count  *int       `json:"count,omitempty"`
		Logs   *[]PostLog `json:"logs,omitempty"`
		PostId *string    `json:"postId,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPostLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostRetryResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *struct {
		Details *map[string]interface{} `json:"details,omitempty"`
		Error   *string                 `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RetryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfilesListResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProfileCreateResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Profile *Profile `json:"profile,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string  `json:"message,omitempty"`
		Profile *Profile `json:"profile,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNextQueueSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextSlot  *time.Time `json:"nextSlot,omitempty"`
		ProfileId *string    `json:"profileId,omitempty"`

		// QueueId Queue ID this slot belongs to
		QueueId *string `json:"queueId,omitempty"`

		// QueueName Queue name
		QueueName *string `json:"queueName,omitempty"`
		Timezone  *string `json:"timezone,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetNextQueueSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNextQueueSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Count     *int         `json:"count,omitempty"`
		ProfileId *string      `json:"profileId,omitempty"`
		Slots     *[]time.Time `json:"slots,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r PreviewQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQueueSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deleted *bool `json:"deleted,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteQueueSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQueueSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQueueSlotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON401 *Unauthorized
}
type ListQueueSlots2000 struct {
	Exists    *bool          `json:"exists,omitempty"`
	NextSlots *[]time.Time   `json:"nextSlots,omitempty"`
	Schedule  *QueueSchedule `json:"schedule,omitempty"`
}
type ListQueueSlots2001 struct {
	Count  *int             `json:"count,omitempty"`
	Queues *[]QueueSchedule `json:"queues,omitempty"`
}

// Status returns HTTPResponse.Status
func (r ListQueueSlotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueueSlotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQueueSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		NextSlots *[]time.Time   `json:"nextSlots,omitempty"`
		Schedule  *QueueSchedule `json:"schedule,omitempty"`
		Success   *bool          `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateQueueSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQueueSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateQueueSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextSlots       *[]time.Time   `json:"nextSlots,omitempty"`
		ReshuffledCount *int           `json:"reshuffledCount,omitempty"`
		Schedule        *QueueSchedule `json:"schedule,omitempty"`
		Success         *bool          `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateQueueSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQueueSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRedditFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		After *string                   `json:"after,omitempty"`
		Posts *[]map[string]interface{} `json:"posts,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetRedditFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRedditFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRedditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		After *string `json:"after,omitempty"`
		Posts *[]struct {
			Author      *string  `json:"author,omitempty"`
			CreatedUtc  *float32 `json:"created_utc,omitempty"`
			Id          *string  `json:"id,omitempty"`
			NumComments *int     `json:"num_comments,omitempty"`
			Permalink   *string  `json:"permalink,omitempty"`
			Score       *int     `json:"score,omitempty"`
			Selftext    *string  `json:"selftext,omitempty"`
			Subreddit   *string  `json:"subreddit,omitempty"`
			Title       *string  `json:"title,omitempty"`
		} `json:"posts,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r SearchRedditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRedditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadBlueskyMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Success     *bool   `json:"success,omitempty"`
		Text        *string `json:"text,omitempty"`
		Thumbnail   *string `json:"thumbnail,omitempty"`
		Title       *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadBlueskyMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadBlueskyMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadFacebookVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Success     *bool   `json:"success,omitempty"`
		Thumbnail   *string `json:"thumbnail,omitempty"`
		Title       *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadFacebookVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadFacebookVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadInstagramMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Success     *bool   `json:"success,omitempty"`
		Title       *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadInstagramMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadInstagramMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckInstagramHashtagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]struct {
			Confidence *float32                                `json:"confidence,omitempty"`
			Hashtag    *string                                 `json:"hashtag,omitempty"`
			Reason     *string                                 `json:"reason,omitempty"`
			Status     *CheckInstagramHashtags200ResultsStatus `json:"status,omitempty"`
		} `json:"results,omitempty"`
		Success *bool `json:"success,omitempty"`
		Summary *struct {
			Banned     *int `json:"banned,omitempty"`
			Restricted *int `json:"restricted,omitempty"`
			Safe       *int `json:"safe,omitempty"`
		} `json:"summary,omitempty"`
	}
}
type CheckInstagramHashtags200ResultsStatus string

// Status returns HTTPResponse.Status
func (r CheckInstagramHashtagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckInstagramHashtagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadLinkedInVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Success     *bool   `json:"success,omitempty"`
		Title       *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadLinkedInVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadLinkedInVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadTikTokVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Formats     *[]struct {
			Ext   *string `json:"ext,omitempty"`
			Id    *string `json:"id,omitempty"`
			Label *string `json:"label,omitempty"`
		} `json:"formats,omitempty"`
		Success *bool   `json:"success,omitempty"`
		Title   *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadTikTokVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadTikTokVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadTwitterMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Success     *bool   `json:"success,omitempty"`
		Title       *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadTwitterMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadTwitterMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadYouTubeVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DownloadUrl *string `json:"downloadUrl,omitempty"`
		Formats     *[]struct {
			Ext    *string `json:"ext,omitempty"`
			Height *int    `json:"height,omitempty"`
			Id     *string `json:"id,omitempty"`
			Label  *string `json:"label,omitempty"`
			Type   *string `json:"type,omitempty"`
			Width  *int    `json:"width,omitempty"`
		} `json:"formats,omitempty"`
		Success *bool   `json:"success,omitempty"`
		Title   *string `json:"title,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DownloadYouTubeVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadYouTubeVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetYouTubeTranscriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FullText *string `json:"fullText,omitempty"`
		Language *string `json:"language,omitempty"`
		Segments *[]struct {
			Duration *float32 `json:"duration,omitempty"`
			Start    *float32 `json:"start,omitempty"`
			Text     *string  `json:"text,omitempty"`
		} `json:"segments,omitempty"`
		Success *bool   `json:"success,omitempty"`
		VideoId *string `json:"videoId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetYouTubeTranscriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetYouTubeTranscriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageStats
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUsageStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CurrentUserId *string `json:"currentUserId,omitempty"`
		Users         *[]struct {
			UnderscoreId  *string    `json:"_id,omitempty"`
			CreatedAt     *time.Time `json:"createdAt,omitempty"`
			Email         *string    `json:"email,omitempty"`
			IsRoot        *bool      `json:"isRoot,omitempty"`
			Name          *string    `json:"name,omitempty"`
			ProfileAccess *[]string  `json:"profileAccess,omitempty"`
			Role          *string    `json:"role,omitempty"`
		} `json:"users,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User *struct {
			UnderscoreId  *string   `json:"_id,omitempty"`
			Email         *string   `json:"email,omitempty"`
			IsRoot        *bool     `json:"isRoot,omitempty"`
			Name          *string   `json:"name,omitempty"`
			ProfileAccess *[]string `json:"profileAccess,omitempty"`
			Role          *string   `json:"role,omitempty"`
		} `json:"user,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Logs *[]WebhookLog `json:"logs,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetWebhookLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Webhooks *[]Webhook `json:"webhooks,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetWebhookSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`

		// Webhook Individual webhook configuration for receiving real-time notifications
		Webhook *Webhook `json:"webhook,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateWebhookSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`

		// Webhook Individual webhook configuration for receiving real-time notifications
		Webhook *Webhook `json:"webhook,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *struct {
		Message *string `json:"message,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TestWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountGroupsWithResponse request returning *ListAccountGroupsResponse
func (c *ClientWithResponses) ListAccountGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAccountGroupsResponse, error) {
	rsp, err := c.ListAccountGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountGroupsResponse(rsp)
}

// CreateAccountGroupWithBodyWithResponse request with arbitrary body returning *CreateAccountGroupResponse
func (c *ClientWithResponses) CreateAccountGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountGroupResponse, error) {
	rsp, err := c.CreateAccountGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountGroupWithResponse(ctx context.Context, body CreateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountGroupResponse, error) {
	rsp, err := c.CreateAccountGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountGroupResponse(rsp)
}

// DeleteAccountGroupWithResponse request returning *DeleteAccountGroupResponse
func (c *ClientWithResponses) DeleteAccountGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAccountGroupResponse, error) {
	rsp, err := c.DeleteAccountGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountGroupResponse(rsp)
}

// UpdateAccountGroupWithBodyWithResponse request with arbitrary body returning *UpdateAccountGroupResponse
func (c *ClientWithResponses) UpdateAccountGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountGroupResponse, error) {
	rsp, err := c.UpdateAccountGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountGroupWithResponse(ctx context.Context, groupId string, body UpdateAccountGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountGroupResponse, error) {
	rsp, err := c.UpdateAccountGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountGroupResponse(rsp)
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// GetFollowerStatsWithResponse request returning *GetFollowerStatsResponse
func (c *ClientWithResponses) GetFollowerStatsWithResponse(ctx context.Context, params *GetFollowerStatsParams, reqEditors ...RequestEditorFn) (*GetFollowerStatsResponse, error) {
	rsp, err := c.GetFollowerStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFollowerStatsResponse(rsp)
}

// GetAllAccountsHealthWithResponse request returning *GetAllAccountsHealthResponse
func (c *ClientWithResponses) GetAllAccountsHealthWithResponse(ctx context.Context, params *GetAllAccountsHealthParams, reqEditors ...RequestEditorFn) (*GetAllAccountsHealthResponse, error) {
	rsp, err := c.GetAllAccountsHealth(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccountsHealthResponse(rsp)
}

// DeleteAccountWithResponse request returning *DeleteAccountResponse
func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error) {
	rsp, err := c.DeleteAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResponse(rsp)
}

// UpdateAccountWithBodyWithResponse request with arbitrary body returning *UpdateAccountResponse
func (c *ClientWithResponses) UpdateAccountWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccountWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithResponse(ctx context.Context, accountId string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccount(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

// GetFacebookPagesWithResponse request returning *GetFacebookPagesResponse
func (c *ClientWithResponses) GetFacebookPagesWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetFacebookPagesResponse, error) {
	rsp, err := c.GetFacebookPages(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFacebookPagesResponse(rsp)
}

// UpdateFacebookPageWithBodyWithResponse request with arbitrary body returning *UpdateFacebookPageResponse
func (c *ClientWithResponses) UpdateFacebookPageWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFacebookPageResponse, error) {
	rsp, err := c.UpdateFacebookPageWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFacebookPageResponse(rsp)
}

func (c *ClientWithResponses) UpdateFacebookPageWithResponse(ctx context.Context, accountId string, body UpdateFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFacebookPageResponse, error) {
	rsp, err := c.UpdateFacebookPage(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFacebookPageResponse(rsp)
}

// GetGoogleBusinessAttributesWithResponse request returning *GetGoogleBusinessAttributesResponse
func (c *ClientWithResponses) GetGoogleBusinessAttributesWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGoogleBusinessAttributesResponse, error) {
	rsp, err := c.GetGoogleBusinessAttributes(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoogleBusinessAttributesResponse(rsp)
}

// UpdateGoogleBusinessAttributesWithBodyWithResponse request with arbitrary body returning *UpdateGoogleBusinessAttributesResponse
func (c *ClientWithResponses) UpdateGoogleBusinessAttributesWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessAttributesResponse, error) {
	rsp, err := c.UpdateGoogleBusinessAttributesWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessAttributesResponse(rsp)
}

func (c *ClientWithResponses) UpdateGoogleBusinessAttributesWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessAttributesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessAttributesResponse, error) {
	rsp, err := c.UpdateGoogleBusinessAttributes(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessAttributesResponse(rsp)
}

// GetGoogleBusinessFoodMenusWithResponse request returning *GetGoogleBusinessFoodMenusResponse
func (c *ClientWithResponses) GetGoogleBusinessFoodMenusWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGoogleBusinessFoodMenusResponse, error) {
	rsp, err := c.GetGoogleBusinessFoodMenus(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoogleBusinessFoodMenusResponse(rsp)
}

// UpdateGoogleBusinessFoodMenusWithBodyWithResponse request with arbitrary body returning *UpdateGoogleBusinessFoodMenusResponse
func (c *ClientWithResponses) UpdateGoogleBusinessFoodMenusWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessFoodMenusResponse, error) {
	rsp, err := c.UpdateGoogleBusinessFoodMenusWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessFoodMenusResponse(rsp)
}

func (c *ClientWithResponses) UpdateGoogleBusinessFoodMenusWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessFoodMenusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessFoodMenusResponse, error) {
	rsp, err := c.UpdateGoogleBusinessFoodMenus(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessFoodMenusResponse(rsp)
}

// GetGoogleBusinessLocationDetailsWithResponse request returning *GetGoogleBusinessLocationDetailsResponse
func (c *ClientWithResponses) GetGoogleBusinessLocationDetailsWithResponse(ctx context.Context, accountId string, params *GetGoogleBusinessLocationDetailsParams, reqEditors ...RequestEditorFn) (*GetGoogleBusinessLocationDetailsResponse, error) {
	rsp, err := c.GetGoogleBusinessLocationDetails(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoogleBusinessLocationDetailsResponse(rsp)
}

// UpdateGoogleBusinessLocationDetailsWithBodyWithResponse request with arbitrary body returning *UpdateGoogleBusinessLocationDetailsResponse
func (c *ClientWithResponses) UpdateGoogleBusinessLocationDetailsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessLocationDetailsResponse, error) {
	rsp, err := c.UpdateGoogleBusinessLocationDetailsWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessLocationDetailsResponse(rsp)
}

func (c *ClientWithResponses) UpdateGoogleBusinessLocationDetailsWithResponse(ctx context.Context, accountId string, body UpdateGoogleBusinessLocationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoogleBusinessLocationDetailsResponse, error) {
	rsp, err := c.UpdateGoogleBusinessLocationDetails(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoogleBusinessLocationDetailsResponse(rsp)
}

// GetGmbLocationsWithResponse request returning *GetGmbLocationsResponse
func (c *ClientWithResponses) GetGmbLocationsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetGmbLocationsResponse, error) {
	rsp, err := c.GetGmbLocations(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGmbLocationsResponse(rsp)
}

// UpdateGmbLocationWithBodyWithResponse request with arbitrary body returning *UpdateGmbLocationResponse
func (c *ClientWithResponses) UpdateGmbLocationWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGmbLocationResponse, error) {
	rsp, err := c.UpdateGmbLocationWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGmbLocationResponse(rsp)
}

func (c *ClientWithResponses) UpdateGmbLocationWithResponse(ctx context.Context, accountId string, body UpdateGmbLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGmbLocationResponse, error) {
	rsp, err := c.UpdateGmbLocation(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGmbLocationResponse(rsp)
}

// DeleteGoogleBusinessMediaWithResponse request returning *DeleteGoogleBusinessMediaResponse
func (c *ClientWithResponses) DeleteGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, params *DeleteGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*DeleteGoogleBusinessMediaResponse, error) {
	rsp, err := c.DeleteGoogleBusinessMedia(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGoogleBusinessMediaResponse(rsp)
}

// ListGoogleBusinessMediaWithResponse request returning *ListGoogleBusinessMediaResponse
func (c *ClientWithResponses) ListGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, params *ListGoogleBusinessMediaParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessMediaResponse, error) {
	rsp, err := c.ListGoogleBusinessMedia(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGoogleBusinessMediaResponse(rsp)
}

// CreateGoogleBusinessMediaWithBodyWithResponse request with arbitrary body returning *CreateGoogleBusinessMediaResponse
func (c *ClientWithResponses) CreateGoogleBusinessMediaWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessMediaResponse, error) {
	rsp, err := c.CreateGoogleBusinessMediaWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleBusinessMediaResponse(rsp)
}

func (c *ClientWithResponses) CreateGoogleBusinessMediaWithResponse(ctx context.Context, accountId string, body CreateGoogleBusinessMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessMediaResponse, error) {
	rsp, err := c.CreateGoogleBusinessMedia(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleBusinessMediaResponse(rsp)
}

// DeleteGoogleBusinessPlaceActionWithResponse request returning *DeleteGoogleBusinessPlaceActionResponse
func (c *ClientWithResponses) DeleteGoogleBusinessPlaceActionWithResponse(ctx context.Context, accountId string, params *DeleteGoogleBusinessPlaceActionParams, reqEditors ...RequestEditorFn) (*DeleteGoogleBusinessPlaceActionResponse, error) {
	rsp, err := c.DeleteGoogleBusinessPlaceAction(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGoogleBusinessPlaceActionResponse(rsp)
}

// ListGoogleBusinessPlaceActionsWithResponse request returning *ListGoogleBusinessPlaceActionsResponse
func (c *ClientWithResponses) ListGoogleBusinessPlaceActionsWithResponse(ctx context.Context, accountId string, params *ListGoogleBusinessPlaceActionsParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessPlaceActionsResponse, error) {
	rsp, err := c.ListGoogleBusinessPlaceActions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGoogleBusinessPlaceActionsResponse(rsp)
}

// CreateGoogleBusinessPlaceActionWithBodyWithResponse request with arbitrary body returning *CreateGoogleBusinessPlaceActionResponse
func (c *ClientWithResponses) CreateGoogleBusinessPlaceActionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessPlaceActionResponse, error) {
	rsp, err := c.CreateGoogleBusinessPlaceActionWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleBusinessPlaceActionResponse(rsp)
}

func (c *ClientWithResponses) CreateGoogleBusinessPlaceActionWithResponse(ctx context.Context, accountId string, body CreateGoogleBusinessPlaceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleBusinessPlaceActionResponse, error) {
	rsp, err := c.CreateGoogleBusinessPlaceAction(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleBusinessPlaceActionResponse(rsp)
}

// GetGoogleBusinessReviewsWithResponse request returning *GetGoogleBusinessReviewsResponse
func (c *ClientWithResponses) GetGoogleBusinessReviewsWithResponse(ctx context.Context, accountId string, params *GetGoogleBusinessReviewsParams, reqEditors ...RequestEditorFn) (*GetGoogleBusinessReviewsResponse, error) {
	rsp, err := c.GetGoogleBusinessReviews(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoogleBusinessReviewsResponse(rsp)
}

// GetAccountHealthWithResponse request returning *GetAccountHealthResponse
func (c *ClientWithResponses) GetAccountHealthWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountHealthResponse, error) {
	rsp, err := c.GetAccountHealth(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountHealthResponse(rsp)
}

// GetLinkedInAggregateAnalyticsWithResponse request returning *GetLinkedInAggregateAnalyticsResponse
func (c *ClientWithResponses) GetLinkedInAggregateAnalyticsWithResponse(ctx context.Context, accountId string, params *GetLinkedInAggregateAnalyticsParams, reqEditors ...RequestEditorFn) (*GetLinkedInAggregateAnalyticsResponse, error) {
	rsp, err := c.GetLinkedInAggregateAnalytics(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkedInAggregateAnalyticsResponse(rsp)
}

// GetLinkedInMentionsWithResponse request returning *GetLinkedInMentionsResponse
func (c *ClientWithResponses) GetLinkedInMentionsWithResponse(ctx context.Context, accountId string, params *GetLinkedInMentionsParams, reqEditors ...RequestEditorFn) (*GetLinkedInMentionsResponse, error) {
	rsp, err := c.GetLinkedInMentions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkedInMentionsResponse(rsp)
}

// UpdateLinkedInOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateLinkedInOrganizationResponse
func (c *ClientWithResponses) UpdateLinkedInOrganizationWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkedInOrganizationResponse, error) {
	rsp, err := c.UpdateLinkedInOrganizationWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkedInOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateLinkedInOrganizationWithResponse(ctx context.Context, accountId string, body UpdateLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkedInOrganizationResponse, error) {
	rsp, err := c.UpdateLinkedInOrganization(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkedInOrganizationResponse(rsp)
}

// GetLinkedInOrganizationsWithResponse request returning *GetLinkedInOrganizationsResponse
func (c *ClientWithResponses) GetLinkedInOrganizationsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetLinkedInOrganizationsResponse, error) {
	rsp, err := c.GetLinkedInOrganizations(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkedInOrganizationsResponse(rsp)
}

// GetLinkedInPostAnalyticsWithResponse request returning *GetLinkedInPostAnalyticsResponse
func (c *ClientWithResponses) GetLinkedInPostAnalyticsWithResponse(ctx context.Context, accountId string, params *GetLinkedInPostAnalyticsParams, reqEditors ...RequestEditorFn) (*GetLinkedInPostAnalyticsResponse, error) {
	rsp, err := c.GetLinkedInPostAnalytics(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkedInPostAnalyticsResponse(rsp)
}

// GetPinterestBoardsWithResponse request returning *GetPinterestBoardsResponse
func (c *ClientWithResponses) GetPinterestBoardsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetPinterestBoardsResponse, error) {
	rsp, err := c.GetPinterestBoards(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPinterestBoardsResponse(rsp)
}

// UpdatePinterestBoardsWithBodyWithResponse request with arbitrary body returning *UpdatePinterestBoardsResponse
func (c *ClientWithResponses) UpdatePinterestBoardsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePinterestBoardsResponse, error) {
	rsp, err := c.UpdatePinterestBoardsWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePinterestBoardsResponse(rsp)
}

func (c *ClientWithResponses) UpdatePinterestBoardsWithResponse(ctx context.Context, accountId string, body UpdatePinterestBoardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePinterestBoardsResponse, error) {
	rsp, err := c.UpdatePinterestBoards(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePinterestBoardsResponse(rsp)
}

// GetRedditSubredditsWithResponse request returning *GetRedditSubredditsResponse
func (c *ClientWithResponses) GetRedditSubredditsWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRedditSubredditsResponse, error) {
	rsp, err := c.GetRedditSubreddits(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRedditSubredditsResponse(rsp)
}

// UpdateRedditSubredditsWithBodyWithResponse request with arbitrary body returning *UpdateRedditSubredditsResponse
func (c *ClientWithResponses) UpdateRedditSubredditsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRedditSubredditsResponse, error) {
	rsp, err := c.UpdateRedditSubredditsWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRedditSubredditsResponse(rsp)
}

func (c *ClientWithResponses) UpdateRedditSubredditsWithResponse(ctx context.Context, accountId string, body UpdateRedditSubredditsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRedditSubredditsResponse, error) {
	rsp, err := c.UpdateRedditSubreddits(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRedditSubredditsResponse(rsp)
}

// GetAnalyticsWithResponse request returning *GetAnalyticsResponse
func (c *ClientWithResponses) GetAnalyticsWithResponse(ctx context.Context, params *GetAnalyticsParams, reqEditors ...RequestEditorFn) (*GetAnalyticsResponse, error) {
	rsp, err := c.GetAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsResponse(rsp)
}

// GetYouTubeDailyViewsWithResponse request returning *GetYouTubeDailyViewsResponse
func (c *ClientWithResponses) GetYouTubeDailyViewsWithResponse(ctx context.Context, params *GetYouTubeDailyViewsParams, reqEditors ...RequestEditorFn) (*GetYouTubeDailyViewsResponse, error) {
	rsp, err := c.GetYouTubeDailyViews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetYouTubeDailyViewsResponse(rsp)
}

// ListApiKeysWithResponse request returning *ListApiKeysResponse
func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyResponse
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

// DeleteApiKeyWithResponse request returning *DeleteApiKeyResponse
func (c *ClientWithResponses) DeleteApiKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error) {
	rsp, err := c.DeleteApiKey(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyResponse(rsp)
}

// ConnectBlueskyCredentialsWithBodyWithResponse request with arbitrary body returning *ConnectBlueskyCredentialsResponse
func (c *ClientWithResponses) ConnectBlueskyCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectBlueskyCredentialsResponse, error) {
	rsp, err := c.ConnectBlueskyCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectBlueskyCredentialsResponse(rsp)
}

func (c *ClientWithResponses) ConnectBlueskyCredentialsWithResponse(ctx context.Context, body ConnectBlueskyCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectBlueskyCredentialsResponse, error) {
	rsp, err := c.ConnectBlueskyCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectBlueskyCredentialsResponse(rsp)
}

// ListFacebookPagesWithResponse request returning *ListFacebookPagesResponse
func (c *ClientWithResponses) ListFacebookPagesWithResponse(ctx context.Context, params *ListFacebookPagesParams, reqEditors ...RequestEditorFn) (*ListFacebookPagesResponse, error) {
	rsp, err := c.ListFacebookPages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFacebookPagesResponse(rsp)
}

// SelectFacebookPageWithBodyWithResponse request with arbitrary body returning *SelectFacebookPageResponse
func (c *ClientWithResponses) SelectFacebookPageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectFacebookPageResponse, error) {
	rsp, err := c.SelectFacebookPageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectFacebookPageResponse(rsp)
}

func (c *ClientWithResponses) SelectFacebookPageWithResponse(ctx context.Context, body SelectFacebookPageJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectFacebookPageResponse, error) {
	rsp, err := c.SelectFacebookPage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectFacebookPageResponse(rsp)
}

// ListGoogleBusinessLocationsWithResponse request returning *ListGoogleBusinessLocationsResponse
func (c *ClientWithResponses) ListGoogleBusinessLocationsWithResponse(ctx context.Context, params *ListGoogleBusinessLocationsParams, reqEditors ...RequestEditorFn) (*ListGoogleBusinessLocationsResponse, error) {
	rsp, err := c.ListGoogleBusinessLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGoogleBusinessLocationsResponse(rsp)
}

// SelectGoogleBusinessLocationWithBodyWithResponse request with arbitrary body returning *SelectGoogleBusinessLocationResponse
func (c *ClientWithResponses) SelectGoogleBusinessLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectGoogleBusinessLocationResponse, error) {
	rsp, err := c.SelectGoogleBusinessLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectGoogleBusinessLocationResponse(rsp)
}

func (c *ClientWithResponses) SelectGoogleBusinessLocationWithResponse(ctx context.Context, body SelectGoogleBusinessLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectGoogleBusinessLocationResponse, error) {
	rsp, err := c.SelectGoogleBusinessLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectGoogleBusinessLocationResponse(rsp)
}

// ListLinkedInOrganizationsWithResponse request returning *ListLinkedInOrganizationsResponse
func (c *ClientWithResponses) ListLinkedInOrganizationsWithResponse(ctx context.Context, params *ListLinkedInOrganizationsParams, reqEditors ...RequestEditorFn) (*ListLinkedInOrganizationsResponse, error) {
	rsp, err := c.ListLinkedInOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinkedInOrganizationsResponse(rsp)
}

// SelectLinkedInOrganizationWithBodyWithResponse request with arbitrary body returning *SelectLinkedInOrganizationResponse
func (c *ClientWithResponses) SelectLinkedInOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectLinkedInOrganizationResponse, error) {
	rsp, err := c.SelectLinkedInOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectLinkedInOrganizationResponse(rsp)
}

func (c *ClientWithResponses) SelectLinkedInOrganizationWithResponse(ctx context.Context, body SelectLinkedInOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectLinkedInOrganizationResponse, error) {
	rsp, err := c.SelectLinkedInOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectLinkedInOrganizationResponse(rsp)
}

// GetPendingOAuthDataWithResponse request returning *GetPendingOAuthDataResponse
func (c *ClientWithResponses) GetPendingOAuthDataWithResponse(ctx context.Context, params *GetPendingOAuthDataParams, reqEditors ...RequestEditorFn) (*GetPendingOAuthDataResponse, error) {
	rsp, err := c.GetPendingOAuthData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingOAuthDataResponse(rsp)
}

// ListPinterestBoardsForSelectionWithResponse request returning *ListPinterestBoardsForSelectionResponse
func (c *ClientWithResponses) ListPinterestBoardsForSelectionWithResponse(ctx context.Context, params *ListPinterestBoardsForSelectionParams, reqEditors ...RequestEditorFn) (*ListPinterestBoardsForSelectionResponse, error) {
	rsp, err := c.ListPinterestBoardsForSelection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPinterestBoardsForSelectionResponse(rsp)
}

// SelectPinterestBoardWithBodyWithResponse request with arbitrary body returning *SelectPinterestBoardResponse
func (c *ClientWithResponses) SelectPinterestBoardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectPinterestBoardResponse, error) {
	rsp, err := c.SelectPinterestBoardWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectPinterestBoardResponse(rsp)
}

func (c *ClientWithResponses) SelectPinterestBoardWithResponse(ctx context.Context, body SelectPinterestBoardJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectPinterestBoardResponse, error) {
	rsp, err := c.SelectPinterestBoard(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectPinterestBoardResponse(rsp)
}

// ListSnapchatProfilesWithResponse request returning *ListSnapchatProfilesResponse
func (c *ClientWithResponses) ListSnapchatProfilesWithResponse(ctx context.Context, params *ListSnapchatProfilesParams, reqEditors ...RequestEditorFn) (*ListSnapchatProfilesResponse, error) {
	rsp, err := c.ListSnapchatProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSnapchatProfilesResponse(rsp)
}

// SelectSnapchatProfileWithBodyWithResponse request with arbitrary body returning *SelectSnapchatProfileResponse
func (c *ClientWithResponses) SelectSnapchatProfileWithBodyWithResponse(ctx context.Context, params *SelectSnapchatProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectSnapchatProfileResponse, error) {
	rsp, err := c.SelectSnapchatProfileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectSnapchatProfileResponse(rsp)
}

func (c *ClientWithResponses) SelectSnapchatProfileWithResponse(ctx context.Context, params *SelectSnapchatProfileParams, body SelectSnapchatProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectSnapchatProfileResponse, error) {
	rsp, err := c.SelectSnapchatProfile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectSnapchatProfileResponse(rsp)
}

// GetTelegramConnectStatusWithResponse request returning *GetTelegramConnectStatusResponse
func (c *ClientWithResponses) GetTelegramConnectStatusWithResponse(ctx context.Context, params *GetTelegramConnectStatusParams, reqEditors ...RequestEditorFn) (*GetTelegramConnectStatusResponse, error) {
	rsp, err := c.GetTelegramConnectStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTelegramConnectStatusResponse(rsp)
}

// CompleteTelegramConnectWithResponse request returning *CompleteTelegramConnectResponse
func (c *ClientWithResponses) CompleteTelegramConnectWithResponse(ctx context.Context, params *CompleteTelegramConnectParams, reqEditors ...RequestEditorFn) (*CompleteTelegramConnectResponse, error) {
	rsp, err := c.CompleteTelegramConnect(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteTelegramConnectResponse(rsp)
}

// InitiateTelegramConnectWithBodyWithResponse request with arbitrary body returning *InitiateTelegramConnectResponse
func (c *ClientWithResponses) InitiateTelegramConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateTelegramConnectResponse, error) {
	rsp, err := c.InitiateTelegramConnectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateTelegramConnectResponse(rsp)
}

func (c *ClientWithResponses) InitiateTelegramConnectWithResponse(ctx context.Context, body InitiateTelegramConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateTelegramConnectResponse, error) {
	rsp, err := c.InitiateTelegramConnect(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateTelegramConnectResponse(rsp)
}

// GetConnectUrlWithResponse request returning *GetConnectUrlResponse
func (c *ClientWithResponses) GetConnectUrlWithResponse(ctx context.Context, platform GetConnectUrlParamsPlatform, params *GetConnectUrlParams, reqEditors ...RequestEditorFn) (*GetConnectUrlResponse, error) {
	rsp, err := c.GetConnectUrl(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectUrlResponse(rsp)
}

// HandleOAuthCallbackWithBodyWithResponse request with arbitrary body returning *HandleOAuthCallbackResponse
func (c *ClientWithResponses) HandleOAuthCallbackWithBodyWithResponse(ctx context.Context, platform string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandleOAuthCallbackResponse, error) {
	rsp, err := c.HandleOAuthCallbackWithBody(ctx, platform, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandleOAuthCallbackResponse(rsp)
}

func (c *ClientWithResponses) HandleOAuthCallbackWithResponse(ctx context.Context, platform string, body HandleOAuthCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*HandleOAuthCallbackResponse, error) {
	rsp, err := c.HandleOAuthCallback(ctx, platform, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandleOAuthCallbackResponse(rsp)
}

// ListInboxCommentsWithResponse request returning *ListInboxCommentsResponse
func (c *ClientWithResponses) ListInboxCommentsWithResponse(ctx context.Context, params *ListInboxCommentsParams, reqEditors ...RequestEditorFn) (*ListInboxCommentsResponse, error) {
	rsp, err := c.ListInboxComments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInboxCommentsResponse(rsp)
}

// DeleteInboxCommentWithResponse request returning *DeleteInboxCommentResponse
func (c *ClientWithResponses) DeleteInboxCommentWithResponse(ctx context.Context, postId string, params *DeleteInboxCommentParams, reqEditors ...RequestEditorFn) (*DeleteInboxCommentResponse, error) {
	rsp, err := c.DeleteInboxComment(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInboxCommentResponse(rsp)
}

// GetInboxPostCommentsWithResponse request returning *GetInboxPostCommentsResponse
func (c *ClientWithResponses) GetInboxPostCommentsWithResponse(ctx context.Context, postId string, params *GetInboxPostCommentsParams, reqEditors ...RequestEditorFn) (*GetInboxPostCommentsResponse, error) {
	rsp, err := c.GetInboxPostComments(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInboxPostCommentsResponse(rsp)
}

// ReplyToInboxPostWithBodyWithResponse request with arbitrary body returning *ReplyToInboxPostResponse
func (c *ClientWithResponses) ReplyToInboxPostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplyToInboxPostResponse, error) {
	rsp, err := c.ReplyToInboxPostWithBody(ctx, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplyToInboxPostResponse(rsp)
}

func (c *ClientWithResponses) ReplyToInboxPostWithResponse(ctx context.Context, postId string, body ReplyToInboxPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplyToInboxPostResponse, error) {
	rsp, err := c.ReplyToInboxPost(ctx, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplyToInboxPostResponse(rsp)
}

// UnhideInboxCommentWithResponse request returning *UnhideInboxCommentResponse
func (c *ClientWithResponses) UnhideInboxCommentWithResponse(ctx context.Context, postId string, commentId string, params *UnhideInboxCommentParams, reqEditors ...RequestEditorFn) (*UnhideInboxCommentResponse, error) {
	rsp, err := c.UnhideInboxComment(ctx, postId, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnhideInboxCommentResponse(rsp)
}

// HideInboxCommentWithBodyWithResponse request with arbitrary body returning *HideInboxCommentResponse
func (c *ClientWithResponses) HideInboxCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HideInboxCommentResponse, error) {
	rsp, err := c.HideInboxCommentWithBody(ctx, postId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideInboxCommentResponse(rsp)
}

func (c *ClientWithResponses) HideInboxCommentWithResponse(ctx context.Context, postId string, commentId string, body HideInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*HideInboxCommentResponse, error) {
	rsp, err := c.HideInboxComment(ctx, postId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideInboxCommentResponse(rsp)
}

// UnlikeInboxCommentWithResponse request returning *UnlikeInboxCommentResponse
func (c *ClientWithResponses) UnlikeInboxCommentWithResponse(ctx context.Context, postId string, commentId string, params *UnlikeInboxCommentParams, reqEditors ...RequestEditorFn) (*UnlikeInboxCommentResponse, error) {
	rsp, err := c.UnlikeInboxComment(ctx, postId, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlikeInboxCommentResponse(rsp)
}

// LikeInboxCommentWithBodyWithResponse request with arbitrary body returning *LikeInboxCommentResponse
func (c *ClientWithResponses) LikeInboxCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikeInboxCommentResponse, error) {
	rsp, err := c.LikeInboxCommentWithBody(ctx, postId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikeInboxCommentResponse(rsp)
}

func (c *ClientWithResponses) LikeInboxCommentWithResponse(ctx context.Context, postId string, commentId string, body LikeInboxCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*LikeInboxCommentResponse, error) {
	rsp, err := c.LikeInboxComment(ctx, postId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikeInboxCommentResponse(rsp)
}

// SendPrivateReplyToCommentWithBodyWithResponse request with arbitrary body returning *SendPrivateReplyToCommentResponse
func (c *ClientWithResponses) SendPrivateReplyToCommentWithBodyWithResponse(ctx context.Context, postId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPrivateReplyToCommentResponse, error) {
	rsp, err := c.SendPrivateReplyToCommentWithBody(ctx, postId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPrivateReplyToCommentResponse(rsp)
}

func (c *ClientWithResponses) SendPrivateReplyToCommentWithResponse(ctx context.Context, postId string, commentId string, body SendPrivateReplyToCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPrivateReplyToCommentResponse, error) {
	rsp, err := c.SendPrivateReplyToComment(ctx, postId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPrivateReplyToCommentResponse(rsp)
}

// ListInboxConversationsWithResponse request returning *ListInboxConversationsResponse
func (c *ClientWithResponses) ListInboxConversationsWithResponse(ctx context.Context, params *ListInboxConversationsParams, reqEditors ...RequestEditorFn) (*ListInboxConversationsResponse, error) {
	rsp, err := c.ListInboxConversations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInboxConversationsResponse(rsp)
}

// GetInboxConversationWithResponse request returning *GetInboxConversationResponse
func (c *ClientWithResponses) GetInboxConversationWithResponse(ctx context.Context, conversationId string, params *GetInboxConversationParams, reqEditors ...RequestEditorFn) (*GetInboxConversationResponse, error) {
	rsp, err := c.GetInboxConversation(ctx, conversationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInboxConversationResponse(rsp)
}

// UpdateInboxConversationWithBodyWithResponse request with arbitrary body returning *UpdateInboxConversationResponse
func (c *ClientWithResponses) UpdateInboxConversationWithBodyWithResponse(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInboxConversationResponse, error) {
	rsp, err := c.UpdateInboxConversationWithBody(ctx, conversationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboxConversationResponse(rsp)
}

func (c *ClientWithResponses) UpdateInboxConversationWithResponse(ctx context.Context, conversationId string, body UpdateInboxConversationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInboxConversationResponse, error) {
	rsp, err := c.UpdateInboxConversation(ctx, conversationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboxConversationResponse(rsp)
}

// GetInboxConversationMessagesWithResponse request returning *GetInboxConversationMessagesResponse
func (c *ClientWithResponses) GetInboxConversationMessagesWithResponse(ctx context.Context, conversationId string, params *GetInboxConversationMessagesParams, reqEditors ...RequestEditorFn) (*GetInboxConversationMessagesResponse, error) {
	rsp, err := c.GetInboxConversationMessages(ctx, conversationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInboxConversationMessagesResponse(rsp)
}

// SendInboxMessageWithBodyWithResponse request with arbitrary body returning *SendInboxMessageResponse
func (c *ClientWithResponses) SendInboxMessageWithBodyWithResponse(ctx context.Context, conversationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendInboxMessageResponse, error) {
	rsp, err := c.SendInboxMessageWithBody(ctx, conversationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendInboxMessageResponse(rsp)
}

func (c *ClientWithResponses) SendInboxMessageWithResponse(ctx context.Context, conversationId string, body SendInboxMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendInboxMessageResponse, error) {
	rsp, err := c.SendInboxMessage(ctx, conversationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendInboxMessageResponse(rsp)
}

// ListInboxReviewsWithResponse request returning *ListInboxReviewsResponse
func (c *ClientWithResponses) ListInboxReviewsWithResponse(ctx context.Context, params *ListInboxReviewsParams, reqEditors ...RequestEditorFn) (*ListInboxReviewsResponse, error) {
	rsp, err := c.ListInboxReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInboxReviewsResponse(rsp)
}

// DeleteInboxReviewReplyWithBodyWithResponse request with arbitrary body returning *DeleteInboxReviewReplyResponse
func (c *ClientWithResponses) DeleteInboxReviewReplyWithBodyWithResponse(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInboxReviewReplyResponse, error) {
	rsp, err := c.DeleteInboxReviewReplyWithBody(ctx, reviewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInboxReviewReplyResponse(rsp)
}

func (c *ClientWithResponses) DeleteInboxReviewReplyWithResponse(ctx context.Context, reviewId string, body DeleteInboxReviewReplyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInboxReviewReplyResponse, error) {
	rsp, err := c.DeleteInboxReviewReply(ctx, reviewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInboxReviewReplyResponse(rsp)
}

// ReplyToInboxReviewWithBodyWithResponse request with arbitrary body returning *ReplyToInboxReviewResponse
func (c *ClientWithResponses) ReplyToInboxReviewWithBodyWithResponse(ctx context.Context, reviewId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplyToInboxReviewResponse, error) {
	rsp, err := c.ReplyToInboxReviewWithBody(ctx, reviewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplyToInboxReviewResponse(rsp)
}

func (c *ClientWithResponses) ReplyToInboxReviewWithResponse(ctx context.Context, reviewId string, body ReplyToInboxReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplyToInboxReviewResponse, error) {
	rsp, err := c.ReplyToInboxReview(ctx, reviewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplyToInboxReviewResponse(rsp)
}

// CreateInviteTokenWithBodyWithResponse request with arbitrary body returning *CreateInviteTokenResponse
func (c *ClientWithResponses) CreateInviteTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInviteTokenResponse, error) {
	rsp, err := c.CreateInviteTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInviteTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateInviteTokenWithResponse(ctx context.Context, body CreateInviteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInviteTokenResponse, error) {
	rsp, err := c.CreateInviteToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInviteTokenResponse(rsp)
}

// ListLogsWithResponse request returning *ListLogsResponse
func (c *ClientWithResponses) ListLogsWithResponse(ctx context.Context, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error) {
	rsp, err := c.ListLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogsResponse(rsp)
}

// GetLogWithResponse request returning *GetLogResponse
func (c *ClientWithResponses) GetLogWithResponse(ctx context.Context, logId string, reqEditors ...RequestEditorFn) (*GetLogResponse, error) {
	rsp, err := c.GetLog(ctx, logId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogResponse(rsp)
}

// GetMediaPresignedUrlWithBodyWithResponse request with arbitrary body returning *GetMediaPresignedUrlResponse
func (c *ClientWithResponses) GetMediaPresignedUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMediaPresignedUrlResponse, error) {
	rsp, err := c.GetMediaPresignedUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaPresignedUrlResponse(rsp)
}

func (c *ClientWithResponses) GetMediaPresignedUrlWithResponse(ctx context.Context, body GetMediaPresignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMediaPresignedUrlResponse, error) {
	rsp, err := c.GetMediaPresignedUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaPresignedUrlResponse(rsp)
}

// ListPostsWithResponse request returning *ListPostsResponse
func (c *ClientWithResponses) ListPostsWithResponse(ctx context.Context, params *ListPostsParams, reqEditors ...RequestEditorFn) (*ListPostsResponse, error) {
	rsp, err := c.ListPosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPostsResponse(rsp)
}

// CreatePostWithBodyWithResponse request with arbitrary body returning *CreatePostResponse
func (c *ClientWithResponses) CreatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResponse, error) {
	rsp, err := c.CreatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResponse(rsp)
}

func (c *ClientWithResponses) CreatePostWithResponse(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResponse, error) {
	rsp, err := c.CreatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResponse(rsp)
}

// BulkUploadPostsWithBodyWithResponse request with arbitrary body returning *BulkUploadPostsResponse
func (c *ClientWithResponses) BulkUploadPostsWithBodyWithResponse(ctx context.Context, params *BulkUploadPostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPostsResponse, error) {
	rsp, err := c.BulkUploadPostsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadPostsResponse(rsp)
}

// DeletePostWithResponse request returning *DeletePostResponse
func (c *ClientWithResponses) DeletePostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*DeletePostResponse, error) {
	rsp, err := c.DeletePost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostResponse(rsp)
}

// GetPostWithResponse request returning *GetPostResponse
func (c *ClientWithResponses) GetPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*GetPostResponse, error) {
	rsp, err := c.GetPost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostResponse(rsp)
}

// UpdatePostWithBodyWithResponse request with arbitrary body returning *UpdatePostResponse
func (c *ClientWithResponses) UpdatePostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error) {
	rsp, err := c.UpdatePostWithBody(ctx, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostResponse(rsp)
}

func (c *ClientWithResponses) UpdatePostWithResponse(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error) {
	rsp, err := c.UpdatePost(ctx, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostResponse(rsp)
}

// GetPostLogsWithResponse request returning *GetPostLogsResponse
func (c *ClientWithResponses) GetPostLogsWithResponse(ctx context.Context, postId string, params *GetPostLogsParams, reqEditors ...RequestEditorFn) (*GetPostLogsResponse, error) {
	rsp, err := c.GetPostLogs(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostLogsResponse(rsp)
}

// RetryPostWithResponse request returning *RetryPostResponse
func (c *ClientWithResponses) RetryPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*RetryPostResponse, error) {
	rsp, err := c.RetryPost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryPostResponse(rsp)
}

// ListProfilesWithResponse request returning *ListProfilesResponse
func (c *ClientWithResponses) ListProfilesWithResponse(ctx context.Context, params *ListProfilesParams, reqEditors ...RequestEditorFn) (*ListProfilesResponse, error) {
	rsp, err := c.ListProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProfilesResponse(rsp)
}

// CreateProfileWithBodyWithResponse request with arbitrary body returning *CreateProfileResponse
func (c *ClientWithResponses) CreateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error) {
	rsp, err := c.CreateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateProfileWithResponse(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error) {
	rsp, err := c.CreateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProfileResponse(rsp)
}

// DeleteProfileWithResponse request returning *DeleteProfileResponse
func (c *ClientWithResponses) DeleteProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*DeleteProfileResponse, error) {
	rsp, err := c.DeleteProfile(ctx, profileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProfileResponse(rsp)
}

// GetProfileWithResponse request returning *GetProfileResponse
func (c *ClientWithResponses) GetProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*GetProfileResponse, error) {
	rsp, err := c.GetProfile(ctx, profileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileResponse(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, profileId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, profileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// GetNextQueueSlotWithResponse request returning *GetNextQueueSlotResponse
func (c *ClientWithResponses) GetNextQueueSlotWithResponse(ctx context.Context, params *GetNextQueueSlotParams, reqEditors ...RequestEditorFn) (*GetNextQueueSlotResponse, error) {
	rsp, err := c.GetNextQueueSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNextQueueSlotResponse(rsp)
}

// PreviewQueueWithResponse request returning *PreviewQueueResponse
func (c *ClientWithResponses) PreviewQueueWithResponse(ctx context.Context, params *PreviewQueueParams, reqEditors ...RequestEditorFn) (*PreviewQueueResponse, error) {
	rsp, err := c.PreviewQueue(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewQueueResponse(rsp)
}

// DeleteQueueSlotWithResponse request returning *DeleteQueueSlotResponse
func (c *ClientWithResponses) DeleteQueueSlotWithResponse(ctx context.Context, params *DeleteQueueSlotParams, reqEditors ...RequestEditorFn) (*DeleteQueueSlotResponse, error) {
	rsp, err := c.DeleteQueueSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQueueSlotResponse(rsp)
}

// ListQueueSlotsWithResponse request returning *ListQueueSlotsResponse
func (c *ClientWithResponses) ListQueueSlotsWithResponse(ctx context.Context, params *ListQueueSlotsParams, reqEditors ...RequestEditorFn) (*ListQueueSlotsResponse, error) {
	rsp, err := c.ListQueueSlots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQueueSlotsResponse(rsp)
}

// CreateQueueSlotWithBodyWithResponse request with arbitrary body returning *CreateQueueSlotResponse
func (c *ClientWithResponses) CreateQueueSlotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQueueSlotResponse, error) {
	rsp, err := c.CreateQueueSlotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQueueSlotResponse(rsp)
}

func (c *ClientWithResponses) CreateQueueSlotWithResponse(ctx context.Context, body CreateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQueueSlotResponse, error) {
	rsp, err := c.CreateQueueSlot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQueueSlotResponse(rsp)
}

// UpdateQueueSlotWithBodyWithResponse request with arbitrary body returning *UpdateQueueSlotResponse
func (c *ClientWithResponses) UpdateQueueSlotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateQueueSlotResponse, error) {
	rsp, err := c.UpdateQueueSlotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQueueSlotResponse(rsp)
}

func (c *ClientWithResponses) UpdateQueueSlotWithResponse(ctx context.Context, body UpdateQueueSlotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateQueueSlotResponse, error) {
	rsp, err := c.UpdateQueueSlot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQueueSlotResponse(rsp)
}

// GetRedditFeedWithResponse request returning *GetRedditFeedResponse
func (c *ClientWithResponses) GetRedditFeedWithResponse(ctx context.Context, params *GetRedditFeedParams, reqEditors ...RequestEditorFn) (*GetRedditFeedResponse, error) {
	rsp, err := c.GetRedditFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRedditFeedResponse(rsp)
}

// SearchRedditWithResponse request returning *SearchRedditResponse
func (c *ClientWithResponses) SearchRedditWithResponse(ctx context.Context, params *SearchRedditParams, reqEditors ...RequestEditorFn) (*SearchRedditResponse, error) {
	rsp, err := c.SearchReddit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRedditResponse(rsp)
}

// DownloadBlueskyMediaWithResponse request returning *DownloadBlueskyMediaResponse
func (c *ClientWithResponses) DownloadBlueskyMediaWithResponse(ctx context.Context, params *DownloadBlueskyMediaParams, reqEditors ...RequestEditorFn) (*DownloadBlueskyMediaResponse, error) {
	rsp, err := c.DownloadBlueskyMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadBlueskyMediaResponse(rsp)
}

// DownloadFacebookVideoWithResponse request returning *DownloadFacebookVideoResponse
func (c *ClientWithResponses) DownloadFacebookVideoWithResponse(ctx context.Context, params *DownloadFacebookVideoParams, reqEditors ...RequestEditorFn) (*DownloadFacebookVideoResponse, error) {
	rsp, err := c.DownloadFacebookVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadFacebookVideoResponse(rsp)
}

// DownloadInstagramMediaWithResponse request returning *DownloadInstagramMediaResponse
func (c *ClientWithResponses) DownloadInstagramMediaWithResponse(ctx context.Context, params *DownloadInstagramMediaParams, reqEditors ...RequestEditorFn) (*DownloadInstagramMediaResponse, error) {
	rsp, err := c.DownloadInstagramMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadInstagramMediaResponse(rsp)
}

// CheckInstagramHashtagsWithBodyWithResponse request with arbitrary body returning *CheckInstagramHashtagsResponse
func (c *ClientWithResponses) CheckInstagramHashtagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckInstagramHashtagsResponse, error) {
	rsp, err := c.CheckInstagramHashtagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckInstagramHashtagsResponse(rsp)
}

func (c *ClientWithResponses) CheckInstagramHashtagsWithResponse(ctx context.Context, body CheckInstagramHashtagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckInstagramHashtagsResponse, error) {
	rsp, err := c.CheckInstagramHashtags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckInstagramHashtagsResponse(rsp)
}

// DownloadLinkedInVideoWithResponse request returning *DownloadLinkedInVideoResponse
func (c *ClientWithResponses) DownloadLinkedInVideoWithResponse(ctx context.Context, params *DownloadLinkedInVideoParams, reqEditors ...RequestEditorFn) (*DownloadLinkedInVideoResponse, error) {
	rsp, err := c.DownloadLinkedInVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadLinkedInVideoResponse(rsp)
}

// DownloadTikTokVideoWithResponse request returning *DownloadTikTokVideoResponse
func (c *ClientWithResponses) DownloadTikTokVideoWithResponse(ctx context.Context, params *DownloadTikTokVideoParams, reqEditors ...RequestEditorFn) (*DownloadTikTokVideoResponse, error) {
	rsp, err := c.DownloadTikTokVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadTikTokVideoResponse(rsp)
}

// DownloadTwitterMediaWithResponse request returning *DownloadTwitterMediaResponse
func (c *ClientWithResponses) DownloadTwitterMediaWithResponse(ctx context.Context, params *DownloadTwitterMediaParams, reqEditors ...RequestEditorFn) (*DownloadTwitterMediaResponse, error) {
	rsp, err := c.DownloadTwitterMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadTwitterMediaResponse(rsp)
}

// DownloadYouTubeVideoWithResponse request returning *DownloadYouTubeVideoResponse
func (c *ClientWithResponses) DownloadYouTubeVideoWithResponse(ctx context.Context, params *DownloadYouTubeVideoParams, reqEditors ...RequestEditorFn) (*DownloadYouTubeVideoResponse, error) {
	rsp, err := c.DownloadYouTubeVideo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadYouTubeVideoResponse(rsp)
}

// GetYouTubeTranscriptWithResponse request returning *GetYouTubeTranscriptResponse
func (c *ClientWithResponses) GetYouTubeTranscriptWithResponse(ctx context.Context, params *GetYouTubeTranscriptParams, reqEditors ...RequestEditorFn) (*GetYouTubeTranscriptResponse, error) {
	rsp, err := c.GetYouTubeTranscript(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetYouTubeTranscriptResponse(rsp)
}

// GetUsageStatsWithResponse request returning *GetUsageStatsResponse
func (c *ClientWithResponses) GetUsageStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageStatsResponse, error) {
	rsp, err := c.GetUsageStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageStatsResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// GetWebhookLogsWithResponse request returning *GetWebhookLogsResponse
func (c *ClientWithResponses) GetWebhookLogsWithResponse(ctx context.Context, params *GetWebhookLogsParams, reqEditors ...RequestEditorFn) (*GetWebhookLogsResponse, error) {
	rsp, err := c.GetWebhookLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookLogsResponse(rsp)
}

// DeleteWebhookSettingsWithResponse request returning *DeleteWebhookSettingsResponse
func (c *ClientWithResponses) DeleteWebhookSettingsWithResponse(ctx context.Context, params *DeleteWebhookSettingsParams, reqEditors ...RequestEditorFn) (*DeleteWebhookSettingsResponse, error) {
	rsp, err := c.DeleteWebhookSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookSettingsResponse(rsp)
}

// GetWebhookSettingsWithResponse request returning *GetWebhookSettingsResponse
func (c *ClientWithResponses) GetWebhookSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhookSettingsResponse, error) {
	rsp, err := c.GetWebhookSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookSettingsResponse(rsp)
}

// CreateWebhookSettingsWithBodyWithResponse request with arbitrary body returning *CreateWebhookSettingsResponse
func (c *ClientWithResponses) CreateWebhookSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSettingsResponse, error) {
	rsp, err := c.CreateWebhookSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSettingsResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookSettingsWithResponse(ctx context.Context, body CreateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSettingsResponse, error) {
	rsp, err := c.CreateWebhookSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSettingsResponse(rsp)
}

// UpdateWebhookSettingsWithBodyWithResponse request with arbitrary body returning *UpdateWebhookSettingsResponse
func (c *ClientWithResponses) UpdateWebhookSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSettingsResponse, error) {
	rsp, err := c.UpdateWebhookSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookSettingsWithResponse(ctx context.Context, body UpdateWebhookSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSettingsResponse, error) {
	rsp, err := c.UpdateWebhookSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSettingsResponse(rsp)
}

// TestWebhookWithBodyWithResponse request with arbitrary body returning *TestWebhookResponse
func (c *ClientWithResponses) TestWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error) {
	rsp, err := c.TestWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhookResponse(rsp)
}

func (c *ClientWithResponses) TestWebhookWithResponse(ctx context.Context, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error) {
	rsp, err := c.TestWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhookResponse(rsp)
}

// ParseListAccountGroupsResponse parses an HTTP response from a ListAccountGroupsWithResponse call
func ParseListAccountGroupsResponse(rsp *http.Response) (*ListAccountGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Groups *[]struct {
				UnderscoreId *string   `json:"_id,omitempty"`
				AccountIds   *[]string `json:"accountIds,omitempty"`
				Name         *string   `json:"name,omitempty"`
			} `json:"groups,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateAccountGroupResponse parses an HTTP response from a CreateAccountGroupWithResponse call
func ParseCreateAccountGroupResponse(rsp *http.Response) (*CreateAccountGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Group *struct {
				UnderscoreId *string   `json:"_id,omitempty"`
				AccountIds   *[]string `json:"accountIds,omitempty"`
				Name         *string   `json:"name,omitempty"`
			} `json:"group,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAccountGroupResponse parses an HTTP response from a DeleteAccountGroupWithResponse call
func ParseDeleteAccountGroupResponse(rsp *http.Response) (*DeleteAccountGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAccountGroupResponse parses an HTTP response from a UpdateAccountGroupWithResponse call
func ParseUpdateAccountGroupResponse(rsp *http.Response) (*UpdateAccountGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Group   *map[string]interface{} `json:"group,omitempty"`
			Message *string                 `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts *[]SocialAccount `json:"accounts,omitempty"`

			// HasAnalyticsAccess Whether user has analytics add-on access
			HasAnalyticsAccess *bool `json:"hasAnalyticsAccess,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFollowerStatsResponse parses an HTTP response from a GetFollowerStatsWithResponse call
func ParseGetFollowerStatsResponse(rsp *http.Response) (*GetFollowerStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFollowerStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts  *[]AccountWithFollowerStats `json:"accounts,omitempty"`
			DateRange *struct {
				From *time.Time `json:"from,omitempty"`
				To   *time.Time `json:"to,omitempty"`
			} `json:"dateRange,omitempty"`
			Granularity *string `json:"granularity,omitempty"`
			Stats       *map[string][]struct {
				Date      *openapi_types.Date `json:"date,omitempty"`
				Followers *float32            `json:"followers,omitempty"`
			} `json:"stats,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Error         *string `json:"error,omitempty"`
			Message       *string `json:"message,omitempty"`
			RequiresAddon *bool   `json:"requiresAddon,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllAccountsHealthResponse parses an HTTP response from a GetAllAccountsHealthWithResponse call
func ParseGetAllAccountsHealthResponse(rsp *http.Response) (*GetAllAccountsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccountsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts *[]struct {
				AccountId         *string                                `json:"accountId,omitempty"`
				CanFetchAnalytics *bool                                  `json:"canFetchAnalytics,omitempty"`
				CanPost           *bool                                  `json:"canPost,omitempty"`
				DisplayName       *string                                `json:"displayName,omitempty"`
				Issues            *[]string                              `json:"issues,omitempty"`
				NeedsReconnect    *bool                                  `json:"needsReconnect,omitempty"`
				Platform          *string                                `json:"platform,omitempty"`
				ProfileId         *string                                `json:"profileId,omitempty"`
				Status            *GetAllAccountsHealth200AccountsStatus `json:"status,omitempty"`
				TokenExpiresAt    *time.Time                             `json:"tokenExpiresAt,omitempty"`
				TokenValid        *bool                                  `json:"tokenValid,omitempty"`
				Username          *string                                `json:"username,omitempty"`
			} `json:"accounts,omitempty"`
			Summary *struct {
				// Error Number of accounts with errors
				Error *int `json:"error,omitempty"`

				// Healthy Number of healthy accounts
				Healthy *int `json:"healthy,omitempty"`

				// NeedsReconnect Number of accounts needing reconnection
				NeedsReconnect *int `json:"needsReconnect,omitempty"`

				// Total Total number of accounts
				Total *int `json:"total,omitempty"`

				// Warning Number of accounts with warnings
				Warning *int `json:"warning,omitempty"`
			} `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAccountResponse parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResponse(rsp *http.Response) (*DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAccountResponse parses an HTTP response from a UpdateAccountWithResponse call
func ParseUpdateAccountResponse(rsp *http.Response) (*UpdateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DisplayName *string `json:"displayName,omitempty"`
			Message     *string `json:"message,omitempty"`
			Username    *string `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFacebookPagesResponse parses an HTTP response from a GetFacebookPagesWithResponse call
func ParseGetFacebookPagesResponse(rsp *http.Response) (*GetFacebookPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFacebookPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cached *bool `json:"cached,omitempty"`
			Pages  *[]struct {
				Category *string `json:"category,omitempty"`
				FanCount *int    `json:"fan_count,omitempty"`
				Id       *string `json:"id,omitempty"`
				Name     *string `json:"name,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"pages,omitempty"`
			SelectedPageId *string `json:"selectedPageId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateFacebookPageResponse parses an HTTP response from a UpdateFacebookPageWithResponse call
func ParseUpdateFacebookPageResponse(rsp *http.Response) (*UpdateFacebookPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFacebookPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message      *string `json:"message,omitempty"`
			SelectedPage *struct {
				Id   *string `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"selectedPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGoogleBusinessAttributesResponse parses an HTTP response from a GetGoogleBusinessAttributesWithResponse call
func ParseGetGoogleBusinessAttributesResponse(rsp *http.Response) (*GetGoogleBusinessAttributesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoogleBusinessAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string `json:"accountId,omitempty"`
			Attributes *[]struct {
				// Name Attribute identifier (e.g. has_delivery)
				Name              *string `json:"name,omitempty"`
				RepeatedEnumValue *struct {
					SetValues   *[]string `json:"setValues,omitempty"`
					UnsetValues *[]string `json:"unsetValues,omitempty"`
				} `json:"repeatedEnumValue,omitempty"`

				// ValueType Value type (BOOL, ENUM, URL, REPEATED_ENUM)
				ValueType *string        `json:"valueType,omitempty"`
				Values    *[]interface{} `json:"values,omitempty"`
			} `json:"attributes,omitempty"`
			LocationId *string `json:"locationId,omitempty"`
			Success    *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateGoogleBusinessAttributesResponse parses an HTTP response from a UpdateGoogleBusinessAttributesWithResponse call
func ParseUpdateGoogleBusinessAttributesResponse(rsp *http.Response) (*UpdateGoogleBusinessAttributesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGoogleBusinessAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string                   `json:"accountId,omitempty"`
			Attributes *[]map[string]interface{} `json:"attributes,omitempty"`
			LocationId *string                   `json:"locationId,omitempty"`
			Success    *bool                     `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGoogleBusinessFoodMenusResponse parses an HTTP response from a GetGoogleBusinessFoodMenusWithResponse call
func ParseGetGoogleBusinessFoodMenusResponse(rsp *http.Response) (*GetGoogleBusinessFoodMenusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoogleBusinessFoodMenusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string     `json:"accountId,omitempty"`
			LocationId *string     `json:"locationId,omitempty"`
			Menus      *[]FoodMenu `json:"menus,omitempty"`

			// Name Resource name of the food menus
			Name    *string `json:"name,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGoogleBusinessFoodMenusResponse parses an HTTP response from a UpdateGoogleBusinessFoodMenusWithResponse call
func ParseUpdateGoogleBusinessFoodMenusResponse(rsp *http.Response) (*UpdateGoogleBusinessFoodMenusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGoogleBusinessFoodMenusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string     `json:"accountId,omitempty"`
			LocationId *string     `json:"locationId,omitempty"`
			Menus      *[]FoodMenu `json:"menus,omitempty"`
			Name       *string     `json:"name,omitempty"`
			Success    *bool       `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGoogleBusinessLocationDetailsResponse parses an HTTP response from a GetGoogleBusinessLocationDetailsWithResponse call
func ParseGetGoogleBusinessLocationDetailsResponse(rsp *http.Response) (*GetGoogleBusinessLocationDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoogleBusinessLocationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId    *string `json:"accountId,omitempty"`
			LocationId   *string `json:"locationId,omitempty"`
			PhoneNumbers *struct {
				AdditionalPhones *[]string `json:"additionalPhones,omitempty"`
				PrimaryPhone     *string   `json:"primaryPhone,omitempty"`
			} `json:"phoneNumbers,omitempty"`
			Profile *struct {
				// Description Business description
				Description *string `json:"description,omitempty"`
			} `json:"profile,omitempty"`
			RegularHours *struct {
				Periods *[]struct {
					CloseDay  *string                                                        `json:"closeDay,omitempty"`
					CloseTime *string                                                        `json:"closeTime,omitempty"`
					OpenDay   *GetGoogleBusinessLocationDetails200RegularHoursPeriodsOpenDay `json:"openDay,omitempty"`

					// OpenTime Opening time in HH:MM format
					OpenTime *string `json:"openTime,omitempty"`
				} `json:"periods,omitempty"`
			} `json:"regularHours,omitempty"`
			SpecialHours *struct {
				SpecialHourPeriods *[]struct {
					CloseTime *string `json:"closeTime,omitempty"`
					Closed    *bool   `json:"closed,omitempty"`
					EndDate   *struct {
						Day   *int `json:"day,omitempty"`
						Month *int `json:"month,omitempty"`
						Year  *int `json:"year,omitempty"`
					} `json:"endDate,omitempty"`
					OpenTime  *string `json:"openTime,omitempty"`
					StartDate *struct {
						Day   *int `json:"day,omitempty"`
						Month *int `json:"month,omitempty"`
						Year  *int `json:"year,omitempty"`
					} `json:"startDate,omitempty"`
				} `json:"specialHourPeriods,omitempty"`
			} `json:"specialHours,omitempty"`
			Success *bool `json:"success,omitempty"`

			// Title Business name
			Title      *string `json:"title,omitempty"`
			WebsiteUri *string `json:"websiteUri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateGoogleBusinessLocationDetailsResponse parses an HTTP response from a UpdateGoogleBusinessLocationDetailsWithResponse call
func ParseUpdateGoogleBusinessLocationDetailsResponse(rsp *http.Response) (*UpdateGoogleBusinessLocationDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGoogleBusinessLocationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string `json:"accountId,omitempty"`
			LocationId *string `json:"locationId,omitempty"`
			Success    *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGmbLocationsResponse parses an HTTP response from a GetGmbLocationsWithResponse call
func ParseGetGmbLocationsResponse(rsp *http.Response) (*GetGmbLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGmbLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Cached    *bool `json:"cached,omitempty"`
			Locations *[]struct {
				AccountId   *string `json:"accountId,omitempty"`
				AccountName *string `json:"accountName,omitempty"`
				Address     *string `json:"address,omitempty"`
				Category    *string `json:"category,omitempty"`
				Id          *string `json:"id,omitempty"`
				Name        *string `json:"name,omitempty"`
				WebsiteUrl  *string `json:"websiteUrl,omitempty"`
			} `json:"locations,omitempty"`
			SelectedLocationId *string `json:"selectedLocationId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateGmbLocationResponse parses an HTTP response from a UpdateGmbLocationWithResponse call
func ParseUpdateGmbLocationResponse(rsp *http.Response) (*UpdateGmbLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGmbLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message          *string `json:"message,omitempty"`
			SelectedLocation *struct {
				Id   *string `json:"id,omitempty"`
				Name *string `json:"name,omitempty"`
			} `json:"selectedLocation,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteGoogleBusinessMediaResponse parses an HTTP response from a DeleteGoogleBusinessMediaWithResponse call
func ParseDeleteGoogleBusinessMediaResponse(rsp *http.Response) (*DeleteGoogleBusinessMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGoogleBusinessMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deleted *bool   `json:"deleted,omitempty"`
			MediaId *string `json:"mediaId,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListGoogleBusinessMediaResponse parses an HTTP response from a ListGoogleBusinessMediaWithResponse call
func ParseListGoogleBusinessMediaResponse(rsp *http.Response) (*ListGoogleBusinessMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGoogleBusinessMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId  *string `json:"accountId,omitempty"`
			LocationId *string `json:"locationId,omitempty"`
			MediaItems *[]struct {
				CreateTime  *time.Time `json:"createTime,omitempty"`
				Description *string    `json:"description,omitempty"`

				// GoogleUrl Google-hosted URL
				GoogleUrl           *string `json:"googleUrl,omitempty"`
				LocationAssociation *struct {
					Category *string `json:"category,omitempty"`
				} `json:"locationAssociation,omitempty"`
				MediaFormat *ListGoogleBusinessMedia200MediaItemsMediaFormat `json:"mediaFormat,omitempty"`

				// Name Resource name
				Name         *string `json:"name,omitempty"`
				SourceUrl    *string `json:"sourceUrl,omitempty"`
				ThumbnailUrl *string `json:"thumbnailUrl,omitempty"`
			} `json:"mediaItems,omitempty"`
			NextPageToken        *string `json:"nextPageToken,omitempty"`
			Success              *bool   `json:"success,omitempty"`
			TotalMediaItemsCount *int    `json:"totalMediaItemsCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateGoogleBusinessMediaResponse parses an HTTP response from a CreateGoogleBusinessMediaWithResponse call
func ParseCreateGoogleBusinessMediaResponse(rsp *http.Response) (*CreateGoogleBusinessMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGoogleBusinessMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			GoogleUrl   *string `json:"googleUrl,omitempty"`
			MediaFormat *string `json:"mediaFormat,omitempty"`
			Name        *string `json:"name,omitempty"`
			Success     *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteGoogleBusinessPlaceActionResponse parses an HTTP response from a DeleteGoogleBusinessPlaceActionWithResponse call
func ParseDeleteGoogleBusinessPlaceActionResponse(rsp *http.Response) (*DeleteGoogleBusinessPlaceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGoogleBusinessPlaceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deleted *bool   `json:"deleted,omitempty"`
			Name    *string `json:"name,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListGoogleBusinessPlaceActionsResponse parses an HTTP response from a ListGoogleBusinessPlaceActionsWithResponse call
func ParseListGoogleBusinessPlaceActionsResponse(rsp *http.Response) (*ListGoogleBusinessPlaceActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGoogleBusinessPlaceActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId        *string `json:"accountId,omitempty"`
			LocationId       *string `json:"locationId,omitempty"`
			NextPageToken    *string `json:"nextPageToken,omitempty"`
			PlaceActionLinks *[]struct {
				CreateTime *time.Time `json:"createTime,omitempty"`

				// Name Resource name
				Name            *string    `json:"name,omitempty"`
				PlaceActionType *string    `json:"placeActionType,omitempty"`
				UpdateTime      *time.Time `json:"updateTime,omitempty"`

				// Uri Action URL
				Uri *string `json:"uri,omitempty"`
			} `json:"placeActionLinks,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateGoogleBusinessPlaceActionResponse parses an HTTP response from a CreateGoogleBusinessPlaceActionWithResponse call
func ParseCreateGoogleBusinessPlaceActionResponse(rsp *http.Response) (*CreateGoogleBusinessPlaceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGoogleBusinessPlaceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Name Resource name of the created link
			Name            *string `json:"name,omitempty"`
			PlaceActionType *string `json:"placeActionType,omitempty"`
			Success         *bool   `json:"success,omitempty"`
			Uri             *string `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGoogleBusinessReviewsResponse parses an HTTP response from a GetGoogleBusinessReviewsWithResponse call
func ParseGetGoogleBusinessReviewsResponse(rsp *http.Response) (*GetGoogleBusinessReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoogleBusinessReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId *string `json:"accountId,omitempty"`

			// AverageRating Overall average rating
			AverageRating *float32 `json:"averageRating,omitempty"`
			LocationId    *string  `json:"locationId,omitempty"`

			// NextPageToken Token for next page
			NextPageToken *string `json:"nextPageToken"`
			Reviews       *[]struct {
				// Comment Review text
				Comment    *string    `json:"comment,omitempty"`
				CreateTime *time.Time `json:"createTime,omitempty"`

				// Id Review ID
				Id *string `json:"id,omitempty"`

				// Name Full resource name
				Name *string `json:"name,omitempty"`

				// Rating Numeric star rating
				Rating      *int `json:"rating,omitempty"`
				ReviewReply *struct {
					// Comment Business owner reply
					Comment    *string    `json:"comment,omitempty"`
					UpdateTime *time.Time `json:"updateTime,omitempty"`
				} `json:"reviewReply"`
				Reviewer *struct {
					DisplayName     *string `json:"displayName,omitempty"`
					IsAnonymous     *bool   `json:"isAnonymous,omitempty"`
					ProfilePhotoUrl *string `json:"profilePhotoUrl"`
				} `json:"reviewer,omitempty"`

				// StarRating Google's string rating
				StarRating *GetGoogleBusinessReviews200ReviewsStarRating `json:"starRating,omitempty"`
				UpdateTime *time.Time                                    `json:"updateTime,omitempty"`
			} `json:"reviews,omitempty"`
			Success *bool `json:"success,omitempty"`

			// TotalReviewCount Total number of reviews
			TotalReviewCount *int `json:"totalReviewCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccountHealthResponse parses an HTTP response from a GetAccountHealthWithResponse call
func ParseGetAccountHealthResponse(rsp *http.Response) (*GetAccountHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId   *string `json:"accountId,omitempty"`
			DisplayName *string `json:"displayName,omitempty"`

			// Issues List of issues found
			Issues      *[]string `json:"issues,omitempty"`
			Permissions *struct {
				Analytics *[]struct {
					Granted  *bool   `json:"granted,omitempty"`
					Required *bool   `json:"required,omitempty"`
					Scope    *string `json:"scope,omitempty"`
				} `json:"analytics,omitempty"`
				CanFetchAnalytics *bool     `json:"canFetchAnalytics,omitempty"`
				CanPost           *bool     `json:"canPost,omitempty"`
				MissingRequired   *[]string `json:"missingRequired,omitempty"`
				Optional          *[]struct {
					Granted  *bool   `json:"granted,omitempty"`
					Required *bool   `json:"required,omitempty"`
					Scope    *string `json:"scope,omitempty"`
				} `json:"optional,omitempty"`
				Posting *[]struct {
					Granted  *bool   `json:"granted,omitempty"`
					Required *bool   `json:"required,omitempty"`
					Scope    *string `json:"scope,omitempty"`
				} `json:"posting,omitempty"`
			} `json:"permissions,omitempty"`
			Platform *string `json:"platform,omitempty"`

			// Recommendations Actionable recommendations to fix issues
			Recommendations *[]string `json:"recommendations,omitempty"`

			// Status Overall health status
			Status      *GetAccountHealth200Status `json:"status,omitempty"`
			TokenStatus *struct {
				ExpiresAt *time.Time `json:"expiresAt,omitempty"`

				// ExpiresIn Human-readable time until expiry
				ExpiresIn *string `json:"expiresIn,omitempty"`

				// NeedsRefresh Whether token expires within 24 hours
				NeedsRefresh *bool `json:"needsRefresh,omitempty"`

				// Valid Whether the token is valid
				Valid *bool `json:"valid,omitempty"`
			} `json:"tokenStatus,omitempty"`
			Username *string `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLinkedInAggregateAnalyticsResponse parses an HTTP response from a GetLinkedInAggregateAnalyticsWithResponse call
func ParseGetLinkedInAggregateAnalyticsResponse(rsp *http.Response) (*GetLinkedInAggregateAnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkedInAggregateAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code         *string   `json:"code,omitempty"`
			Error        *string   `json:"error,omitempty"`
			ValidOptions *[]string `json:"validOptions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest struct {
			Code  *string `json:"code,omitempty"`
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Action        *string `json:"action,omitempty"`
			Code          *string `json:"code,omitempty"`
			Error         *string `json:"error,omitempty"`
			RequiredScope *string `json:"requiredScope,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetLinkedInMentionsResponse parses an HTTP response from a GetLinkedInMentionsWithResponse call
func ParseGetLinkedInMentionsResponse(rsp *http.Response) (*GetLinkedInMentionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkedInMentionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DisplayName Display name (provided, from API, or derived from vanity URL)
			DisplayName *string `json:"displayName,omitempty"`

			// MentionFormat Ready-to-use mention format for post content
			MentionFormat *string `json:"mentionFormat,omitempty"`

			// Type The type of entity (person or organization)
			Type *GetLinkedInMentions200Type `json:"type,omitempty"`

			// Urn The LinkedIn URN (person or organization)
			Urn *string `json:"urn,omitempty"`

			// VanityName The vanity name/slug (only for organization mentions)
			VanityName *string `json:"vanityName,omitempty"`

			// Warning Warning about clickable mentions (only present for person mentions if displayName was not provided)
			Warning *string `json:"warning,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLinkedInOrganizationResponse parses an HTTP response from a UpdateLinkedInOrganizationWithResponse call
func ParseUpdateLinkedInOrganizationResponse(rsp *http.Response) (*UpdateLinkedInOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLinkedInOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *SocialAccount `json:"account,omitempty"`
			Message *string        `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLinkedInOrganizationsResponse parses an HTTP response from a GetLinkedInOrganizationsWithResponse call
func ParseGetLinkedInOrganizationsResponse(rsp *http.Response) (*GetLinkedInOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkedInOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Organizations *[]struct {
				Id            *string `json:"id,omitempty"`
				LocalizedName *string `json:"localizedName,omitempty"`
				Name          *string `json:"name,omitempty"`
				VanityName    *string `json:"vanityName,omitempty"`
			} `json:"organizations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLinkedInPostAnalyticsResponse parses an HTTP response from a GetLinkedInPostAnalyticsWithResponse call
func ParseGetLinkedInPostAnalyticsResponse(rsp *http.Response) (*GetLinkedInPostAnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkedInPostAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId   *string                                 `json:"accountId,omitempty"`
			AccountType *GetLinkedInPostAnalytics200AccountType `json:"accountType,omitempty"`
			Analytics   *struct {
				// Clicks Clicks on the post (organization accounts only)
				Clicks *int `json:"clicks,omitempty"`

				// Comments Comments on the post
				Comments *int `json:"comments,omitempty"`

				// EngagementRate Engagement rate as percentage
				EngagementRate *float32 `json:"engagementRate,omitempty"`

				// Impressions Times the post was shown
				Impressions *int `json:"impressions,omitempty"`

				// Likes Reactions on the post
				Likes *int `json:"likes,omitempty"`

				// Reach Unique members who saw the post
				Reach *int `json:"reach,omitempty"`

				// Shares Reshares of the post
				Shares *int `json:"shares,omitempty"`

				// Views Video views (video posts only)
				Views *int `json:"views,omitempty"`
			} `json:"analytics,omitempty"`
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			Platform    *string    `json:"platform,omitempty"`
			PostUrn     *string    `json:"postUrn,omitempty"`
			Username    *string    `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code  *GetLinkedInPostAnalytics400Code `json:"code,omitempty"`
			Error *string                          `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Action        *string `json:"action,omitempty"`
			Code          *string `json:"code,omitempty"`
			Error         *string `json:"error,omitempty"`
			RequiredScope *string `json:"requiredScope,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code  *string `json:"code,omitempty"`
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPinterestBoardsResponse parses an HTTP response from a GetPinterestBoardsWithResponse call
func ParseGetPinterestBoardsResponse(rsp *http.Response) (*GetPinterestBoardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPinterestBoardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Boards *[]struct {
				Description *string `json:"description,omitempty"`
				Id          *string `json:"id,omitempty"`
				Name        *string `json:"name,omitempty"`
				Privacy     *string `json:"privacy,omitempty"`
			} `json:"boards,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePinterestBoardsResponse parses an HTTP response from a UpdatePinterestBoardsWithResponse call
func ParseUpdatePinterestBoardsResponse(rsp *http.Response) (*UpdatePinterestBoardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePinterestBoardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *SocialAccount `json:"account,omitempty"`
			Message *string        `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRedditSubredditsResponse parses an HTTP response from a GetRedditSubredditsWithResponse call
func ParseGetRedditSubredditsResponse(rsp *http.Response) (*GetRedditSubredditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRedditSubredditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DefaultSubreddit Currently set default subreddit for posting
			DefaultSubreddit *string `json:"defaultSubreddit,omitempty"`
			Subreddits       *[]struct {
				// Id Reddit subreddit ID
				Id *string `json:"id,omitempty"`

				// Name Subreddit name without r/ prefix
				Name *string `json:"name,omitempty"`

				// Over18 Whether the subreddit is NSFW
				Over18 *bool `json:"over18,omitempty"`

				// Title Subreddit title
				Title *string `json:"title,omitempty"`

				// Url Subreddit URL path
				Url *string `json:"url,omitempty"`
			} `json:"subreddits,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateRedditSubredditsResponse parses an HTTP response from a UpdateRedditSubredditsWithResponse call
func ParseUpdateRedditSubredditsResponse(rsp *http.Response) (*UpdateRedditSubredditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRedditSubredditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAnalyticsResponse parses an HTTP response from a GetAnalyticsWithResponse call
func ParseGetAnalyticsResponse(rsp *http.Response) (*GetAnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest struct {
			Code  *string `json:"code,omitempty"`
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetYouTubeDailyViewsResponse parses an HTTP response from a GetYouTubeDailyViewsWithResponse call
func ParseGetYouTubeDailyViewsResponse(rsp *http.Response) (*GetYouTubeDailyViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetYouTubeDailyViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest YouTubeDailyViewsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest struct {
			Code  *string `json:"code,omitempty"`
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest YouTubeScopeMissingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error   *string `json:"error,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListApiKeysResponse parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysResponse(rsp *http.Response) (*ListApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ApiKeys *[]ApiKey `json:"apiKeys,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyResponse parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyResponse(rsp *http.Response) (*CreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			ApiKey  *ApiKey `json:"apiKey,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyResponse parses an HTTP response from a DeleteApiKeyWithResponse call
func ParseDeleteApiKeyResponse(rsp *http.Response) (*DeleteApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseConnectBlueskyCredentialsResponse parses an HTTP response from a ConnectBlueskyCredentialsWithResponse call
func ParseConnectBlueskyCredentialsResponse(rsp *http.Response) (*ConnectBlueskyCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectBlueskyCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *SocialAccount `json:"account,omitempty"`
			Message *string        `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListFacebookPagesResponse parses an HTTP response from a ListFacebookPagesWithResponse call
func ParseListFacebookPagesResponse(rsp *http.Response) (*ListFacebookPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFacebookPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Pages *[]struct {
				// AccessToken Page-specific access token
				AccessToken *string `json:"access_token,omitempty"`

				// Category Page category
				Category *string `json:"category,omitempty"`

				// Id Facebook Page ID
				Id *string `json:"id,omitempty"`

				// Name Page name
				Name *string `json:"name,omitempty"`

				// Tasks User permissions for this page
				Tasks *[]string `json:"tasks,omitempty"`

				// Username Page username/handle (may be null)
				Username *string `json:"username,omitempty"`
			} `json:"pages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSelectFacebookPageResponse parses an HTTP response from a SelectFacebookPageWithResponse call
func ParseSelectFacebookPageResponse(rsp *http.Response) (*SelectFacebookPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectFacebookPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				// AccountId ID of the created SocialAccount
				AccountId        *string                               `json:"accountId,omitempty"`
				DisplayName      *string                               `json:"displayName,omitempty"`
				IsActive         *bool                                 `json:"isActive,omitempty"`
				Platform         *SelectFacebookPage200AccountPlatform `json:"platform,omitempty"`
				ProfilePicture   *string                               `json:"profilePicture,omitempty"`
				SelectedPageName *string                               `json:"selectedPageName,omitempty"`
				Username         *string                               `json:"username,omitempty"`
			} `json:"account,omitempty"`
			Message *string `json:"message,omitempty"`

			// RedirectUrl Redirect URL if custom redirect_url was provided
			RedirectUrl *string `json:"redirect_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListGoogleBusinessLocationsResponse parses an HTTP response from a ListGoogleBusinessLocationsWithResponse call
func ParseListGoogleBusinessLocationsResponse(rsp *http.Response) (*ListGoogleBusinessLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGoogleBusinessLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Locations *[]struct {
				// AccountId Google Business Account ID
				AccountId *string `json:"accountId,omitempty"`

				// AccountName Account name
				AccountName *string `json:"accountName,omitempty"`

				// Address Business address
				Address *string `json:"address,omitempty"`

				// Category Business category
				Category *string `json:"category,omitempty"`

				// Id Location ID
				Id *string `json:"id,omitempty"`

				// Name Business name
				Name *string `json:"name,omitempty"`
			} `json:"locations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSelectGoogleBusinessLocationResponse parses an HTTP response from a SelectGoogleBusinessLocationWithResponse call
func ParseSelectGoogleBusinessLocationResponse(rsp *http.Response) (*SelectGoogleBusinessLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectGoogleBusinessLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				// AccountId ID of the created SocialAccount
				AccountId            *string                                         `json:"accountId,omitempty"`
				DisplayName          *string                                         `json:"displayName,omitempty"`
				IsActive             *bool                                           `json:"isActive,omitempty"`
				Platform             *SelectGoogleBusinessLocation200AccountPlatform `json:"platform,omitempty"`
				SelectedLocationId   *string                                         `json:"selectedLocationId,omitempty"`
				SelectedLocationName *string                                         `json:"selectedLocationName,omitempty"`
				Username             *string                                         `json:"username,omitempty"`
			} `json:"account,omitempty"`
			Message *string `json:"message,omitempty"`

			// RedirectUrl Redirect URL if custom redirect_url was provided
			RedirectUrl *string `json:"redirect_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListLinkedInOrganizationsResponse parses an HTTP response from a ListLinkedInOrganizationsWithResponse call
func ParseListLinkedInOrganizationsResponse(rsp *http.Response) (*ListLinkedInOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinkedInOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Organizations *[]struct {
				// Description Organization's description
				Description *string `json:"description,omitempty"`

				// Id Organization ID
				Id *string `json:"id,omitempty"`

				// Industry Organization's primary industry
				Industry *string `json:"industry,omitempty"`

				// LogoUrl Logo URL (may be absent if no logo)
				LogoUrl *string `json:"logoUrl,omitempty"`

				// VanityName Organization's vanity name/slug
				VanityName *string `json:"vanityName,omitempty"`

				// Website Organization's website URL
				Website *string `json:"website,omitempty"`
			} `json:"organizations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSelectLinkedInOrganizationResponse parses an HTTP response from a SelectLinkedInOrganizationWithResponse call
func ParseSelectLinkedInOrganizationResponse(rsp *http.Response) (*SelectLinkedInOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectLinkedInOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				// AccountId ID of the created SocialAccount
				AccountId      *string                                          `json:"accountId,omitempty"`
				AccountType    *SelectLinkedInOrganization200AccountAccountType `json:"accountType,omitempty"`
				DisplayName    *string                                          `json:"displayName,omitempty"`
				IsActive       *bool                                            `json:"isActive,omitempty"`
				Platform       *SelectLinkedInOrganization200AccountPlatform    `json:"platform,omitempty"`
				ProfilePicture *string                                          `json:"profilePicture,omitempty"`
				Username       *string                                          `json:"username,omitempty"`
			} `json:"account,omitempty"`
			BulkRefresh *struct {
				Errors       *int `json:"errors,omitempty"`
				UpdatedCount *int `json:"updatedCount,omitempty"`
			} `json:"bulkRefresh,omitempty"`
			Message *string `json:"message,omitempty"`

			// RedirectUrl The redirect URL with connection params appended (only if redirect_url was provided in request)
			RedirectUrl *string `json:"redirect_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPendingOAuthDataResponse parses an HTTP response from a GetPendingOAuthDataWithResponse call
func ParseGetPendingOAuthDataResponse(rsp *http.Response) (*GetPendingOAuthDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingOAuthDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExpiresIn Token expiry in seconds
			ExpiresIn *float32 `json:"expiresIn,omitempty"`

			// Organizations LinkedIn organizations (when selectionType is "organizations")
			Organizations *[]struct {
				Id         *string `json:"id,omitempty"`
				Name       *string `json:"name,omitempty"`
				Urn        *string `json:"urn,omitempty"`
				VanityName *string `json:"vanityName,omitempty"`
			} `json:"organizations,omitempty"`

			// Platform The platform (e.g., "linkedin")
			Platform *string `json:"platform,omitempty"`

			// ProfileId The Late profile ID
			ProfileId *string `json:"profileId,omitempty"`

			// RefreshToken Refresh token (if available)
			RefreshToken *string `json:"refreshToken,omitempty"`

			// SelectionType Type of selection data
			SelectionType *GetPendingOAuthData200SelectionType `json:"selectionType,omitempty"`

			// TempToken Temporary access token for the platform
			TempToken *string `json:"tempToken,omitempty"`

			// UserProfile User profile data (id, username, displayName, profilePicture)
			UserProfile *map[string]interface{} `json:"userProfile,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPinterestBoardsForSelectionResponse parses an HTTP response from a ListPinterestBoardsForSelectionWithResponse call
func ParseListPinterestBoardsForSelectionResponse(rsp *http.Response) (*ListPinterestBoardsForSelectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPinterestBoardsForSelectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Boards *[]struct {
				// Description Board description
				Description *string `json:"description,omitempty"`

				// Id Pinterest Board ID
				Id *string `json:"id,omitempty"`

				// Name Board name
				Name *string `json:"name,omitempty"`

				// Privacy Board privacy setting
				Privacy *string `json:"privacy,omitempty"`
			} `json:"boards,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSelectPinterestBoardResponse parses an HTTP response from a SelectPinterestBoardWithResponse call
func ParseSelectPinterestBoardResponse(rsp *http.Response) (*SelectPinterestBoardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectPinterestBoardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				// AccountId ID of the created SocialAccount
				AccountId        *string                                 `json:"accountId,omitempty"`
				DefaultBoardName *string                                 `json:"defaultBoardName,omitempty"`
				DisplayName      *string                                 `json:"displayName,omitempty"`
				IsActive         *bool                                   `json:"isActive,omitempty"`
				Platform         *SelectPinterestBoard200AccountPlatform `json:"platform,omitempty"`
				ProfilePicture   *string                                 `json:"profilePicture,omitempty"`
				Username         *string                                 `json:"username,omitempty"`
			} `json:"account,omitempty"`
			Message *string `json:"message,omitempty"`

			// RedirectUrl Redirect URL with connection params (if provided)
			RedirectUrl *string `json:"redirect_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListSnapchatProfilesResponse parses an HTTP response from a ListSnapchatProfilesWithResponse call
func ParseListSnapchatProfilesResponse(rsp *http.Response) (*ListSnapchatProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSnapchatProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PublicProfiles *[]struct {
				// DisplayName Public profile display name
				DisplayName *string `json:"display_name,omitempty"`

				// Id Snapchat Public Profile ID
				Id *string `json:"id,omitempty"`

				// ProfileImageUrl Profile image URL
				ProfileImageUrl *string `json:"profile_image_url,omitempty"`

				// SubscriberCount Number of subscribers
				SubscriberCount *int `json:"subscriber_count,omitempty"`

				// Username Public profile username/handle
				Username *string `json:"username,omitempty"`
			} `json:"publicProfiles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSelectSnapchatProfileResponse parses an HTTP response from a SelectSnapchatProfileWithResponse call
func ParseSelectSnapchatProfileResponse(rsp *http.Response) (*SelectSnapchatProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectSnapchatProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				// AccountId ID of the created SocialAccount
				AccountId         *string                                  `json:"accountId,omitempty"`
				DisplayName       *string                                  `json:"displayName,omitempty"`
				IsActive          *bool                                    `json:"isActive,omitempty"`
				Platform          *SelectSnapchatProfile200AccountPlatform `json:"platform,omitempty"`
				ProfilePicture    *string                                  `json:"profilePicture,omitempty"`
				PublicProfileName *string                                  `json:"publicProfileName,omitempty"`
				Username          *string                                  `json:"username,omitempty"`
			} `json:"account,omitempty"`
			Message *string `json:"message,omitempty"`

			// RedirectUrl Redirect URL with connection params (if provided in request)
			RedirectUrl *string `json:"redirect_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTelegramConnectStatusResponse parses an HTTP response from a GetTelegramConnectStatusWithResponse call
func ParseGetTelegramConnectStatusResponse(rsp *http.Response) (*GetTelegramConnectStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTelegramConnectStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BotUsername The Telegram bot username to message
			BotUsername *string `json:"botUsername,omitempty"`

			// Code The access code to send to the Telegram bot
			Code *string `json:"code,omitempty"`

			// ExpiresAt When the code expires
			ExpiresAt *time.Time `json:"expiresAt,omitempty"`

			// ExpiresIn Seconds until expiration
			ExpiresIn *int `json:"expiresIn,omitempty"`

			// Instructions Step-by-step connection instructions
			Instructions *[]string `json:"instructions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCompleteTelegramConnectResponse parses an HTTP response from a CompleteTelegramConnectWithResponse call
func ParseCompleteTelegramConnectResponse(rsp *http.Response) (*CompleteTelegramConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteTelegramConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseInitiateTelegramConnectResponse parses an HTTP response from a InitiateTelegramConnectWithResponse call
func ParseInitiateTelegramConnectResponse(rsp *http.Response) (*InitiateTelegramConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateTelegramConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Account *struct {
				UnderscoreId *string                                    `json:"_id,omitempty"`
				ChatType     *InitiateTelegramConnect200AccountChatType `json:"chatType,omitempty"`
				DisplayName  *string                                    `json:"displayName,omitempty"`
				IsActive     *bool                                      `json:"isActive,omitempty"`
				Platform     *InitiateTelegramConnect200AccountPlatform `json:"platform,omitempty"`
				Username     *string                                    `json:"username,omitempty"`
			} `json:"account,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConnectUrlResponse parses an HTTP response from a GetConnectUrlWithResponse call
func ParseGetConnectUrlResponse(rsp *http.Response) (*GetConnectUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AuthUrl URL to redirect your user to for OAuth authorization
			AuthUrl *string `json:"authUrl,omitempty"`

			// State State parameter for security (handled automatically)
			State *string `json:"state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHandleOAuthCallbackResponse parses an HTTP response from a HandleOAuthCallbackWithResponse call
func ParseHandleOAuthCallbackResponse(rsp *http.Response) (*HandleOAuthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandleOAuthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListInboxCommentsResponse parses an HTTP response from a ListInboxCommentsWithResponse call
func ParseListInboxCommentsResponse(rsp *http.Response) (*ListInboxCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboxCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AccountId       *string `json:"accountId,omitempty"`
				AccountUsername *string `json:"accountUsername,omitempty"`

				// Cid Bluesky content identifier
				Cid          *string    `json:"cid"`
				CommentCount *int       `json:"commentCount,omitempty"`
				Content      *string    `json:"content,omitempty"`
				CreatedTime  *time.Time `json:"createdTime,omitempty"`
				Id           *string    `json:"id,omitempty"`
				LikeCount    *int       `json:"likeCount,omitempty"`
				Permalink    *string    `json:"permalink"`
				Picture      *string    `json:"picture"`
				Platform     *string    `json:"platform,omitempty"`

				// Subreddit Reddit subreddit name
				Subreddit *string `json:"subreddit"`
			} `json:"data,omitempty"`
			Meta *struct {
				AccountsFailed  *int `json:"accountsFailed,omitempty"`
				AccountsQueried *int `json:"accountsQueried,omitempty"`
				FailedAccounts  *[]struct {
					AccountId       *string `json:"accountId,omitempty"`
					AccountUsername *string `json:"accountUsername"`

					// Code Error code if available
					Code     *string `json:"code"`
					Error    *string `json:"error,omitempty"`
					Platform *string `json:"platform,omitempty"`

					// RetryAfter Seconds to wait before retry (rate limits)
					RetryAfter *int `json:"retryAfter"`
				} `json:"failedAccounts,omitempty"`
				LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			} `json:"meta,omitempty"`
			Pagination *struct {
				HasMore    *bool   `json:"hasMore,omitempty"`
				NextCursor *string `json:"nextCursor"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteInboxCommentResponse parses an HTTP response from a DeleteInboxCommentWithResponse call
func ParseDeleteInboxCommentResponse(rsp *http.Response) (*DeleteInboxCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInboxCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Message *string `json:"message,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetInboxPostCommentsResponse parses an HTTP response from a GetInboxPostCommentsWithResponse call
func ParseGetInboxPostCommentsResponse(rsp *http.Response) (*GetInboxPostCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboxPostCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments *[]struct {
				CanDelete *bool `json:"canDelete,omitempty"`

				// CanHide Whether this comment can be hidden (Facebook
				CanHide *bool `json:"canHide,omitempty"`

				// CanLike Whether this comment can be liked (Facebook
				CanLike  *bool `json:"canLike,omitempty"`
				CanReply *bool `json:"canReply,omitempty"`

				// Cid Bluesky content identifier
				Cid         *string    `json:"cid"`
				CreatedTime *time.Time `json:"createdTime,omitempty"`
				From        *struct {
					Id       *string `json:"id,omitempty"`
					IsOwner  *bool   `json:"isOwner,omitempty"`
					Name     *string `json:"name,omitempty"`
					Picture  *string `json:"picture"`
					Username *string `json:"username,omitempty"`
				} `json:"from,omitempty"`
				Id *string `json:"id,omitempty"`

				// IsHidden Whether the comment is currently hidden
				IsHidden *bool `json:"isHidden,omitempty"`

				// IsLiked Whether the current user has liked this comment
				IsLiked   *bool `json:"isLiked,omitempty"`
				LikeCount *int  `json:"likeCount,omitempty"`

				// LikeUri Bluesky like URI for unliking
				LikeUri *string `json:"likeUri"`
				Message *string `json:"message,omitempty"`

				// ParentId Parent comment ID for nested replies
				ParentId *string `json:"parentId"`

				// Platform The platform this comment is from
				Platform   *string                   `json:"platform,omitempty"`
				Replies    *[]map[string]interface{} `json:"replies,omitempty"`
				ReplyCount *int                      `json:"replyCount,omitempty"`

				// RootCid Bluesky root post CID
				RootCid *string `json:"rootCid"`

				// RootUri Bluesky root post URI
				RootUri *string `json:"rootUri"`

				// Url Direct link to the comment on the platform (if available)
				Url *string `json:"url"`
			} `json:"comments,omitempty"`
			Meta *struct {
				AccountId   *string    `json:"accountId,omitempty"`
				LastUpdated *time.Time `json:"lastUpdated,omitempty"`
				Platform    *string    `json:"platform,omitempty"`
				PostId      *string    `json:"postId,omitempty"`

				// Subreddit (Reddit only) Subreddit name
				Subreddit *string `json:"subreddit"`
			} `json:"meta,omitempty"`
			Pagination *struct {
				Cursor  *string `json:"cursor"`
				HasMore *bool   `json:"hasMore,omitempty"`
			} `json:"pagination,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseReplyToInboxPostResponse parses an HTTP response from a ReplyToInboxPostWithResponse call
func ParseReplyToInboxPostResponse(rsp *http.Response) (*ReplyToInboxPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplyToInboxPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Cid Bluesky CID
				Cid       *string `json:"cid"`
				CommentId *string `json:"commentId,omitempty"`
				IsReply   *bool   `json:"isReply,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUnhideInboxCommentResponse parses an HTTP response from a UnhideInboxCommentWithResponse call
func ParseUnhideInboxCommentResponse(rsp *http.Response) (*UnhideInboxCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnhideInboxCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CommentId *string `json:"commentId,omitempty"`
			Hidden    *bool   `json:"hidden,omitempty"`
			Platform  *string `json:"platform,omitempty"`
			Status    *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHideInboxCommentResponse parses an HTTP response from a HideInboxCommentWithResponse call
func ParseHideInboxCommentResponse(rsp *http.Response) (*HideInboxCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HideInboxCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CommentId *string `json:"commentId,omitempty"`
			Hidden    *bool   `json:"hidden,omitempty"`
			Platform  *string `json:"platform,omitempty"`
			Status    *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUnlikeInboxCommentResponse parses an HTTP response from a UnlikeInboxCommentWithResponse call
func ParseUnlikeInboxCommentResponse(rsp *http.Response) (*UnlikeInboxCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlikeInboxCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CommentId *string `json:"commentId,omitempty"`
			Liked     *bool   `json:"liked,omitempty"`
			Platform  *string `json:"platform,omitempty"`
			Status    *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLikeInboxCommentResponse parses an HTTP response from a LikeInboxCommentWithResponse call
func ParseLikeInboxCommentResponse(rsp *http.Response) (*LikeInboxCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LikeInboxCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CommentId *string `json:"commentId,omitempty"`

			// LikeUri (Bluesky only) URI to use for unliking
			LikeUri  *string `json:"likeUri,omitempty"`
			Liked    *bool   `json:"liked,omitempty"`
			Platform *string `json:"platform,omitempty"`
			Status   *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSendPrivateReplyToCommentResponse parses an HTTP response from a SendPrivateReplyToCommentWithResponse call
func ParseSendPrivateReplyToCommentResponse(rsp *http.Response) (*SendPrivateReplyToCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPrivateReplyToCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CommentId The comment ID that was replied to
			CommentId *string `json:"commentId,omitempty"`

			// MessageId The ID of the sent message
			MessageId *string `json:"messageId,omitempty"`
			Platform  *string `json:"platform,omitempty"`
			Status    *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code  *SendPrivateReplyToComment400Code `json:"code,omitempty"`
			Error *string                           `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListInboxConversationsResponse parses an HTTP response from a ListInboxConversationsWithResponse call
func ParseListInboxConversationsResponse(rsp *http.Response) (*ListInboxConversationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboxConversationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AccountId          *string                              `json:"accountId,omitempty"`
				AccountUsername    *string                              `json:"accountUsername,omitempty"`
				Id                 *string                              `json:"id,omitempty"`
				LastMessage        *string                              `json:"lastMessage,omitempty"`
				ParticipantId      *string                              `json:"participantId,omitempty"`
				ParticipantName    *string                              `json:"participantName,omitempty"`
				ParticipantPicture *string                              `json:"participantPicture"`
				Platform           *string                              `json:"platform,omitempty"`
				Status             *ListInboxConversations200DataStatus `json:"status,omitempty"`

				// UnreadCount Number of unread messages
				UnreadCount *int       `json:"unreadCount"`
				UpdatedTime *time.Time `json:"updatedTime,omitempty"`

				// Url Direct link to open the conversation on the platform (if available)
				Url *string `json:"url"`
			} `json:"data,omitempty"`
			Meta *struct {
				AccountsFailed  *int `json:"accountsFailed,omitempty"`
				AccountsQueried *int `json:"accountsQueried,omitempty"`
				FailedAccounts  *[]struct {
					AccountId       *string `json:"accountId,omitempty"`
					AccountUsername *string `json:"accountUsername"`

					// Code Error code if available
					Code     *string `json:"code"`
					Error    *string `json:"error,omitempty"`
					Platform *string `json:"platform,omitempty"`

					// RetryAfter Seconds to wait before retry (rate limits)
					RetryAfter *int `json:"retryAfter"`
				} `json:"failedAccounts,omitempty"`
				LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			} `json:"meta,omitempty"`
			Pagination *struct {
				HasMore    *bool   `json:"hasMore,omitempty"`
				NextCursor *string `json:"nextCursor"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetInboxConversationResponse parses an HTTP response from a GetInboxConversationWithResponse call
func ParseGetInboxConversationResponse(rsp *http.Response) (*GetInboxConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboxConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AccountId       *string    `json:"accountId,omitempty"`
				AccountUsername *string    `json:"accountUsername,omitempty"`
				Id              *string    `json:"id,omitempty"`
				LastMessage     *string    `json:"lastMessage,omitempty"`
				LastMessageAt   *time.Time `json:"lastMessageAt,omitempty"`
				ParticipantId   *string    `json:"participantId,omitempty"`
				ParticipantName *string    `json:"participantName,omitempty"`
				Participants    *[]struct {
					Id   *string `json:"id,omitempty"`
					Name *string `json:"name,omitempty"`
				} `json:"participants,omitempty"`
				Platform    *string                            `json:"platform,omitempty"`
				Status      *GetInboxConversation200DataStatus `json:"status,omitempty"`
				UpdatedTime *time.Time                         `json:"updatedTime,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateInboxConversationResponse parses an HTTP response from a UpdateInboxConversationWithResponse call
func ParseUpdateInboxConversationResponse(rsp *http.Response) (*UpdateInboxConversationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInboxConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AccountId *string                               `json:"accountId,omitempty"`
				Id        *string                               `json:"id,omitempty"`
				Platform  *string                               `json:"platform,omitempty"`
				Status    *UpdateInboxConversation200DataStatus `json:"status,omitempty"`
				UpdatedAt *time.Time                            `json:"updatedAt,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetInboxConversationMessagesResponse parses an HTTP response from a GetInboxConversationMessagesWithResponse call
func ParseGetInboxConversationMessagesResponse(rsp *http.Response) (*GetInboxConversationMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboxConversationMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			Messages    *[]struct {
				AccountId   *string `json:"accountId,omitempty"`
				Attachments *[]struct {
					Filename   *string                                                 `json:"filename"`
					Id         *string                                                 `json:"id,omitempty"`
					PreviewUrl *string                                                 `json:"previewUrl"`
					Type       *GetInboxConversationMessages200MessagesAttachmentsType `json:"type,omitempty"`
					Url        *string                                                 `json:"url,omitempty"`
				} `json:"attachments,omitempty"`
				ConversationId *string                                           `json:"conversationId,omitempty"`
				CreatedAt      *time.Time                                        `json:"createdAt,omitempty"`
				Direction      *GetInboxConversationMessages200MessagesDirection `json:"direction,omitempty"`
				Id             *string                                           `json:"id,omitempty"`

				// IsStoryMention Instagram story mention
				IsStoryMention *bool   `json:"isStoryMention"`
				Message        *string `json:"message,omitempty"`
				Platform       *string `json:"platform,omitempty"`
				SenderId       *string `json:"senderId,omitempty"`
				SenderName     *string `json:"senderName"`

				// StoryReply Instagram story reply
				StoryReply *bool `json:"storyReply"`

				// Subject Reddit message subject
				Subject *string `json:"subject"`
			} `json:"messages,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSendInboxMessageResponse parses an HTTP response from a SendInboxMessageWithResponse call
func ParseSendInboxMessageResponse(rsp *http.Response) (*SendInboxMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendInboxMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ConversationId Twitter conversation ID
				ConversationId *string `json:"conversationId"`

				// Message Success message (Reddit only)
				Message *string `json:"message"`

				// MessageId ID of the sent message (not returned for Reddit)
				MessageId *string `json:"messageId,omitempty"`

				// SentAt Bluesky sent timestamp
				SentAt *time.Time `json:"sentAt"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code  *SendInboxMessage400Code `json:"code,omitempty"`
			Error *string                  `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListInboxReviewsResponse parses an HTTP response from a ListInboxReviewsWithResponse call
func ParseListInboxReviewsResponse(rsp *http.Response) (*ListInboxReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboxReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AccountId       *string    `json:"accountId,omitempty"`
				AccountUsername *string    `json:"accountUsername,omitempty"`
				Created         *time.Time `json:"created,omitempty"`
				HasReply        *bool      `json:"hasReply,omitempty"`
				Id              *string    `json:"id,omitempty"`
				Platform        *string    `json:"platform,omitempty"`
				Rating          *int       `json:"rating,omitempty"`
				Reply           *struct {
					Created *time.Time `json:"created,omitempty"`
					Id      *string    `json:"id,omitempty"`
					Text    *string    `json:"text,omitempty"`
				} `json:"reply"`
				ReviewUrl *string `json:"reviewUrl"`
				Reviewer  *struct {
					Id           *string `json:"id"`
					Name         *string `json:"name,omitempty"`
					ProfileImage *string `json:"profileImage"`
				} `json:"reviewer,omitempty"`
				Text *string `json:"text,omitempty"`
			} `json:"data,omitempty"`
			Meta *struct {
				AccountsFailed  *int `json:"accountsFailed,omitempty"`
				AccountsQueried *int `json:"accountsQueried,omitempty"`
				FailedAccounts  *[]struct {
					AccountId       *string `json:"accountId,omitempty"`
					AccountUsername *string `json:"accountUsername"`

					// Code Error code if available
					Code     *string `json:"code"`
					Error    *string `json:"error,omitempty"`
					Platform *string `json:"platform,omitempty"`

					// RetryAfter Seconds to wait before retry (rate limits)
					RetryAfter *int `json:"retryAfter"`
				} `json:"failedAccounts,omitempty"`
				LastUpdated *time.Time `json:"lastUpdated,omitempty"`
			} `json:"meta,omitempty"`
			Pagination *struct {
				HasMore    *bool   `json:"hasMore,omitempty"`
				NextCursor *string `json:"nextCursor"`
			} `json:"pagination,omitempty"`
			Status  *string `json:"status,omitempty"`
			Summary *struct {
				AverageRating *float32 `json:"averageRating"`
				TotalReviews  *int     `json:"totalReviews,omitempty"`
			} `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteInboxReviewReplyResponse parses an HTTP response from a DeleteInboxReviewReplyWithResponse call
func ParseDeleteInboxReviewReplyResponse(rsp *http.Response) (*DeleteInboxReviewReplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInboxReviewReplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message  *string `json:"message,omitempty"`
			Platform *string `json:"platform,omitempty"`
			Status   *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseReplyToInboxReviewResponse parses an HTTP response from a ReplyToInboxReviewWithResponse call
func ParseReplyToInboxReviewResponse(rsp *http.Response) (*ReplyToInboxReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplyToInboxReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Platform *string `json:"platform,omitempty"`
			Reply    *struct {
				Created *time.Time `json:"created,omitempty"`
				Id      *string    `json:"id,omitempty"`
				Text    *string    `json:"text,omitempty"`
			} `json:"reply,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateInviteTokenResponse parses an HTTP response from a CreateInviteTokenWithResponse call
func ParseCreateInviteTokenResponse(rsp *http.Response) (*CreateInviteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInviteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			ExpiresAt         *time.Time `json:"expiresAt,omitempty"`
			InviteUrl         *string    `json:"inviteUrl,omitempty"`
			InvitedProfileIds *[]string  `json:"invitedProfileIds,omitempty"`
			Scope             *string    `json:"scope,omitempty"`
			Token             *string    `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListLogsResponse parses an HTTP response from a ListLogsWithResponse call
func ParseListLogsResponse(rsp *http.Response) (*ListLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Logs       *[]PostLog `json:"logs,omitempty"`
			Pagination *struct {
				HasMore *bool `json:"hasMore,omitempty"`
				Limit   *int  `json:"limit,omitempty"`

				// Pages Total number of pages
				Pages *int `json:"pages,omitempty"`
				Skip  *int `json:"skip,omitempty"`

				// Total Total number of logs matching the query
				Total *int `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLogResponse parses an HTTP response from a GetLogWithResponse call
func ParseGetLogResponse(rsp *http.Response) (*GetLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Log *PostLogDetail `json:"log,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMediaPresignedUrlResponse parses an HTTP response from a GetMediaPresignedUrlWithResponse call
func ParseGetMediaPresignedUrlResponse(rsp *http.Response) (*GetMediaPresignedUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaPresignedUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Storage key/path of the file
			Key *string `json:"key,omitempty"`

			// PublicUrl Public URL where the file will be accessible after upload
			PublicUrl *string `json:"publicUrl,omitempty"`

			// Type Detected file type based on content type
			Type *GetMediaPresignedUrl200Type `json:"type,omitempty"`

			// UploadUrl Presigned URL to PUT your file to (expires in 1 hour)
			UploadUrl *string `json:"uploadUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPostsResponse parses an HTTP response from a ListPostsWithResponse call
func ParseListPostsResponse(rsp *http.Response) (*ListPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePostResponse parses an HTTP response from a CreatePostWithResponse call
func ParseCreatePostResponse(rsp *http.Response) (*CreatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Details *struct {
				AccountId      *string `json:"accountId,omitempty"`
				ExistingPostId *string `json:"existingPostId,omitempty"`
				Platform       *string `json:"platform,omitempty"`
			} `json:"details,omitempty"`
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Details Additional context about the rate limit
			Details *map[string]interface{} `json:"details,omitempty"`
			Error   *string                 `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseBulkUploadPostsResponse parses an HTTP response from a BulkUploadPostsWithResponse call
func ParseBulkUploadPostsResponse(rsp *http.Response) (*BulkUploadPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Created *int `json:"created,omitempty"`
			Errors  *[]struct {
				Error *string `json:"error,omitempty"`
				Row   *int    `json:"row,omitempty"`
			} `json:"errors,omitempty"`
			Failed    *int    `json:"failed,omitempty"`
			Posts     *[]Post `json:"posts,omitempty"`
			Success   *bool   `json:"success,omitempty"`
			TotalRows *int    `json:"totalRows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Details *map[string]interface{} `json:"details,omitempty"`
			Error   *string                 `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePostResponse parses an HTTP response from a DeletePostWithResponse call
func ParseDeletePostResponse(rsp *http.Response) (*DeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPostResponse parses an HTTP response from a GetPostWithResponse call
func ParseGetPostResponse(rsp *http.Response) (*GetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePostResponse parses an HTTP response from a UpdatePostWithResponse call
func ParseUpdatePostResponse(rsp *http.Response) (*UpdatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPostLogsResponse parses an HTTP response from a GetPostLogsWithResponse call
func ParseGetPostLogsResponse(rsp *http.Response) (*GetPostLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of logs returned
			Count  *int       `json:"count,omitempty"`
			Logs   *[]PostLog `json:"logs,omitempty"`
			PostId *string    `json:"postId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRetryPostResponse parses an HTTP response from a RetryPostWithResponse call
func ParseRetryPostResponse(rsp *http.Response) (*RetryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostRetryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Details *map[string]interface{} `json:"details,omitempty"`
			Error   *string                 `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListProfilesResponse parses an HTTP response from a ListProfilesWithResponse call
func ParseListProfilesResponse(rsp *http.Response) (*ListProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfilesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateProfileResponse parses an HTTP response from a CreateProfileWithResponse call
func ParseCreateProfileResponse(rsp *http.Response) (*CreateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProfileCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteProfileResponse parses an HTTP response from a DeleteProfileWithResponse call
func ParseDeleteProfileResponse(rsp *http.Response) (*DeleteProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProfileResponse parses an HTTP response from a GetProfileWithResponse call
func ParseGetProfileResponse(rsp *http.Response) (*GetProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Profile *Profile `json:"profile,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string  `json:"message,omitempty"`
			Profile *Profile `json:"profile,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetNextQueueSlotResponse parses an HTTP response from a GetNextQueueSlotWithResponse call
func ParseGetNextQueueSlotResponse(rsp *http.Response) (*GetNextQueueSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNextQueueSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextSlot  *time.Time `json:"nextSlot,omitempty"`
			ProfileId *string    `json:"profileId,omitempty"`

			// QueueId Queue ID this slot belongs to
			QueueId *string `json:"queueId,omitempty"`

			// QueueName Queue name
			QueueName *string `json:"queueName,omitempty"`
			Timezone  *string `json:"timezone,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePreviewQueueResponse parses an HTTP response from a PreviewQueueWithResponse call
func ParsePreviewQueueResponse(rsp *http.Response) (*PreviewQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Count     *int         `json:"count,omitempty"`
			ProfileId *string      `json:"profileId,omitempty"`
			Slots     *[]time.Time `json:"slots,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteQueueSlotResponse parses an HTTP response from a DeleteQueueSlotWithResponse call
func ParseDeleteQueueSlotResponse(rsp *http.Response) (*DeleteQueueSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQueueSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deleted *bool `json:"deleted,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListQueueSlotsResponse parses an HTTP response from a ListQueueSlotsWithResponse call
func ParseListQueueSlotsResponse(rsp *http.Response) (*ListQueueSlotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQueueSlotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateQueueSlotResponse parses an HTTP response from a CreateQueueSlotWithResponse call
func ParseCreateQueueSlotResponse(rsp *http.Response) (*CreateQueueSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQueueSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			NextSlots *[]time.Time   `json:"nextSlots,omitempty"`
			Schedule  *QueueSchedule `json:"schedule,omitempty"`
			Success   *bool          `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateQueueSlotResponse parses an HTTP response from a UpdateQueueSlotWithResponse call
func ParseUpdateQueueSlotResponse(rsp *http.Response) (*UpdateQueueSlotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateQueueSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextSlots       *[]time.Time   `json:"nextSlots,omitempty"`
			ReshuffledCount *int           `json:"reshuffledCount,omitempty"`
			Schedule        *QueueSchedule `json:"schedule,omitempty"`
			Success         *bool          `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRedditFeedResponse parses an HTTP response from a GetRedditFeedWithResponse call
func ParseGetRedditFeedResponse(rsp *http.Response) (*GetRedditFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRedditFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			After *string                   `json:"after,omitempty"`
			Posts *[]map[string]interface{} `json:"posts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSearchRedditResponse parses an HTTP response from a SearchRedditWithResponse call
func ParseSearchRedditResponse(rsp *http.Response) (*SearchRedditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRedditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			After *string `json:"after,omitempty"`
			Posts *[]struct {
				Author      *string  `json:"author,omitempty"`
				CreatedUtc  *float32 `json:"created_utc,omitempty"`
				Id          *string  `json:"id,omitempty"`
				NumComments *int     `json:"num_comments,omitempty"`
				Permalink   *string  `json:"permalink,omitempty"`
				Score       *int     `json:"score,omitempty"`
				Selftext    *string  `json:"selftext,omitempty"`
				Subreddit   *string  `json:"subreddit,omitempty"`
				Title       *string  `json:"title,omitempty"`
			} `json:"posts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDownloadBlueskyMediaResponse parses an HTTP response from a DownloadBlueskyMediaWithResponse call
func ParseDownloadBlueskyMediaResponse(rsp *http.Response) (*DownloadBlueskyMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadBlueskyMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Success     *bool   `json:"success,omitempty"`
			Text        *string `json:"text,omitempty"`
			Thumbnail   *string `json:"thumbnail,omitempty"`
			Title       *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadFacebookVideoResponse parses an HTTP response from a DownloadFacebookVideoWithResponse call
func ParseDownloadFacebookVideoResponse(rsp *http.Response) (*DownloadFacebookVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadFacebookVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Success     *bool   `json:"success,omitempty"`
			Thumbnail   *string `json:"thumbnail,omitempty"`
			Title       *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadInstagramMediaResponse parses an HTTP response from a DownloadInstagramMediaWithResponse call
func ParseDownloadInstagramMediaResponse(rsp *http.Response) (*DownloadInstagramMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadInstagramMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Success     *bool   `json:"success,omitempty"`
			Title       *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckInstagramHashtagsResponse parses an HTTP response from a CheckInstagramHashtagsWithResponse call
func ParseCheckInstagramHashtagsResponse(rsp *http.Response) (*CheckInstagramHashtagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckInstagramHashtagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]struct {
				Confidence *float32                                `json:"confidence,omitempty"`
				Hashtag    *string                                 `json:"hashtag,omitempty"`
				Reason     *string                                 `json:"reason,omitempty"`
				Status     *CheckInstagramHashtags200ResultsStatus `json:"status,omitempty"`
			} `json:"results,omitempty"`
			Success *bool `json:"success,omitempty"`
			Summary *struct {
				Banned     *int `json:"banned,omitempty"`
				Restricted *int `json:"restricted,omitempty"`
				Safe       *int `json:"safe,omitempty"`
			} `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadLinkedInVideoResponse parses an HTTP response from a DownloadLinkedInVideoWithResponse call
func ParseDownloadLinkedInVideoResponse(rsp *http.Response) (*DownloadLinkedInVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadLinkedInVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Success     *bool   `json:"success,omitempty"`
			Title       *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadTikTokVideoResponse parses an HTTP response from a DownloadTikTokVideoWithResponse call
func ParseDownloadTikTokVideoResponse(rsp *http.Response) (*DownloadTikTokVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadTikTokVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Formats     *[]struct {
				Ext   *string `json:"ext,omitempty"`
				Id    *string `json:"id,omitempty"`
				Label *string `json:"label,omitempty"`
			} `json:"formats,omitempty"`
			Success *bool   `json:"success,omitempty"`
			Title   *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadTwitterMediaResponse parses an HTTP response from a DownloadTwitterMediaWithResponse call
func ParseDownloadTwitterMediaResponse(rsp *http.Response) (*DownloadTwitterMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadTwitterMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Success     *bool   `json:"success,omitempty"`
			Title       *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadYouTubeVideoResponse parses an HTTP response from a DownloadYouTubeVideoWithResponse call
func ParseDownloadYouTubeVideoResponse(rsp *http.Response) (*DownloadYouTubeVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadYouTubeVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DownloadUrl *string `json:"downloadUrl,omitempty"`
			Formats     *[]struct {
				Ext    *string `json:"ext,omitempty"`
				Height *int    `json:"height,omitempty"`
				Id     *string `json:"id,omitempty"`
				Label  *string `json:"label,omitempty"`
				Type   *string `json:"type,omitempty"`
				Width  *int    `json:"width,omitempty"`
			} `json:"formats,omitempty"`
			Success *bool   `json:"success,omitempty"`
			Title   *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetYouTubeTranscriptResponse parses an HTTP response from a GetYouTubeTranscriptWithResponse call
func ParseGetYouTubeTranscriptResponse(rsp *http.Response) (*GetYouTubeTranscriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetYouTubeTranscriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FullText *string `json:"fullText,omitempty"`
			Language *string `json:"language,omitempty"`
			Segments *[]struct {
				Duration *float32 `json:"duration,omitempty"`
				Start    *float32 `json:"start,omitempty"`
				Text     *string  `json:"text,omitempty"`
			} `json:"segments,omitempty"`
			Success *bool   `json:"success,omitempty"`
			VideoId *string `json:"videoId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsageStatsResponse parses an HTTP response from a GetUsageStatsWithResponse call
func ParseGetUsageStatsResponse(rsp *http.Response) (*GetUsageStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CurrentUserId *string `json:"currentUserId,omitempty"`
			Users         *[]struct {
				UnderscoreId  *string    `json:"_id,omitempty"`
				CreatedAt     *time.Time `json:"createdAt,omitempty"`
				Email         *string    `json:"email,omitempty"`
				IsRoot        *bool      `json:"isRoot,omitempty"`
				Name          *string    `json:"name,omitempty"`
				ProfileAccess *[]string  `json:"profileAccess,omitempty"`
				Role          *string    `json:"role,omitempty"`
			} `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User *struct {
				UnderscoreId  *string   `json:"_id,omitempty"`
				Email         *string   `json:"email,omitempty"`
				IsRoot        *bool     `json:"isRoot,omitempty"`
				Name          *string   `json:"name,omitempty"`
				ProfileAccess *[]string `json:"profileAccess,omitempty"`
				Role          *string   `json:"role,omitempty"`
			} `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWebhookLogsResponse parses an HTTP response from a GetWebhookLogsWithResponse call
func ParseGetWebhookLogsResponse(rsp *http.Response) (*GetWebhookLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Logs *[]WebhookLog `json:"logs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookSettingsResponse parses an HTTP response from a DeleteWebhookSettingsWithResponse call
func ParseDeleteWebhookSettingsResponse(rsp *http.Response) (*DeleteWebhookSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetWebhookSettingsResponse parses an HTTP response from a GetWebhookSettingsWithResponse call
func ParseGetWebhookSettingsResponse(rsp *http.Response) (*GetWebhookSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Webhooks *[]Webhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateWebhookSettingsResponse parses an HTTP response from a CreateWebhookSettingsWithResponse call
func ParseCreateWebhookSettingsResponse(rsp *http.Response) (*CreateWebhookSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`

			// Webhook Individual webhook configuration for receiving real-time notifications
			Webhook *Webhook `json:"webhook,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookSettingsResponse parses an HTTP response from a UpdateWebhookSettingsWithResponse call
func ParseUpdateWebhookSettingsResponse(rsp *http.Response) (*UpdateWebhookSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`

			// Webhook Individual webhook configuration for receiving real-time notifications
			Webhook *Webhook `json:"webhook,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseTestWebhookResponse parses an HTTP response from a TestWebhookWithResponse call
func ParseTestWebhookResponse(rsp *http.Response) (*TestWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
